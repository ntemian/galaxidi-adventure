<!DOCTYPE html>
<html lang="el">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Το Μυστήριο του Γαλαξειδίου — Canvas Engine</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
  body { background: #000; overflow: hidden; font-family: 'Press Start 2P', monospace; display: flex; flex-direction: column; height: 100vh; }

  /* ── CANVAS ── */
  #game-canvas {
    display: block; background: #0a0812;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    cursor: crosshair;
    flex: 1;
    width: 100%;
    min-height: 0;
  }

  /* ── ACTION LINE — Trunk wood strip ── */
  #action-line {
    height: 36px; display: none; align-items: center; justify-content: center;
    font-family: 'Press Start 2P', monospace;
    font-size: .65rem; color: #FFE8A0; letter-spacing: 1px;
    background:
      /* Tree ring curves flowing through */
      radial-gradient(ellipse 120px 200px at -10% 50%, transparent 65%, rgba(45,28,8,0.12) 66%, transparent 67%, transparent 72%, rgba(40,25,8,0.08) 73%, transparent 74%),
      radial-gradient(ellipse 140px 220px at 110% 50%, transparent 60%, rgba(42,26,8,0.1) 61%, transparent 62%, transparent 68%, rgba(48,30,10,0.07) 69%, transparent 70%),
      /* Grain lines */
      repeating-linear-gradient(87deg, transparent 0px, transparent 5px, rgba(80,55,20,0.1) 5px, rgba(80,55,20,0.1) 6px, transparent 6px, transparent 18px),
      repeating-linear-gradient(93deg, transparent 0px, transparent 11px, rgba(0,0,0,0.07) 11px, rgba(0,0,0,0.07) 12px, transparent 12px, transparent 30px),
      /* Stains */
      radial-gradient(ellipse 80px 20px at 25% 60%, rgba(90,60,20,0.12) 0%, transparent 100%),
      radial-gradient(ellipse 60px 18px at 70% 30%, rgba(40,25,8,0.1) 0%, transparent 100%),
      linear-gradient(180deg, #5a4228 0%, #4e3820 20%, #3e2c18 50%, #4a3620 75%, #2e1e0e 100%);
    border-top: 3px solid #8a6e42;
    border-bottom: 2px solid #1a0e04;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.9), 0 0 10px rgba(255,220,120,0.25);
    box-shadow: inset 0 1px 0 rgba(255,220,160,0.12), inset 0 -1px 0 rgba(0,0,0,0.3);
  }
  #action-line.on { display: flex; }

  /* ── UI PANEL — MI2 rough-hewn trunk wood ── */
  #ui-panel {
    background:
      /* === ETCHED ROSES — carved into the wood === */
      /* Rose 1 — top-left, full bloom */
      radial-gradient(ellipse 11px 10px at 8% 18%, rgba(90,25,15,0.22) 0%, rgba(65,18,10,0.12) 45%, transparent 100%),
      radial-gradient(ellipse 14px 13px at 8% 18%, transparent 55%, rgba(75,20,12,0.1) 60%, transparent 68%),
      radial-gradient(ellipse 18px 16px at 8% 18%, transparent 62%, rgba(60,16,8,0.07) 66%, transparent 74%),
      radial-gradient(ellipse 8px 10px at 6% 15%, rgba(95,28,18,0.15) 0%, transparent 70%),
      radial-gradient(ellipse 9px 7px at 10% 21%, rgba(85,22,14,0.13) 0%, transparent 65%),
      radial-gradient(ellipse 7px 9px at 7% 22%, rgba(80,20,12,0.11) 0%, transparent 60%),
      /* Rose 2 — center-right, bud */
      radial-gradient(ellipse 9px 8px at 72% 28%, rgba(85,22,14,0.2) 0%, rgba(60,16,8,0.1) 50%, transparent 100%),
      radial-gradient(ellipse 12px 11px at 72% 28%, transparent 50%, rgba(70,18,10,0.08) 56%, transparent 65%),
      radial-gradient(ellipse 7px 8px at 70% 25%, rgba(90,25,16,0.12) 0%, transparent 65%),
      radial-gradient(ellipse 6px 7px at 74% 31%, rgba(80,20,12,0.1) 0%, transparent 60%),
      /* Rose 3 — bottom-center */
      radial-gradient(ellipse 10px 9px at 45% 82%, rgba(88,24,15,0.18) 0%, rgba(62,17,9,0.09) 48%, transparent 100%),
      radial-gradient(ellipse 14px 12px at 45% 82%, transparent 52%, rgba(68,18,10,0.07) 58%, transparent 68%),
      radial-gradient(ellipse 8px 9px at 43% 79%, rgba(92,26,16,0.12) 0%, transparent 65%),
      radial-gradient(ellipse 7px 8px at 47% 85%, rgba(82,21,13,0.1) 0%, transparent 60%),
      /* Rose 4 — far right */
      radial-gradient(ellipse 7px 6px at 92% 65%, rgba(80,20,12,0.18) 0%, rgba(55,14,7,0.08) 50%, transparent 100%),
      radial-gradient(ellipse 10px 9px at 92% 65%, transparent 48%, rgba(65,16,8,0.07) 55%, transparent 65%),
      /* === TWISTING VINES — carved S-curves === */
      radial-gradient(ellipse 300px 180px at -5% -20%, transparent 96%, rgba(28,45,15,0.14) 96.5%, rgba(28,45,15,0.14) 97%, transparent 97.5%),
      radial-gradient(ellipse 280px 200px at 35% 130%, transparent 93%, rgba(25,40,12,0.12) 93.5%, rgba(25,40,12,0.12) 94%, transparent 94.5%),
      radial-gradient(ellipse 320px 160px at 70% -30%, transparent 95%, rgba(30,48,16,0.13) 95.5%, rgba(30,48,16,0.13) 96%, transparent 96.5%),
      radial-gradient(ellipse 250px 180px at 105% 120%, transparent 94%, rgba(26,42,14,0.11) 94.5%, rgba(26,42,14,0.11) 95%, transparent 95.5%),
      radial-gradient(ellipse 200px 120px at 15% 110%, transparent 95.5%, rgba(22,38,12,0.1) 96%, rgba(22,38,12,0.1) 96.3%, transparent 96.8%),
      radial-gradient(ellipse 180px 140px at 85% -10%, transparent 94.5%, rgba(24,40,13,0.09) 95%, rgba(24,40,13,0.09) 95.3%, transparent 95.8%),
      /* === THORNS === */
      radial-gradient(ellipse 3px 6px at 12% 35%, rgba(30,48,16,0.16) 0%, transparent 100%),
      radial-gradient(ellipse 3px 5px at 25% 72%, rgba(28,45,14,0.14) 0%, transparent 100%),
      radial-gradient(ellipse 4px 6px at 38% 25%, rgba(32,50,18,0.13) 0%, transparent 100%),
      radial-gradient(ellipse 3px 5px at 55% 80%, rgba(26,42,13,0.15) 0%, transparent 100%),
      radial-gradient(ellipse 3px 6px at 65% 38%, rgba(30,48,16,0.12) 0%, transparent 100%),
      radial-gradient(ellipse 4px 5px at 78% 70%, rgba(28,45,14,0.14) 0%, transparent 100%),
      radial-gradient(ellipse 3px 6px at 88% 42%, rgba(32,50,18,0.11) 0%, transparent 100%),
      /* === LEAVES along vines === */
      radial-gradient(ellipse 10px 5px at 15% 30%, rgba(30,52,18,0.14) 0%, rgba(25,42,14,0.06) 50%, transparent 100%),
      radial-gradient(ellipse 8px 4px at 22% 68%, rgba(28,48,16,0.12) 0%, transparent 100%),
      radial-gradient(ellipse 9px 5px at 35% 22%, rgba(32,55,20,0.11) 0%, transparent 100%),
      radial-gradient(ellipse 11px 5px at 52% 78%, rgba(26,45,15,0.13) 0%, transparent 100%),
      radial-gradient(ellipse 8px 4px at 62% 35%, rgba(30,50,18,0.1) 0%, transparent 100%),
      radial-gradient(ellipse 10px 5px at 75% 68%, rgba(28,48,16,0.12) 0%, transparent 100%),
      radial-gradient(ellipse 9px 4px at 85% 40%, rgba(32,52,18,0.1) 0%, transparent 100%),
      radial-gradient(ellipse 7px 4px at 48% 15%, rgba(26,44,14,0.11) 0%, transparent 100%),
      /* === TREE RINGS === */
      radial-gradient(ellipse 180px 300px at -20% 50%,
        transparent 58%, rgba(45,28,8,0.12) 59%, transparent 60%,
        transparent 63%, rgba(50,30,10,0.08) 64%, transparent 65%,
        transparent 69%, rgba(40,25,8,0.1) 70%, transparent 71%,
        transparent 76%, rgba(55,35,12,0.07) 77%, transparent 78%
      ),
      radial-gradient(ellipse 200px 350px at 110% 40%,
        transparent 55%, rgba(40,25,8,0.1) 56%, transparent 57%,
        transparent 61%, rgba(50,32,10,0.07) 62%, transparent 63%,
        transparent 68%, rgba(42,26,8,0.09) 69%, transparent 70%
      ),
      /* === GRAIN LINES === */
      repeating-linear-gradient(87deg, transparent 0px, transparent 4px, rgba(0,0,0,0.07) 4px, rgba(0,0,0,0.07) 5.5px, transparent 5.5px, transparent 10px, rgba(55,35,12,0.05) 10px, rgba(55,35,12,0.05) 11px, transparent 11px, transparent 18px),
      repeating-linear-gradient(92deg, transparent 0px, transparent 6px, rgba(0,0,0,0.05) 6px, rgba(0,0,0,0.05) 7px, transparent 7px, transparent 15px, rgba(60,40,15,0.04) 15px, rgba(60,40,15,0.04) 16px, transparent 16px, transparent 25px),
      /* === KNOTS === */
      radial-gradient(ellipse 18px 14px at 18% 45%, rgba(20,10,2,0.3) 0%, rgba(35,20,5,0.15) 35%, transparent 60%),
      radial-gradient(ellipse 12px 10px at 62% 60%, rgba(22,12,3,0.25) 0%, rgba(40,25,8,0.1) 40%, transparent 65%),
      /* === WORN patches === */
      radial-gradient(ellipse 80px 45px at 30% 50%, rgba(100,70,30,0.06) 0%, transparent 100%),
      radial-gradient(ellipse 70px 40px at 78% 55%, rgba(90,62,25,0.05) 0%, transparent 100%),
      /* === BASE wood === */
      linear-gradient(180deg,
        #6b5030 0%, #5e4528 5%, #523c22 12%, #5a4428 18%,
        #4a3620 28%, #523e24 35%, #443018 45%, #4e3a22 55%,
        #3e2c16 62%, #463420 70%, #382814 78%, #3e3018 85%,
        #2e2010 93%, #241a0c 100%
      );
    border-top: 4px solid #7a5e38;
    display: none; flex-direction: column;
    box-shadow:
      inset 0 2px 0 rgba(255,200,120,0.1),
      inset 0 -3px 6px rgba(0,0,0,0.5),
      0 -2px 8px rgba(0,0,0,0.5);
    position: relative;
    overflow: hidden;
  }
  #ui-panel.on { display: flex; }
  /* Vine + rosette border along top */
  #ui-panel::before {
    content: '';
    position: absolute; top: 0; left: 0; right: 0; height: 8px;
    background:
      radial-gradient(ellipse 40px 12px at 10% 60%, rgba(30,50,18,0.18) 0%, transparent 80%),
      radial-gradient(ellipse 35px 10px at 30% 40%, rgba(28,46,16,0.15) 0%, transparent 75%),
      radial-gradient(ellipse 45px 12px at 50% 65%, rgba(32,52,20,0.17) 0%, transparent 80%),
      radial-gradient(ellipse 38px 10px at 70% 35%, rgba(26,44,14,0.14) 0%, transparent 75%),
      radial-gradient(ellipse 42px 12px at 90% 55%, rgba(30,48,18,0.16) 0%, transparent 80%),
      radial-gradient(circle 3px at 20% 50%, rgba(90,25,15,0.2) 0%, rgba(70,18,10,0.08) 50%, transparent 100%),
      radial-gradient(circle 3px at 50% 50%, rgba(85,22,14,0.18) 0%, transparent 100%),
      radial-gradient(circle 3px at 80% 50%, rgba(88,24,15,0.2) 0%, transparent 100%),
      linear-gradient(180deg, rgba(138,110,66,0.6) 0%, rgba(100,78,40,0.3) 40%, transparent 100%);
    pointer-events: none; z-index: 1;
  }
  /* Bottom vine border */
  #ui-panel::after {
    content: '';
    position: absolute; bottom: 0; left: 0; right: 0; height: 6px;
    background:
      radial-gradient(ellipse 35px 10px at 15% 40%, rgba(28,46,16,0.15) 0%, transparent 75%),
      radial-gradient(ellipse 40px 12px at 40% 60%, rgba(30,50,18,0.16) 0%, transparent 80%),
      radial-gradient(ellipse 38px 10px at 65% 35%, rgba(26,44,14,0.14) 0%, transparent 75%),
      radial-gradient(ellipse 42px 12px at 88% 55%, rgba(32,52,20,0.16) 0%, transparent 80%),
      radial-gradient(circle 2.5px at 28% 50%, rgba(88,24,15,0.18) 0%, transparent 100%),
      radial-gradient(circle 2.5px at 55% 50%, rgba(85,22,14,0.16) 0%, transparent 100%),
      radial-gradient(circle 2.5px at 78% 50%, rgba(90,25,15,0.18) 0%, transparent 100%),
      linear-gradient(180deg, transparent 0%, rgba(26,16,8,0.4) 60%, rgba(20,12,4,0.6) 100%);
    pointer-events: none; z-index: 1;
  }

  /* Bottom row: verbs LEFT, inventory RIGHT */
  #ui-bottom {
    display: flex; height: 150px; padding: 8px 10px;
  }

  /* ── VERB GRID — Rough carved buttons ── */
  #verb-panel {
    display: grid; grid-template-columns: repeat(2, 1fr); grid-template-rows: repeat(2, 1fr);
    gap: 5px; width: 300px; flex-shrink: 0;
  }
  .vb {
    font-family: 'Press Start 2P', monospace; font-size: .6rem; color: #c8a868;
    background:
      /* Tree ring arc through button */
      radial-gradient(ellipse 80px 120px at -15% 50%,
        transparent 55%, rgba(42,26,8,0.13) 56%, transparent 57%,
        transparent 63%, rgba(38,22,6,0.09) 64%, transparent 65%
      ),
      /* Grain lines at angles */
      repeating-linear-gradient(86deg, transparent 0px, transparent 4px, rgba(0,0,0,0.07) 4px, rgba(0,0,0,0.07) 5.5px, transparent 5.5px, transparent 11px),
      repeating-linear-gradient(93deg, transparent 0px, transparent 8px, rgba(60,40,15,0.05) 8px, rgba(60,40,15,0.05) 9px, transparent 9px, transparent 20px),
      /* Small knot */
      radial-gradient(ellipse 8px 6px at 75% 35%, rgba(25,14,4,0.2) 0%, rgba(40,25,8,0.08) 50%, transparent 100%),
      /* Uneven color patches */
      radial-gradient(ellipse 40px 25px at 30% 40%, rgba(70,48,18,0.12) 0%, transparent 100%),
      radial-gradient(ellipse 35px 20px at 70% 60%, rgba(40,25,8,0.1) 0%, transparent 100%),
      linear-gradient(180deg, #4a3822 0%, #3e2e18 25%, #3a2a16 50%, #352814 75%, #2e2010 100%);
    border: 3px solid #5a4428;
    border-top-color: #7a6040; border-left-color: #6a5438;
    border-bottom-color: #2a1c0c; border-right-color: #2a1c0c;
    cursor: pointer; transition: all .12s;
    display: flex; align-items: center; justify-content: center;
    padding: 4px 8px; text-align: center;
    text-shadow: 1px 1px 1px rgba(0,0,0,0.8), 0 1px 0 rgba(0,0,0,0.5);
    box-shadow:
      inset 0 1px 0 rgba(255,200,120,0.08),
      inset -1px -1px 0 rgba(0,0,0,0.15),
      2px 2px 4px rgba(0,0,0,0.45);
    border-radius: 1px;
  }
  .vb:hover {
    color: #FFE090;
    background:
      radial-gradient(ellipse 80px 120px at -15% 50%, transparent 55%, rgba(52,34,12,0.13) 56%, transparent 57%, transparent 63%, rgba(48,30,10,0.09) 64%, transparent 65%),
      repeating-linear-gradient(86deg, transparent 0px, transparent 4px, rgba(0,0,0,0.07) 4px, rgba(0,0,0,0.07) 5.5px, transparent 5.5px, transparent 11px),
      repeating-linear-gradient(93deg, transparent 0px, transparent 8px, rgba(60,40,15,0.05) 8px, rgba(60,40,15,0.05) 9px, transparent 9px, transparent 20px),
      radial-gradient(ellipse 8px 6px at 75% 35%, rgba(25,14,4,0.2) 0%, rgba(40,25,8,0.08) 50%, transparent 100%),
      radial-gradient(ellipse 40px 25px at 30% 40%, rgba(90,60,22,0.12) 0%, transparent 100%),
      linear-gradient(180deg, #5a4828 0%, #4e3e20 30%, #443418 60%, #3a2c14 100%);
    border-top-color: #9a7848; border-left-color: #8a6840;
    text-shadow: 0 0 8px rgba(255,224,144,0.3), 1px 1px 1px rgba(0,0,0,0.8);
    box-shadow:
      inset 0 1px 0 rgba(255,200,120,0.12),
      inset -1px -1px 0 rgba(0,0,0,0.1),
      2px 2px 5px rgba(0,0,0,0.35),
      0 0 8px rgba(180,140,60,0.08);
  }
  .vb:active { transform: scale(.97); }
  .vb.on {
    color: #FFE8A0;
    background:
      radial-gradient(ellipse 80px 120px at -15% 50%, transparent 55%, rgba(55,38,14,0.12) 56%, transparent 57%, transparent 63%, rgba(50,32,12,0.08) 64%, transparent 65%),
      repeating-linear-gradient(86deg, transparent 0px, transparent 4px, rgba(255,180,60,0.05) 4px, rgba(255,180,60,0.05) 5.5px, transparent 5.5px, transparent 11px),
      radial-gradient(ellipse 8px 6px at 75% 35%, rgba(25,14,4,0.18) 0%, rgba(40,25,8,0.06) 50%, transparent 100%),
      radial-gradient(ellipse 50px 30px at 50% 50%, rgba(100,70,25,0.12) 0%, transparent 100%),
      linear-gradient(180deg, #5e4828 0%, #503c1e 30%, #483416 60%, #3e2c12 100%);
    border: 3px solid #B8903C;
    border-top-color: #D4A848; border-left-color: #C49840;
    border-bottom-color: #705020; border-right-color: #705020;
    text-shadow: 0 0 10px rgba(255,232,160,0.4), 1px 1px 1px rgba(0,0,0,0.8);
    box-shadow:
      inset 0 1px 0 rgba(255,200,120,0.15),
      inset -1px -1px 0 rgba(0,0,0,0.08),
      0 0 12px rgba(212,168,72,0.18),
      2px 2px 4px rgba(0,0,0,0.3);
  }

  /* ── INVENTORY — Dark recessed hold ── */
  #inv-panel {
    flex: 1; display: flex; align-items: stretch;
    margin-left: 10px;
    border: 3px solid #3a2a16;
    border-top-color: #221408; border-left-color: #221408;
    border-bottom-color: #6a5438; border-right-color: #5a4428;
    background:
      /* Tree ring arcs inside the hold */
      radial-gradient(ellipse 150px 250px at -5% 50%,
        transparent 58%, rgba(35,20,5,0.1) 59%, transparent 60%,
        transparent 66%, rgba(30,18,4,0.07) 67%, transparent 68%,
        transparent 75%, rgba(32,19,5,0.06) 76%, transparent 77%
      ),
      radial-gradient(ellipse 130px 200px at 105% 40%,
        transparent 55%, rgba(32,18,4,0.08) 56%, transparent 57%,
        transparent 63%, rgba(28,16,4,0.06) 64%, transparent 65%
      ),
      /* Dark wood grain inside */
      repeating-linear-gradient(87deg, transparent 0px, transparent 5px, rgba(0,0,0,0.08) 5px, rgba(0,0,0,0.08) 6.5px, transparent 6.5px, transparent 14px),
      repeating-linear-gradient(92deg, transparent 0px, transparent 9px, rgba(40,25,8,0.06) 9px, rgba(40,25,8,0.06) 10px, transparent 10px, transparent 22px),
      /* Dark knot */
      radial-gradient(ellipse 14px 11px at 35% 45%, rgba(15,8,2,0.2) 0%, rgba(25,14,4,0.08) 50%, transparent 100%),
      /* Wear stains */
      radial-gradient(ellipse 60px 30px at 55% 50%, rgba(50,35,12,0.1) 0%, transparent 100%),
      radial-gradient(ellipse 50px 25px at 80% 30%, rgba(30,18,5,0.08) 0%, transparent 100%),
      linear-gradient(180deg, #1a1206 0%, #221a0a 15%, #201808 30%, #241c0c 45%, #1e1608 60%, #28200e 75%, #1a1408 90%, #161008 100%);
    box-shadow:
      inset 0 4px 8px rgba(0,0,0,0.6),
      inset 0 -1px 0 rgba(255,200,120,0.04),
      inset 4px 0 8px rgba(0,0,0,0.35),
      inset -4px 0 8px rgba(0,0,0,0.35);
    border-radius: 2px;
    padding: 0;
  }
  #inv-label { display: none; }
  #inv-arrows {
    display: flex; flex-direction: column; justify-content: center;
    gap: 8px; padding: 6px 8px; flex-shrink: 0;
    border-right: 2px solid #1e1408;
    background:
      radial-gradient(ellipse 20px 40px at 50% 50%, rgba(50,35,12,0.1) 0%, transparent 100%),
      linear-gradient(180deg, rgba(0,0,0,0.12) 0%, transparent 40%, transparent 60%, rgba(0,0,0,0.12) 100%);
  }
  #inv-arrows button {
    font-size: .8rem; color: #B89858;
    background:
      repeating-linear-gradient(89deg, transparent 0px, transparent 5px, rgba(0,0,0,0.05) 5px, rgba(0,0,0,0.05) 6px, transparent 6px, transparent 14px),
      linear-gradient(180deg, #4a3822 0%, #3a2c18 40%, #352814 70%, #302410 100%);
    border: 2px solid #5a4428;
    border-top-color: #7a6040; border-left-color: #6a5438;
    border-bottom-color: #2a1c0c; border-right-color: #2a1c0c;
    cursor: pointer; padding: 8px 10px; line-height: 1;
    transition: all .12s;
    border-radius: 1px;
    box-shadow: 1px 2px 3px rgba(0,0,0,0.4);
    text-shadow: 0 1px 1px rgba(0,0,0,0.6);
  }
  #inv-arrows button:hover {
    color: #FFE090; border-top-color: #9a7848;
    background:
      repeating-linear-gradient(89deg, transparent 0px, transparent 5px, rgba(0,0,0,0.05) 5px, rgba(0,0,0,0.05) 6px, transparent 6px, transparent 14px),
      linear-gradient(180deg, #5a4828 0%, #4a3820 40%, #403018 70%, #3a2c16 100%);
    text-shadow: 0 0 6px rgba(255,224,144,0.25);
    box-shadow: 1px 2px 3px rgba(0,0,0,0.3), 0 0 6px rgba(180,140,60,0.08);
  }
  #inv-grid {
    flex: 1; display: grid;
    grid-template-columns: repeat(auto-fill, 60px);
    grid-template-rows: repeat(2, 60px);
    grid-auto-flow: column;
    gap: 5px; padding: 6px;
    overflow: hidden;
    align-content: center;
  }
  .inv-slot {
    width: 60px; height: 60px;
    background:
      /* Subtle grain inside slots */
      repeating-linear-gradient(90deg, transparent 0px, transparent 6px, rgba(0,0,0,0.04) 6px, rgba(0,0,0,0.04) 7px, transparent 7px, transparent 15px),
      radial-gradient(ellipse 30px 30px at 50% 50%, rgba(40,28,10,0.1) 0%, transparent 100%),
      linear-gradient(180deg, #141008 0%, #1c1608 35%, #181208 65%, #141008 100%);
    border: 2px solid #3a2c18;
    border-top-color: #1e1408; border-left-color: #1e1408;
    border-bottom-color: #4a3822; border-right-color: #4a3822;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; transition: all .12s;
    box-shadow: inset 0 2px 5px rgba(0,0,0,0.5), inset 0 -1px 0 rgba(255,200,120,0.03);
    border-radius: 1px;
  }
  .inv-slot:hover {
    border-color: #7a5e38;
    border-bottom-color: #9a7848; border-right-color: #8a6838;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.35), 0 0 6px rgba(180,140,60,0.12);
  }
  .inv-slot.on {
    border: 2px solid #B8903C;
    border-top-color: #D4A848; border-left-color: #C49840;
    border-bottom-color: #705020; border-right-color: #705020;
    background:
      repeating-linear-gradient(90deg, transparent 0px, transparent 6px, rgba(255,180,60,0.03) 6px, rgba(255,180,60,0.03) 7px, transparent 7px, transparent 15px),
      linear-gradient(180deg, #2a2010 0%, #322810 50%, #2a2010 100%);
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.2), 0 0 10px rgba(212,168,72,0.2);
  }
  .inv-slot .inv-text {
    font-family: 'Press Start 2P', monospace; font-size: .35rem; color: #c8a868;
    text-align: center; line-height: 1.3;
    text-shadow: 1px 1px 1px rgba(0,0,0,0.7);
  }

  /* ── TITLE (canvas-rendered, no HTML overlay) ── */
  @keyframes blink { 0%,100%{opacity:.3} 50%{opacity:.9} }

  /* ── INTRO OVERLAY ── */
  #intro-screen {
    position: fixed; inset: 0; background: #0a0812;
    display: none; flex-direction: column; align-items: center; justify-content: center;
    z-index: 1500; padding: 2rem; cursor: pointer; transition: opacity 1.5s;
  }
  #intro-screen.show { display: flex; }
  #intro-text { max-width:600px; font-size:clamp(.6rem,1.2vw,.8rem); color:#D4A03C; line-height:2.5; text-align:center; opacity:0; transition: opacity 1.5s; }
  #intro-hint { font-size:.5rem; color:#4a4a4a; margin-top:2rem; opacity:0; transition: opacity .5s; }
  #intro-hint.on { opacity:1; animation: blink 2s infinite; }

  /* ── FADE ── */
  #fade { position: fixed; inset: 0; background: #000; z-index: 3000; opacity: 0; pointer-events: none; transition: opacity .5s; }
  #fade.on { opacity: 1; }
</style>
</head>
<body>

<div id="fade"></div>

<!-- Title screen is canvas-rendered -->

<div id="intro-screen">
  <div id="intro-text"></div>
  <div id="intro-hint">▶ ΚΛΙΚ</div>
</div>

<canvas id="game-canvas" width="640" height="400"></canvas>

<div id="action-line"></div>

<div id="ui-panel">
  <div id="ui-bottom">
    <div id="verb-panel">
      <button class="vb on" data-v="look" onclick="setVerb('look')">Κοίταξε</button>
      <button class="vb" data-v="talk" onclick="setVerb('talk')">Μίλησε</button>
      <button class="vb" data-v="open" onclick="setVerb('open')">Άνοιξε</button>
      <button class="vb" data-v="use" onclick="setVerb('use')">Χρησιμοποίησε</button>
    </div>
    <div id="inv-panel">
      <div id="inv-arrows">
        <button onclick="scrollInv(-1)">▲</button>
        <button onclick="scrollInv(1)">▼</button>
      </div>
      <div id="inv-grid"></div>
    </div>
  </div>
</div>

<audio id="title-music" loop preload="auto"><source src="music/galaxidi-title-theme-1.mp3" type="audio/mpeg"></audio>
<audio id="bgm" loop preload="auto"><source src="music/arrival-at-galaxidi-scene-1-1.mp3" type="audio/mpeg"></audio>

<script>
// ════════════════════════════════════════════════════════════
// CANVAS ENGINE — Pure requestAnimationFrame game loop
// ════════════════════════════════════════════════════════════
const CVS = document.getElementById('game-canvas');
const ctx = CVS.getContext('2d');
const GW = 640, GH = 400; // internal game resolution
CVS.width = GW; CVS.height = GH;

// ════════════════════════════════════════════════════════════
// STATE
// ════════════════════════════════════════════════════════════
const state = {
  phase: 'title', // title, intro, playing
  scene: null,
  verb: 'look',
  inv: [],
  flags: {},
  visited: new Set(),
  tick: 0,
  mouseGX: 0, mouseGY: 0,
  hoverObj: null,
  musicOn: false,
  dlg: { active: false, queue: [], text: '', displayed: '', charIdx: 0, timer: 0, speaker: '', cb: null },
  fade: { active: false, alpha: 0, dir: 0, cb: null },
  introPage: 0,
};

// Characters
const chars = {
  ntemis: { x: 0, y: 0, dir: 1, walking: false, frame: 0, targetX: null, startX: 0, walkT: 0, walkDur: 0, visible: true, fadeIn: 0 },
  ajax:   { x: 0, y: 0, dir: 1, walking: false, frame: 0, targetX: null, startX: 0, walkT: 0, walkDur: 0, visible: true, fadeIn: 0 },
  clio:   { x: 0, y: 0, dir: 1, walking: false, frame: 0, targetX: null, startX: 0, walkT: 0, walkDur: 0, visible: true, fadeIn: 0 },
};

// NPC characters — static, scene-specific
const npcChars = {
  ghost:   { scene: 'graveyard', x: 480, y: 300, dir: -1, visible: true },
  athos:   { scene: 'liotrivi', x: 120, y: 335, dir: 1, visible: true },
  stathis: { scene: 'port', x: 80, y: 340, dir: 1, visible: true },
  akis:    { scene: 'port', x: 150, y: 342, dir: 1, visible: true },
  giannis: { scene: 'windmill', x: 150, y: 340, dir: 1, visible: true },
  curator: { scene: 'museum', x: 100, y: 340, dir: 1, visible: true },
};

let walkDoneCallback = null;

// ════════════════════════════════════════════════════════════
// IMAGE LOADING
// ════════════════════════════════════════════════════════════
const images = {};
function loadImg(key, src) {
  return new Promise(resolve => {
    const img = new Image();
    img.onload = () => { images[key] = img; resolve(img); };
    img.onerror = () => { console.warn('Failed to load:', src); resolve(null); };
    img.src = src;
  });
}

// Character idle sprites
const CHAR_IMGS = {};
const WALK_FRAMES = { ntemis: [], ajax: [], clio: [] };
const PORTRAITS = {};

async function loadAllAssets() {
  // Backgrounds
  await Promise.all([
    loadImg('title-bg', 'assets/title-bg.png'),
    loadImg('bg-exterior', 'assets/pixel-exterior.png'),
    loadImg('bg-terrace', 'assets/pixel-terrace.png'),
    loadImg('bg-kitchen', 'assets/pixel-kitchen.png'),
    loadImg('bg-port', 'assets/pixel-port.png'),
    loadImg('bg-museum', 'assets/pixel-museum.png'),
    loadImg('bg-liotrivi', 'assets/pixel-liotrivi.png'),
    loadImg('bg-cave', 'assets/pixel-cave.png'),
    loadImg('bg-church', 'assets/pixel-church.png'),
    loadImg('bg-windmill', 'assets/pixel-windmill.png'),
    loadImg('bg-boat', 'assets/pixel-boat.png'),
    loadImg('bg-graveyard', 'assets/pixel-graveyard.png'),
  ]);

  // Character idle sprites (family + NPCs)
  const charPromises = ['ntemis','ajax','clio','ghost','athos','stathis','akis','giannis','curator'].map(id =>
    loadImg(`char-${id}`, `assets/char-${id}-final.png`).then(img => { CHAR_IMGS[id] = img; })
  );

  // Portraits (family + NPCs)
  const portPromises = [
    loadImg('port-ntemis', 'assets/portrait-ntemis.png').then(img => { PORTRAITS['ΝΤΕΜΗΣ'] = img; }),
    loadImg('port-ajax', 'assets/portrait-ajax.png').then(img => { PORTRAITS['ΑΙΑΣ'] = img; }),
    loadImg('port-clio', 'assets/portrait-clio.png').then(img => { PORTRAITS['ΚΛΕΙΩ'] = img; }),
    loadImg('port-ghost', 'assets/portrait-ghost.png').then(img => { PORTRAITS['ΦΑΝΤΑΣΜΑ'] = img; }),
    loadImg('port-athos', 'assets/portrait-athos.png').then(img => { PORTRAITS['ΑΘΟΣ'] = img; }),
    loadImg('port-stathis', 'assets/portrait-stathis.png').then(img => { PORTRAITS['ΣΤΑΘΗΣ'] = img; }),
    loadImg('port-akis', 'assets/portrait-akis.png').then(img => { PORTRAITS['ΑΚΗΣ'] = img; }),
    loadImg('port-giannis', 'assets/portrait-giannis.png').then(img => { PORTRAITS['ΓΙΑΝΝΗΣ'] = img; }),
    loadImg('port-curator', 'assets/portrait-curator.png').then(img => { PORTRAITS['ΕΠΙΜΕΛΗΤΗΣ'] = img; }),
  ];

  await Promise.all([...charPromises, ...portPromises]);

  // Walk frames from JSON
  try {
    const resp = await fetch('assets/walk-frames-b64.json');
    const data = await resp.json();
    for (const who of ['ntemis','ajax','clio']) {
      if (data[who]) {
        for (let i = 0; i < data[who].length; i++) {
          const img = new Image();
          img.src = 'data:image/png;base64,' + data[who][i];
          WALK_FRAMES[who].push(img);
        }
      }
    }
  } catch(e) { console.warn('Walk frames load failed:', e); }
}

// ════════════════════════════════════════════════════════════
// SCENES DATA
// ════════════════════════════════════════════════════════════
const scenes = {
  exterior: {
    label: 'ΤΟ ΣΠΙΤΙ — ΓΑΛΑΞΙΔΙ', bg: 'bg-exterior',
    charPos: {
      ntemis: { x: 290, y: 340 },
      ajax:   { x: 370, y: 348 },
      clio:   { x: 210, y: 348 },
    },
    objects: [
      { id:'door', x:115, y:100, w:70, h:120, label:'Πόρτα',
        verbs: { look:[{s:'',t:'Ξύλινη πόρτα βαμμένη μπλε. Το χρώμα του Αιγαίου.'}],
                 open:[{s:'ΝΤΕΜΗΣ',t:'Ας μπούμε μέσα.'}], walk:'kitchen', use:'kitchen' }},
      { id:'bougainvillea', x:175, y:20, w:150, h:120, label:'Μπουκαμβίλιες',
        verbs: { look:[{s:'',t:'Ροζ μπουκαμβίλιες σκαρφαλώνουν στον τοίχο. Εδώ το καλοκαίρι αρνείται να φύγει.'}],
                 pick:[{s:'ΚΛΕΙΩ',t:'Μπαμπά, μην τις κόβεις! Είναι τέλειες έτσι.'}] }},
      { id:'flowerpots', x:75, y:195, w:65, h:55, label:'Γλάστρες',
        verbs: { look:[{s:'',t:'Πήλινες γλάστρες με βασιλικό. Κάποιος τα περιποιείται ακόμα κι όταν το σπίτι μένει κλειστό.'}] }},
      { id:'barrel', x:245, y:180, w:55, h:60, label:'Βαρέλι',
        verbs: { look:[{s:'',t:'Ένα παλιό ξύλινο βαρέλι. Μυρίζει κρασί και αλμύρα.'}],
                 open:[{s:'ΑΙΑΣ',t:'Άδειο. Κρίμα!'}] }},
      { id:'boats', x:380, y:120, w:140, h:80, label:'Ψαροκάικα',
        verbs: { look:[{s:'',t:'Χρωματιστά ψαροκάικα δεμένα στο λιμάνι. Κουνιούνται αργά στο απογευματινό φως.'},{s:'ΑΙΑΣ',t:'Μπαμπά, θα πάμε βόλτα με βάρκα;'}] }},
      { id:'sea', x:350, y:60, w:230, h:60, label:'Η θάλασσα',
        verbs: { look:[{s:'',t:'Ο Κορινθιακός κόλπος λάμπει χρυσαφί στο ηλιοβασίλεμα. Μαγικό.'}] }},
    ],
    exits: [
      { side:'right', target:'terrace', label:'Βεράντα →' },
      { side:'left', target:'port', label:'← Λιμάνι' },
    ],
    entry: [
      {s:'',t:'Ο ήλιος βάφει χρυσά τα καλντερίμια. Μυρωδιά πεύκου ανακατεμένη με θαλασσινό αλάτι.'},
      {s:'ΝΤΕΜΗΣ',t:'Φτάσαμε, παιδιά. Αυτό είναι το σπίτι μας για το Σαββατοκύριακο.'},
      {s:'ΑΙΑΣ',t:'Τέλειο! Πάμε κατευθείαν στο λιμάνι;'},
      {s:'ΚΛΕΙΩ',t:'Πρώτα ας αφήσουμε τις βαλίτσες. Θέλω να δω τη βεράντα.'},
    ],
  },
  terrace: {
    label: 'Η ΒΕΡΑΝΤΑ', bg: 'bg-terrace',
    charPos: {
      ntemis: { x: 320, y: 345 },
      ajax:   { x: 420, y: 350 },
      clio:   { x: 225, y: 350 },
    },
    objects: [
      { id:'harbor', x:140, y:120, w:280, h:100, label:'Το λιμάνι',
        verbs: { look:()=>{
          if(!state.flags.dolphins){state.flags.dolphins=1;return[
            {s:'',t:'Ο Κορινθιακός λάμπει σαν λιωμένο χρυσάφι. Ψαροκάικα κουνιούνται αργά στο λιμάνι.'},
            {s:'ΚΛΕΙΩ',t:'Μπαμπά, κοίτα! Δελφίνια!'},
            {s:'',t:'Τρία δελφίνια κόβουν βόλτες στο λιμάνι.'},
            {s:'ΑΙΑΣ',t:'Δελφίνια μέσα στο λιμάνι; Αυτό δεν είναι συνηθισμένο...'}];}
          return[{s:'',t:'Τα δελφίνια συνεχίζουν τους κύκλους τους. Σαν να φυλάνε κάτι.'}];}}},
      { id:'rooftops', x:30, y:80, w:130, h:100, label:'Σκεπές',
        verbs: { look:[{s:'',t:'Κεραμίδια, σκεπές, καμινάδες. Κάθε σπίτι κι ένας καπετάνιος κάποτε.'}] }},
      { id:'mountains', x:250, y:12, w:300, h:80, label:'Παρνασσός',
        verbs: { look:[{s:'',t:'Ο Παρνασσός στο βάθος. Οι Δελφοί κάπου εκεί πάνω.'},{s:'ΚΛΕΙΩ',t:'Οι Αμφικτίονες ξεκινούσαν από τους Δελφούς... Το Γαλαξίδι ήταν λιμάνι τους.'}] }},
      { id:'balustrade', x:90, y:240, w:370, h:40, label:'Κάγκελο',
        verbs: { look:[{s:'',t:'Πέτρινο κάγκελο με θέα ολόκληρο το Γαλαξίδι. Θα μπορούσες να κάτσεις εδώ ώρες.'}],
                 push:[{s:'ΚΛΕΙΩ',t:'Μπαμπά, μην ακουμπάς, φαίνεται παλιό!'}] }},
      { id:'flowerpot', x:10, y:220, w:65, h:60, label:'Γλάστρα',
        verbs: { look:[{s:'',t:'Γεράνια σε πήλινη γλάστρα. Τα χρώματα λάμπουν στο ηλιοβασίλεμα.'}] }},
    ],
    exits: [{ side:'left', target:'exterior', label:'← Σπίτι' }],
    entry: [
      {s:'',t:'Η θέα κόβει την ανάσα.'},
      {s:'ΚΛΕΙΩ',t:'Αυτό είναι το πιο όμορφο μέρος στον κόσμο.'},
      {s:'ΝΤΕΜΗΣ',t:'Καλωσορίσατε στο Γαλαξίδι.'},
    ],
  },
  kitchen: {
    label: 'Η ΚΟΥΖΙΝΑ', bg: 'bg-kitchen',
    charPos: {
      ntemis: { x: 350, y: 340 },
      ajax:   { x: 450, y: 345 },
      clio:   { x: 100, y: 345 },
    },
    objects: [
      { id:'figs', x:180, y:175, w:100, h:55, label:'Σύκα',
        verbs: { look:[{s:'',t:'Φρέσκα σύκα σε πήλινο μπολ. Η μυρωδιά γεμίζει το δωμάτιο.'}],
                 pick:[{s:'ΑΙΑΣ',t:'Μπαμπά, μπορώ να φάω ένα;'},{s:'ΝΤΕΜΗΣ',t:'Φυσικά.'}],
                 use:[{s:'',t:'Τρως ένα σύκο. Γλυκό σαν μέλι.'}] }},
      { id:'satchel', x:340, y:168, w:80, h:85, label:'Δερμάτινη τσάντα',
        verbs: {
          look:()=>{if(!state.flags.note)return[{s:'',t:'Μια παλιά δερμάτινη τσάντα πάνω στην καρέκλα. Δεν είναι δική σας.'},{s:'ΚΛΕΙΩ',t:'Μπαμπά, κοίτα — υπάρχει κάτι μέσα.'}];return[{s:'',t:'Η τσάντα είναι άδεια τώρα.'}];},
          open:()=>{if(!state.flags.note){state.flags.note=1;addInv({id:'note',label:'Σημείωμα'});return[{s:'',t:'Ανοίγεις την τσάντα. Μέσα βρίσκεις ένα σημείωμα.'},{s:'ΚΛΕΙΩ',t:'Διάβασέ το!'},{s:'',t:'«Σας περιμέναμε. Ελάτε στο λιμάνι απόψε. Τραπέζι για τρεις. — Γ.»'},{s:'ΑΙΑΣ',t:'Ποιος είναι ο «Γ.»;'},{s:'ΝΤΕΜΗΣ',t:'Και πώς ξέρει ότι είμαστε τρεις;'}];}return[{s:'',t:'Η τσάντα είναι πλέον άδεια.'}];},
          pick:[{s:'ΝΤΕΜΗΣ',t:'Δεν είναι δική μας. Ας κοιτάξω μέσα πρώτα.'}] }},
      { id:'window', x:455, y:50, w:95, h:115, label:'Παράθυρο',
        verbs: { look:[{s:'',t:'Απογευματινό φως μέσα από γαλάζια πατζούρια. Σκιές χορεύουν στον τοίχο.'}],
                 open:[{s:'',t:'Ανοίγεις τα πατζούρια. Μυρωδιά θυμαριού και τζιτζίκια.'}] }},
      { id:'pots', x:150, y:35, w:240, h:65, label:'Χάλκινα σκεύη',
        verbs: { look:[{s:'',t:'Χάλκινα σκεύη κρεμασμένα στον τοίχο. Κάποτε τάιζαν οικογένειες ναυτικών.'}] }},
      { id:'fireplace', x:0, y:75, w:95, h:145, label:'Τζάκι',
        verbs: { look:[{s:'',t:'Πέτρινο τζάκι. Μέσα υπάρχουν ακόμα στάχτες από τον τελευταίο χειμώνα.'}] }},
    ],
    exits: [{ side:'left', target:'exterior', label:'← Έξω' }],
    entry: [
      {s:'',t:'Η κουζίνα μυρίζει θυμάρι και παλιό ξύλο.'},
      {s:'ΚΛΕΙΩ',t:'Κοιτάξτε — κάποιος μας άφησε σύκα!'},
      {s:'ΑΙΑΣ',t:'Και κάτι πάνω στην καρέκλα... μια τσάντα;'},
    ],
  },


  // ── SCENE 2: THE PORT ──
  port: {
    label: 'ΤΟ ΛΙΜΑΝΙ', bg: 'bg-port',
    charPos: { ntemis: { x: 320, y: 340 }, ajax: { x: 400, y: 345 }, clio: { x: 240, y: 345 } },
    objects: [
      { id:'boats_port', x:120, y:80, w:200, h:100, label:'Ψαρόβαρκες',
        verbs: { look:[{s:'',t:'Χρωματιστά καΐκια δεμένα στα μπαλόνια. Η μπογιά ξεφλουδίζει — αλμύρα και χρόνια.'},{s:'ΑΙΑΣ',t:'Μπαμπά, μπορώ να πηδήξω σε κάποιο;'},{s:'ΝΤΕΜΗΣ',t:'Μπορείς να κοιτάξεις. Από εδώ.'}] }},
      { id:'bollards', x:380, y:250, w:80, h:60, label:'Δέστρες',
        verbs: { look:[{s:'',t:'Μεταλλικές δέστρες ψηλότερες από την Κλειώ. Φτιαγμένες για τρικάταρτα, όχι για βαρκούλες.'},{s:'ΚΛΕΙΩ',t:'Γιατί είναι τόσο μεγάλες;'},{s:'ΝΤΕΜΗΣ',t:'Γιατί κάποτε εδώ δένανε ιστιοφόρα πενήντα μέτρων.'}] }},
      { id:'nets', x:30, y:200, w:100, h:100, label:'Δίχτυα',
        verbs: { look:[{s:'',t:'Ένας ψαράς μπαλώνει τα δίχτυα του. Τα χέρια του κινούνται αυτόματα — πενήντα χρόνια πρακτική.'}],
                 talk:[{s:'ΝΤΕΜΗΣ',t:'Καλησπέρα! Πολύ ψάρι σήμερα;'},{s:'',t:'Ο ψαράς σηκώνει το βλέμμα. Τα μάτια του είναι γαλάζια σαν τον κόλπο.'},{s:'',t:'«Ψάρι λίγο. Ιστορίες πολλές. Κάτσε να σου πω.»'}] }},
      { id:'warehouses', x:450, y:60, w:150, h:140, label:'Αποθήκες',
        verbs: { look:[{s:'',t:'Πέτρινες αποθήκες με σιδερένιες πόρτες. Κάποτε γεμάτες σταφίδα και λάδι για εξαγωγή. Τώρα σιωπή.'}] }},
      { id:'seagulls', x:300, y:10, w:150, h:50, label:'Γλάροι',
        verbs: { look:[{s:'',t:'Γλάροι κράζουν πάνω από το λιμάνι. Αιώνιοι κάτοικοι.'},{s:'ΚΛΕΙΩ',t:'Αυτοί ξέρουν τα πάντα. Αν μιλούσαν...'}] }},
      { id:'cats', x:500, y:290, w:60, h:50, label:'Γάτες',
        verbs: { look:[{s:'',t:'Τρεις γάτες ξαπλωμένες στον ήλιο. Σε κοιτάνε με αδιαφορία.'},{s:'ΚΛΕΙΩ',t:'Πόσο τέλεια! Αυτή η πορτοκαλί μου αρέσει πολύ.'}] }},
      { id:'stathis', x:55, y:270, w:70, h:100, label:'Στάθης',
        verbs: { look:[{s:'',t:'Ο Στάθης με την κιθάρα του. Φίλος από τα παλιά.'}],
                 talk:[{s:'ΣΤΑΘΗΣ',t:'Ντέμη! Τι κάνεις εδώ; Πάρε μια καρέκλα!'},{s:'ΝΤΕΜΗΣ',t:'Στάθη! Πόσο καιρό!'},{s:'ΣΤΑΘΗΣ',t:'Ψάχνεις κάτι; Ρώτα τον Άθο στο Λιοτρίβι. Ξέρει τα πάντα για τις παλιές οικογένειες.'}] }},
      { id:'akis', x:125, y:272, w:60, h:98, label:'Άκης',
        verbs: { look:[{s:'',t:'Ο Άκης παίζει φλογέρα στο λιμάνι. Η μελωδία ταξιδεύει στο νερό.'}],
                 talk:[{s:'ΑΚΗΣ',t:'Ε, Ντέμη! Τα παιδιά μεγάλωσαν!'},{s:'ΚΛΕΙΩ',t:'Θείε Άκη, τι παίζεις;'},{s:'ΑΚΗΣ',t:'Ένα παλιό τραγούδι ναυτικό. Πήγαινε στο μουσείο — θα καταλάβεις.'}] }},
    ],
    exits: [{ side:'right', target:'exterior', label:'Σπίτι →' }, { side:'left', target:'museum', label:'← Μουσείο' }],
    entry: [
      {s:'',t:'Το λιμάνι του Γαλαξειδίου. Μισοφέγγαρο από πέτρα, κυμαρισμένο φως, μυρωδιά αλμύρας.'},
      {s:'ΑΙΑΣ',t:'Αυτό το λιμάνι φαίνεται τεράστιο για τόσο μικρό χωριό.'},
      {s:'ΝΤΕΜΗΣ',t:'Γιατί κάποτε δεν ήταν μικρό χωριό. Ήταν ναυτική δύναμη.'},
      {s:'ΚΛΕΙΩ',t:'Τριακόσια καράβια, μπαμπά. Το διάβασα.'},
    ],
  },

  // ── SCENE 3: THE NAUTICAL MUSEUM ──
  museum: {
    label: 'ΤΟ ΝΑΥΤΙΚΟ ΜΟΥΣΕΙΟ', bg: 'bg-museum',
    charPos: { ntemis: { x: 320, y: 345 }, ajax: { x: 420, y: 348 }, clio: { x: 200, y: 348 } },
    objects: [
      { id:'model_ship', x:20, y:100, w:180, h:150, label:'Μοντέλο ιστιοφόρου',
        verbs: { look:[{s:'',t:'Ένα πανέμορφο μοντέλο τρικάταρτου μέσα σε γυάλινη βιτρίνα. Κάθε λεπτομέρεια τέλεια.'},{s:'ΚΛΕΙΩ',t:'Κοιτάξτε τα πανιά! Ένα-ένα ραμμένα.'},{s:'',t:'Η πινακίδα γράφει: «Σκούνα Χρυσούλα, 1904 — το τελευταίο ιστιοφόρο του Γαλαξειδίου.»'}] }},
      { id:'steamship', x:380, y:100, w:180, h:150, label:'Ατμόπλοιο',
        verbs: { look:[{s:'',t:'Μια γωνιά αφιερωμένη στα ατμόπλοια. Ένα σιδερένιο μοντέλο, μικρότερο, λιγότερο εντυπωσιακό.'},{s:'ΝΤΕΜΗΣ',t:'Αυτό ήταν το μέλλον. Και το Γαλαξίδι δεν το είδε.'},{s:'ΑΙΑΣ',t:'Γιατί; Ήταν χαζοί;'},{s:'ΝΤΕΜΗΣ',t:'Όχι. Ήταν οι καλύτεροι στα πανιά. Γι\u0027 αυτό ακριβώς δεν άλλαξαν.'}] }},
      { id:'portraits_mus', x:200, y:20, w:180, h:100, label:'Πορτρέτα καπεταναίων',
        verbs: { look:[{s:'',t:'Πορτρέτα σε χρυσές κορνίζες. Σοβαρά πρόσωπα, κομψά μουστάκια, μάτια που έχουν δει θάλασσα.'},{s:'ΚΛΕΙΩ',t:'Αυτός μοιάζει λίγο με τον μπαμπά.'},{s:'ΑΙΑΣ',t:'Ε, λίγο μόνο.'},{s:'ΝΤΕΜΗΣ',t:'Ευχαριστώ, νομίζω.'}] }},
      { id:'instruments', x:30, y:310, w:150, h:60, label:'Ναυτικά όργανα',
        verbs: { look:[{s:'',t:'Πυξίδες, εξάντες, χάρτες. Τα εργαλεία που οδηγούσαν τα πλοία σε κάθε γωνιά της Μεσογείου.'},{s:'ΚΛΕΙΩ',t:'Χωρίς GPS; Πώς;'},{s:'ΝΤΕΜΗΣ',t:'Αστέρια, εμπειρία, και θάρρος.'}] }},
      { id:'flags', x:100, y:5, w:400, h:40, label:'Σημαίες',
        verbs: { look:[{s:'',t:'Ναυτικές σημαίες κρέμονται από το ταβάνι. Ελληνική, γαλλική, ρωσική — τα λιμάνια που γνώριζαν.'}] }},
      { id:'map_table', x:350, y:300, w:120, h:60, label:'Χάρτης',
        verbs: { look:[{s:'',t:'Ένας παλιός χάρτης του Κορινθιακού ξαπλωμένος σε τραπέζι. Σημειώσεις με μελάνι — δρόμοι ναυσιπλοΐας.'},{s:'ΚΛΕΙΩ',t:'Μπαμπά, σημείωσε αυτό. Μπορεί να μας χρειαστεί.'}] }},
      { id:'curator_npc', x:75, y:270, w:90, h:100, label:'Επιμελητής',
        verbs: { look:[{s:'',t:'Ο επιμελητής του μουσείου. Τα μάτια του λάμπουν πίσω από τα στρογγυλά γυαλιά.'}],
                 talk:[{s:'ΕΠΙΜΕΛΗΤΗΣ',t:'Καλώς ήρθατε! Βλέπω ξέρετε να εκτιμάτε την ιστορία.'},{s:'ΝΤΕΜΗΣ',t:'Τα παιδιά μου ήθελαν να δουν τα καράβια.'},{s:'ΕΠΙΜΕΛΗΤΗΣ',t:'Τριακόσια πλοία! Η Χρυσούλα ήταν το τελευταίο. Τα ατμόπλοια τα σκότωσαν όλα.'},{s:'ΚΛΕΙΩ',t:'Γιατί δεν έφτιαξαν κι αυτοί ατμόπλοια;'},{s:'ΕΠΙΜΕΛΗΤΗΣ',t:'Ωραία ερώτηση, μικρή. Ήταν τόσο καλοί στα πανιά, που δεν φαντάζονταν κόσμο χωρίς αυτά.'}] }},
    ],
    exits: [{ side:'right', target:'port', label:'Λιμάνι →' }, { side:'left', target:'liotrivi', label:'← Λιοτρίβι' }],
    entry: [
      {s:'',t:'Το Ναυτικό Μουσείο του Γαλαξειδίου. Μυρωδιά ξύλου και παλιού χαρτιού.'},
      {s:'ΚΛΕΙΩ',t:'Πόσα μοντέλα! Θέλω να τα δω ΟΛΑ.'},
      {s:'ΑΙΑΣ',t:'Εγώ θέλω να δω αν έχει κανόνια.'},
      {s:'ΝΤΕΜΗΣ',t:'Σσσ. Μουσείο, παιδιά. Ησυχία.'},
    ],
  },

  // ── SCENE 4: LIOTRIVI BAR ──
  liotrivi: {
    label: 'ΛΙΟΤΡΙΒΙ', bg: 'bg-liotrivi',
    charPos: { ntemis: { x: 320, y: 340 }, ajax: { x: 400, y: 345 }, clio: { x: 240, y: 345 } },
    objects: [
      { id:'olive_press', x:10, y:80, w:140, h:180, label:'Ελαιοτριβείο',
        verbs: { look:[{s:'',t:'Το παλιό ελαιοτριβείο — πέτρα και ξύλο. Κάποτε έβγαζε λάδι, τώρα βγάζει ιστορίες.'},{s:'ΚΛΕΙΩ',t:'Φανταστείτε πόσα χέρια το γύρισαν.'}] }},
      { id:'bar_counter', x:200, y:80, w:180, h:120, label:'Μπαρ',
        verbs: { look:[{s:'',t:'Ξύλινο μπαρ γεμάτο μπουκάλια. Τσίπουρο, ρακή, κρασιά ντόπια. Φανάρια ρίχνουν ζεστό φως.'},{s:'ΑΙΑΣ',t:'Εγώ μπορώ να πάρω λεμονάδα;'}] }},
      { id:'window_liot', x:420, y:50, w:130, h:140, label:'Παράθυρο',
        verbs: { look:[{s:'',t:'Γαλάζια πατζούρια ανοιχτά στο φεγγαρόφωτο. Το λιμάνι λάμπει ασημί.'},{s:'ΚΛΕΙΩ',t:'Μαγικό. Σαν πίνακας ζωγραφικής.'}] }},
      { id:'photos_liot', x:150, y:20, w:100, h:60, label:'Παλιές φωτογραφίες',
        verbs: { look:[{s:'',t:'Ασπρόμαυρες φωτογραφίες στον τοίχο. Ψαράδες, καπετάνιοι, γυναίκες που περίμεναν.'},{s:'ΝΤΕΜΗΣ',t:'Κάθε φωτογραφία και μια ιστορία. Κάθε πρόσωπο και μια ζωή.'}] }},
      { id:'stools', x:280, y:250, w:80, h:60, label:'Σκαμπό',
        verbs: { look:[{s:'',t:'Ξύλινα σκαμπό τριγμένα από χρόνια. Πόσες κουβέντες έχουν ακούσει.'}],
                 use:[{s:'ΝΤΕΜΗΣ',t:'Κάτσε. Ξεκουράσου. Η νύχτα είναι μακριά.'}] }},
      { id:'checkered_floor', x:100, y:300, w:400, h:80, label:'Πλακάκια',
        verbs: { look:[{s:'',t:'Πλακάκια σε σκακιέρα — κίτρινα και καφέ. Λαμπυρίζουν στο φως των φαναριών.'}] }},
      { id:'athos_npc', x:95, y:265, w:65, h:100, label:'Άθος',
        verbs: { look:[{s:'',t:'Ο Άθος. Δικηγόρος και ιδιοκτήτης του Λιοτριβιού. Τα μάτια του κρύβουν χίλια μυστικά.'}],
                 talk:[{s:'ΑΘΟΣ',t:'Λατσούδη! Περίμενα πότε θα φτάσεις.'},{s:'ΝΤΕΜΗΣ',t:'Με ξέρεις;'},{s:'ΑΘΟΣ',t:'Ξέρω τον παππού σου. Ήξερα. Και ξέρω τι ψάχνεις.'},{s:'ΑΘΟΣ',t:'Ο Βισβίκης άφησε διαθήκη. Αν θέλεις απαντήσεις, ψάξε στο σπήλαιο του Κάρκαρου.'},{s:'ΚΛΕΙΩ',t:'Σπήλαιο; Θα πάμε σε σπήλαιο;!'}] }},
    ],
    exits: [{ side:'right', target:'museum', label:'Μουσείο →' }, { side:'left', target:'church', label:'← Εκκλησία' }],
    entry: [
      {s:'',t:'Το Λιοτρίβι. Πέτρα, ξύλο, ζεστό φως. Μυρωδιά τσίπουρου και ελιάς.'},
      {s:'ΑΙΑΣ',t:'Αυτό μοιάζει σαν πειρατικό καπηλειό!'},
      {s:'ΚΛΕΙΩ',t:'Μυρίζει ωραία. Σαν τη γιαγιά.'},
      {s:'ΝΤΕΜΗΣ',t:'Ελάτε, ας δούμε ποιος είναι εδώ.'},
    ],
  },

  // ── SCENE 5: THE CAVE OF KARKAROS ──
  cave: {
    label: 'ΤΟ ΣΠΗΛΑΙΟ ΤΟΥ ΚΑΡΚΑΡΟΥ', bg: 'bg-cave',
    charPos: { ntemis: { x: 310, y: 345 }, ajax: { x: 390, y: 350 }, clio: { x: 230, y: 350 } },
    objects: [
      { id:'stone_door', x:190, y:85, w:170, h:130, label:'Πέτρινη πόρτα',
        verbs: { look:[{s:'',t:'Μια τεράστια πέτρινη πόρτα με δώδεκα κυκλικές εσοχές. Σχήμα τιμονιού.'},{s:'ΚΛΕΙΩ',t:'Δώδεκα θέσεις. Σαν ρολόι.'},{s:'ΑΙΑΣ',t:'Ή σαν τιμόνι καραβιού!'},{s:'ΝΤΕΜΗΣ',t:'Κάτι πρέπει να μπει σε κάθε εσοχή. Αλλά τι;'}],
                 open:[{s:'ΝΤΕΜΗΣ',t:'Δεν κουνιέται. Χρειαζόμαστε κάτι για τις εσοχές.'}],
                 use:[{s:'ΝΤΕΜΗΣ',t:'Δεν έχουμε αρκετά ακόμα. Πρέπει να ψάξουμε περισσότερο.'}] }},
      { id:'captain_marks', x:10, y:115, w:80, h:70, label:'Σημάδια καπεταναίων',
        verbs: { look:[{s:'',t:'Χαραγμένα σύμβολα στον βράχο. Νεκροκεφαλή, ψάρι, άγκυρα, μάτι.'},{s:'ΚΛΕΙΩ',t:'Αυτά δεν είναι πειρατικά. Είναι σημάδια καπεταναίων!'},{s:'ΝΤΕΜΗΣ',t:'Σωστά. Κάθε καπετάνιος είχε το δικό του σήμα. Αυτοί οι τοίχοι θυμούνται.'}] }},
      { id:'cave_water', x:130, y:260, w:250, h:75, label:'Νερό',
        verbs: { look:[{s:'',t:'Τυρκουάζ νερό λάμπει από το φως της εισόδου. Κρυστάλλινο.'},{s:'ΑΙΑΣ',t:'Μπορώ να κολυμπήσω;'},{s:'ΝΤΕΜΗΣ',t:'Όχι τώρα, Αία. Ποιος ξέρει πόσο βαθιά είναι.'}] }},
      { id:'stalactites', x:50, y:0, w:500, h:55, label:'Σταλακτίτες',
        verbs: { look:[{s:'',t:'Σταλακτίτες κρέμονται σαν δάχτυλα γίγαντα. Χιλιάδες χρόνια σε κάθε σταγόνα.'},{s:'ΚΛΕΙΩ',t:'Ο Κάρκαρος. Λέγανε ότι η φωνή σου γυρίζει πίσω τρεις φορές.'}] }},
      { id:'barrel_cave', x:25, y:225, w:55, h:50, label:'Βαρέλι',
        verbs: { look:[{s:'',t:'Ένα σάπιο βαρέλι. Μυρίζει θάλασσα και χρόνο.'},{s:'ΑΙΑΣ',t:'Μήπως είχε ρούμι;'},{s:'ΝΤΕΜΗΣ',t:'Πιθανόν, κάποτε.'}],
                 open:[{s:'',t:'Άδειο, εκτός από αλμύρα και σκόνη.'}] }},
      { id:'cave_entrance', x:460, y:50, w:170, h:240, label:'Είσοδος σπηλαίου',
        verbs: { look:[{s:'',t:'Χρυσό φως χύνεται μέσα από τη φυσική αψίδα. Σκόνη χορεύει στις ακτίνες.'},{s:'ΑΙΑΣ',t:'Σαν εκκλησία!'},{s:'ΚΛΕΙΩ',t:'Σαν να σε καλεί μέσα.'}] }},
    ],
    exits: [{ side:'right', target:'church', label:'Έξοδος →' }],
    entry: [
      {s:'',t:'Ο Κάρκαρος. Ο θόλος υψώνεται σαν καθεδρικός. Χρυσό φως χύνεται από την είσοδο.'},
      {s:'ΚΛΕΙΩ',t:'Μπαμπά... αυτό δεν μοιάζει σπήλαιο. Μοιάζει σαν κάποιος να το έφτιαξε.'},
      {s:'ΑΙΑΣ',t:'Η πόρτα! Κοιτάξτε αυτή την τεράστια πόρτα!'},
      {s:'ΝΤΕΜΗΣ',t:'Δώδεκα εσοχές. Σαν τιμόνι πλοίου. Κάτι μας λείπει.'},
    ],
  },

  // ── SCENE 6: CHURCH OF AGIOS NIKOLAOS ──
  church: {
    label: 'ΑΓΙΟΣ ΝΙΚΟΛΑΟΣ', bg: 'bg-church',
    charPos: { ntemis: { x: 300, y: 340 }, ajax: { x: 390, y: 345 }, clio: { x: 210, y: 345 } },
    objects: [
      { id:'fountain', x:200, y:180, w:130, h:140, label:'Σιντριβάνι',
        verbs: { look:[{s:'',t:'Πέτρινο σιντριβάνι στην πλατεία. Το νερό τρέχει αθόρυβα.'},{s:'ΚΛΕΙΩ',t:'Ρίχνω ένα νόμισμα;'},{s:'ΝΤΕΜΗΣ',t:'Γιατί όχι; Κάνε μια ευχή.'}] }},
      { id:'church_dome', x:250, y:10, w:160, h:120, label:'Εκκλησία',
        verbs: { look:[{s:'',t:'Ο Άγιος Νικόλαος — προστάτης των ναυτικών. Ο τρούλος λάμπει κόκκινος στον ήλιο.'},{s:'ΝΤΕΜΗΣ',t:'Κάθε καπετάνιος προσευχόταν εδώ πριν φύγει. Και η οικογένειά του μετά.'}] }},
      { id:'bougainvillea_ch', x:0, y:60, w:90, h:180, label:'Μπουκαμβίλιες',
        verbs: { look:[{s:'',t:'Φούξια μπουκαμβίλιες σκεπάζουν τον τοίχο. Χρώμα που αψηφά τον χρόνο.'}] }},
      { id:'cat_church', x:420, y:300, w:60, h:40, label:'Γάτα',
        verbs: { look:[{s:'',t:'Μια πορτοκαλί γάτα κοιμάται αράχτη στα πλακάκια.'},{s:'ΚΛΕΙΩ',t:'Την ξαναβρήκα! Αυτή είναι η ίδια από το λιμάνι.'}],
                 talk:[{s:'ΚΛΕΙΩ',t:'Γεια σου, μικρούλα. Με ακολουθείς;'},{s:'',t:'Η γάτα νιαουρίζει απαλά.'}] }},
      { id:'benches', x:50, y:270, w:120, h:50, label:'Παγκάκια',
        verbs: { look:[{s:'',t:'Πέτρινα παγκάκια στη σκιά. Γέροι κάθονταν εδώ κάθε απόγευμα, εδώ και δεκαετίες.'}] }},
      { id:'pots_church', x:480, y:180, w:80, h:100, label:'Γλάστρες',
        verbs: { look:[{s:'',t:'Γλάστρες με γεράνια και λουλούδια. Κάποιος φροντίζει αυτή την πλατεία με αγάπη.'}] }},
    ],
    exits: [{ side:'right', target:'liotrivi', label:'Λιοτρίβι →' }, { side:'left', target:'cave', label:'← Σπήλαιο' }],
    entry: [
      {s:'',t:'Η πλατεία του Αγίου Νικολάου. Ησυχία, λουλούδια, και ήχος νερού.'},
      {s:'ΚΛΕΙΩ',t:'Τι ωραία πλατεία! Και γάτα!'},
      {s:'ΑΙΑΣ',t:'Πάλι γάτα;'},
      {s:'ΝΤΕΜΗΣ',t:'Ο Άγιος Νικόλαος. Προστάτης των ναυτικών. Κατάλληλος για το Γαλαξίδι.'},
    ],
  },

  // ── SCENE 7: THE WINDMILL ──
  windmill: {
    label: 'Ο ΜΥΛΟΣ', bg: 'bg-windmill',
    charPos: { ntemis: { x: 350, y: 345 }, ajax: { x: 440, y: 348 }, clio: { x: 260, y: 348 } },
    objects: [
      { id:'telescope', x:60, y:140, w:80, h:120, label:'Τηλεσκόπιο',
        verbs: { look:[{s:'',t:'Ένα παλιό ορειχάλκινο τηλεσκόπιο. Κάποιος το άφησε εδώ;'},{s:'ΚΛΕΙΩ',t:'Αφήστε με να κοιτάξω!'}],
                 use:[{s:'ΚΛΕΙΩ',t:'Βλέπω... το λιμάνι! Και κάτι στο νερό...'},{s:'ΑΙΑΣ',t:'Τι; Τι βλέπεις;'},{s:'ΚΛΕΙΩ',t:'Ένα σημάδι στην προβλήτα. Σαν αστέρι.'},{s:'ΝΤΕΜΗΣ',t:'Σημείωσέ το, Κλειώ.'}] }},
      { id:'panorama', x:0, y:20, w:640, h:100, label:'Πανόραμα',
        verbs: { look:[{s:'',t:'Η θέα κόβει την ανάσα. Ολόκληρο το Γαλαξίδι, ο κόλπος, τα βουνά. Από εδώ βλέπεις τα πάντα.'},{s:'ΑΙΑΣ',t:'Μπαμπά, βλέπω μέχρι την Ιτέα!'},{s:'ΚΛΕΙΩ',t:'Και τους Δελφούς! Εκεί πάνω!'}] }},
      { id:'ruins', x:470, y:130, w:120, h:130, label:'Ερείπια',
        verbs: { look:[{s:'',t:'Πέτρινα ερείπια — ίσως ο παλιός μύλος. Αψίδα ακόμα όρθια, αψηφώντας τον χρόνο.'}] }},
      { id:'wildflowers', x:150, y:250, w:200, h:80, label:'Αγριολούλουδα',
        verbs: { look:[{s:'',t:'Παπαρούνες, μαργαρίτες, θυμάρι. Ο λόφος μυρίζει μέλι και καλοκαίρι.'},{s:'ΚΛΕΙΩ',t:'Θέλω να ζωγραφίσω αυτά.'}] }},
      { id:'stone_path_wm', x:300, y:300, w:200, h:60, label:'Μονοπάτι',
        verbs: { look:[{s:'',t:'Πέτρινο καλντερίμι ανεβαίνει τον λόφο. Λειασμένο από πόδια αιώνων.'}] }},
      { id:'giannis_npc', x:125, y:268, w:75, h:105, label:'Γιάννης Βελανής',
        verbs: { look:[{s:'',t:'Ο Γιάννης Βελανής. Ιδιοκτήτης του παλιού μύλου. Ήσυχος, βλέπει τα πάντα από ψηλά.'}],
                 talk:[{s:'ΓΙΑΝΝΗΣ',t:'...'},{s:'ΝΤΕΜΗΣ',t:'Γεια σου. Ψάχνουμε το σπήλαιο του Κάρκαρου.'},{s:'ΓΙΑΝΝΗΣ',t:'Το ξέρω. Σε βλέπω από εδώ πάνω.'},{s:'ΓΙΑΝΝΗΣ',t:'Πάρε αυτό. Θα το χρειαστείς.'},{s:'',t:'Ο Γιάννης σου δίνει ένα φανάρι.'}] }},
    ],
    exits: [{ side:'right', target:'graveyard', label:'Νεκροταφείο →' }, { side:'left', target:'church', label:'← Εκκλησία' }],
    entry: [
      {s:'',t:'Η κορυφή του λόφου. Αέρας, φως, και θέα που δεν τελειώνει.'},
      {s:'ΑΙΑΣ',t:'ΤΕΛΕΙΟ! Βλέπω τα πάντα από εδώ!'},
      {s:'ΚΛΕΙΩ',t:'Μπαμπά, κοίτα — ένα τηλεσκόπιο!'},
      {s:'ΝΤΕΜΗΣ',t:'Ένα σημείο παρατήρησης. Κάποιος παρακολουθούσε τα πλοία από εδώ.'},
    ],
  },

  // ── SCENE 8: THE BOAT (ELPIDA) ──
  boat: {
    label: 'ΤΟ ΚΑΡΑΒΙ — ΕΛΠΙΔΑ', bg: 'bg-boat',
    charPos: { ntemis: { x: 350, y: 340 }, ajax: { x: 430, y: 345 }, clio: { x: 270, y: 345 } },
    objects: [
      { id:'nameplate', x:50, y:310, w:120, h:40, label:'ΕΛΠΙΔΑ',
        verbs: { look:[{s:'',t:'«ΕΛΠΙΔΑ» — χρυσά γράμματα σε ξεφλουδισμένο μπλε ξύλο.'},{s:'ΝΤΕΜΗΣ',t:'Ελπίδα. Πάντα υπάρχει ελπίδα.'}] }},
      { id:'chapel', x:30, y:60, w:150, h:150, label:'Παρεκκλήσι',
        verbs: { look:[{s:'',t:'Ένα μικρό λευκό παρεκκλήσι πάνω στον βράχο. Ελληνική σημαία κυματίζει.'},{s:'ΚΛΕΙΩ',t:'Ποιος πάει εκεί πάνω για λειτουργία;'},{s:'ΝΤΕΜΗΣ',t:'Οι ψαράδες. Πριν και μετά το ταξίδι.'}] }},
      { id:'sunset_sea', x:200, y:20, w:400, h:120, label:'Ηλιοβασίλεμα',
        verbs: { look:[{s:'',t:'Ο ήλιος βυθίζεται στον Κορινθιακό. Χρυσό, πορτοκαλί, ροζ. Τα βουνά γίνονται σκιές.'},{s:'',t:'Κανείς δεν μιλάει. Δεν χρειάζεται.'}] }},
      { id:'rope', x:350, y:250, w:80, h:60, label:'Σχοινιά',
        verbs: { look:[{s:'',t:'Σχοινιά τυλιγμένα στο κατάστρωμα. Μυρίζουν θάλασσα και πεύκο.'}],
                 use:[{s:'ΑΙΑΣ',t:'Ξέρω κόμπους! Ο παππούς μου έμαθε.'},{s:'ΝΤΕΜΗΣ',t:'Δείξε μας.'}] }},
      { id:'lifebuoy', x:460, y:290, w:60, h:60, label:'Σωσίβιο',
        verbs: { look:[{s:'',t:'Πορτοκαλί σωσίβιο. Λευκά γράμματα: ΕΛΠΙΔΑ — ΓΑΛΑΞΙΔΙ.'}] }},
      { id:'galaxidi_view', x:400, y:80, w:200, h:100, label:'Γαλαξίδι στο βάθος',
        verbs: { look:[{s:'',t:'Το Γαλαξίδι λάμπει στον ήλιο του δειλινού. Σπίτια, εκκλησίες, το λιμάνι — σαν μακέτα.'},{s:'ΚΛΕΙΩ',t:'Από εδώ φαίνεται σαν παραμύθι.'}] }},
    ],
    exits: [{ side:'left', target:'port', label:'← Λιμάνι' }],
    entry: [
      {s:'',t:'Η Ελπίδα πλέει αργά στον Κορινθιακό. Ο κόσμος σταμάτησε.'},
      {s:'ΚΛΕΙΩ',t:'Αυτό... αυτό είναι τέλειο.'},
      {s:'ΑΙΑΣ',t:'Μπαμπά, μπορούμε να μείνουμε για πάντα εδώ;'},
      {s:'ΝΤΕΜΗΣ',t:'Για λίγο ακόμα. Κοιτάξτε τον ήλιο.'},
    ],
  },

  // ── SCENE 9: THE GRAVEYARD ──
  graveyard: {
    label: 'ΤΟ ΝΕΚΡΟΤΑΦΕΙΟ', bg: 'bg-graveyard',
    charPos: { ntemis: { x: 300, y: 345 }, ajax: { x: 390, y: 348 }, clio: { x: 210, y: 348 } },
    objects: [
      { id:'headstones', x:100, y:100, w:200, h:150, label:'Ταφόπλακες',
        verbs: { look:[{s:'',t:'Μαρμάρινοι σταυροί και πλάκες. Ονόματα καπεταναίων: Τσώνης, Ρήγας, Μαμάς, Χρυσοβαλάντου.'},{s:'ΚΛΕΙΩ',t:'Κάθε πέτρα και ένα ταξίδι.'},{s:'ΝΤΕΜΗΣ',t:'Κάθε πέτρα και μια οικογένεια που περίμενε.'}] }},
      { id:'cypress', x:0, y:20, w:60, h:300, label:'Κυπαρίσσια',
        verbs: { look:[{s:'',t:'Κυπαρίσσια ψηλά σαν κατάρτια. Φρουροί αιώνιοι.'}] }},
      { id:'poppies_gr', x:300, y:200, w:150, h:100, label:'Παπαρούνες',
        verbs: { look:[{s:'',t:'Κόκκινες παπαρούνες ανάμεσα στους τάφους. Η ζωή εκεί που αναπαύεται ο θάνατος.'},{s:'ΚΛΕΙΩ',t:'Μπαμπά, δεν είναι τρομακτικό. Είναι... ωραίο.'}] }},
      { id:'sea_view_gr', x:350, y:30, w:250, h:100, label:'Θέα στη θάλασσα',
        verbs: { look:[{s:'',t:'Η θάλασσα λάμπει χρυσή από το ηλιοβασίλεμα. Ακόμα και μετά θάνατον, οι καπετάνιοι βλέπουν τη θάλασσα.'},{s:'ΑΙΑΣ',t:'Τους έβαλαν εδώ επίτηδες. Να βλέπουν.'}] }},
      { id:'sailboat_dist', x:500, y:80, w:60, h:40, label:'Ιστιοφόρο στο βάθος',
        verbs: { look:[{s:'',t:'Ένα ιστιοφόρο στον ορίζοντα. Σαν φάντασμα του παρελθόντος.'}] }},
      { id:'path_stones_gr', x:150, y:280, w:200, h:60, label:'Πέτρινο μονοπάτι',
        verbs: { look:[{s:'',t:'Πλακόστρωτο μονοπάτι ανάμεσα στους τάφους. Λειασμένο από χιλιάδες επισκέψεις.'}] }},
      { id:'ghost_npc', x:455, y:290, w:55, h:110, label:'Σκιά',
        verbs: { look:[{s:'',t:'Μια αχνή, ψηλή σιλουέτα κοντά στα κυπαρίσσια. Τρεμοπαίζει σαν φως σε νερό.'},{s:'ΚΛΕΙΩ',t:'Μπαμπά... βλέπω κάτι εκεί.'},{s:'ΑΙΑΣ',t:'Φάντασμα; Σοβαρά τώρα;'}],
                 talk:[{s:'ΦΑΝΤΑΣΜΑ',t:'...'},{s:'',t:'Το φάντασμα δεν μιλάει. Δείχνει προς την εκκλησία.'},{s:'ΚΛΕΙΩ',t:'Θέλει να πάμε στον Άγιο Νικόλαο!'},{s:'ΝΤΕΜΗΣ',t:'Μόλις μας έδωσε οδηγίες ένα φάντασμα.'}] }},
    ],
    exits: [{ side:'left', target:'windmill', label:'← Μύλος' }],
    entry: [
      {s:'',t:'Το παλιό νεκροταφείο. Θέα στη θάλασσα, μυρωδιά θυμαριού, ησυχία.'},
      {s:'ΚΛΕΙΩ',t:'Μπαμπά... δεν μου αρέσουν τα νεκροταφεία.'},
      {s:'ΝΤΕΜΗΣ',t:'Αυτό δεν είναι τρομακτικό. Είναι γεμάτο ιστορίες.'},
      {s:'ΑΙΑΣ',t:'Κοίτα — βλέπεις τη θάλασσα από κάθε τάφο. Αυτό ήθελαν.'},
    ],
  },

};

// ════════════════════════════════════════════════════════════
// INTRO PAGES
// ════════════════════════════════════════════════════════════
const introPages = [
  'Γαλαξίδι.\nΤέλη Σεπτεμβρίου, 2026.',
  'Ένα μικρό λιμάνι\nστον Κορινθιακό κόλπο.\n\nΕκεί που κάποτε ξεκινούσαν\nτα πιο τολμηρά καράβια\nτης Ελλάδας.',
  'Ο Ντέμης έφτασε\nμε τα δυο του παιδιά\nγια ένα ήσυχο\nΣαββατοκύριακο.\n\nΤουλάχιστον,\nαυτό νόμιζε.',
];

// ════════════════════════════════════════════════════════════
// EASING
// ════════════════════════════════════════════════════════════
function easeInOutCubic(t) { return t < .5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3)/2; }

// ════════════════════════════════════════════════════════════
// COORDINATE CONVERSION
// ════════════════════════════════════════════════════════════
function screenToGame(sx, sy) {
  const rect = CVS.getBoundingClientRect();
  const scaleX = GW / rect.width;
  const scaleY = GH / rect.height;
  return { x: (sx - rect.left) * scaleX, y: (sy - rect.top) * scaleY };
}

// ════════════════════════════════════════════════════════════
// DUST PARTICLES (canvas-drawn)
// ════════════════════════════════════════════════════════════
const particles = [];
function initParticles() {
  particles.length = 0;
  const isExterior = (state.scene === 'exterior' || state.scene === 'terrace');
  const count = isExterior ? 30 : 20;
  for (let i = 0; i < count; i++) {
    if (isExterior) {
      // Golden motes drifting in the light shaft (upper-right to lower-left)
      const startX = GW * 0.4 + Math.random() * GW * 0.6;
      particles.push({
        x: startX,
        y: Math.random() * GH * 0.7,
        vx: -0.05 - Math.random() * 0.15,
        vy: 0.03 + Math.random() * 0.08,
        size: 0.6 + Math.random() * 1.5,
        alpha: 0,
        maxAlpha: 0.15 + Math.random() * 0.25,
        life: Math.random() * 700,
        maxLife: 600 + Math.random() * 500,
        glow: Math.random() < 0.3,
      });
    } else {
      particles.push({
        x: Math.random() * GW,
        y: 60 + Math.random() * 240,
        vx: 0.1 + Math.random() * 0.25,
        vy: -0.05 - Math.random() * 0.12,
        size: 0.8 + Math.random() * 1.8,
        alpha: 0,
        maxAlpha: 0.12 + Math.random() * 0.18,
        life: Math.random() * 700,
        maxLife: 500 + Math.random() * 400,
      });
    }
  }
}

function updateParticles() {
  for (const p of particles) {
    p.x += p.vx;
    p.y += p.vy;
    p.life++;
    const prog = p.life / p.maxLife;
    if (prog < 0.3) p.alpha = p.maxAlpha * (prog / 0.3) * (prog / 0.3); // quadratic fade-in
    else if (prog > 0.7) { const f = (prog - 0.7) / 0.3; p.alpha = p.maxAlpha * (1 - f * f); } // quadratic fade-out
    else p.alpha = p.maxAlpha;
    if (p.life >= p.maxLife || p.x > GW + 10 || p.x < -10 || p.y < -10 || p.y > GH + 10) {
      const isExterior = (state.scene === 'exterior' || state.scene === 'terrace');
      if (isExterior) {
        p.x = GW * 0.4 + Math.random() * GW * 0.6;
        p.y = -5 + Math.random() * 30;
      } else {
        p.x = -5 + Math.random() * 20;
        p.y = 80 + Math.random() * 200;
      }
      p.life = 0;
      p.alpha = 0;
    }
  }
}

function drawParticles() {
  for (const p of particles) {
    if (p.alpha <= 0) continue;
    ctx.save();
    ctx.globalAlpha = p.alpha;
    if (p.glow) {
      // Glowing golden mote
      ctx.shadowColor = 'rgba(255,200,60,0.6)';
      ctx.shadowBlur = 4;
      ctx.fillStyle = '#FFD860';
    } else {
      ctx.fillStyle = '#D4A03C';
    }
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

// ════════════════════════════════════════════════════════════
// SCENE AMBIENCE — per-scene visual & audio layers
// ════════════════════════════════════════════════════════════


// ── Bobbing Boats (extracted from background, redrawn with bob) ──
let boatCutout = null;
let boatWaterPatch = null;
const boatRegion = { x: 375, y: 135, w: 190, h: 80 };
let boatBobPhase = 0;

function initBoatBob() {
  boatBobPhase = Math.random() * Math.PI * 2;
  boatCutout = null;
  boatWaterPatch = null;
  const bgImg = images['bg-exterior'];
  if (!bgImg || !bgImg.complete) return;
  // Source coords in the 1024x1024 image
  const sx = boatRegion.x / GW * bgImg.naturalWidth;
  const sy = boatRegion.y / GH * bgImg.naturalHeight;
  const sw = boatRegion.w / GW * bgImg.naturalWidth;
  const sh = boatRegion.h / GH * bgImg.naturalHeight;
  // Extract boats
  const cut = document.createElement('canvas');
  cut.width = boatRegion.w;
  cut.height = boatRegion.h;
  const cctx = cut.getContext('2d');
  cctx.imageSmoothingEnabled = true;
  cctx.imageSmoothingQuality = 'high';
  cctx.drawImage(bgImg, sx, sy, sw, sh, 0, 0, boatRegion.w, boatRegion.h);
  boatCutout = cut;
  // Water patch from row just below boats
  const patch = document.createElement('canvas');
  patch.width = boatRegion.w;
  patch.height = boatRegion.h + 8;
  const pctx = patch.getContext('2d');
  pctx.imageSmoothingEnabled = true;
  pctx.imageSmoothingQuality = 'high';
  const waterSrcY = sy + sh;
  for (let row = 0; row < patch.height; row++) {
    pctx.drawImage(bgImg, sx, waterSrcY, sw, 1, 0, row, boatRegion.w, 1);
  }
  boatWaterPatch = patch;
}

function updateBoatBob(dt) {
  boatBobPhase += dt * 0.8;
}

function drawBoatBob() {
  if (!boatCutout || !boatWaterPatch) return;
  const bob = Math.sin(boatBobPhase) * 3;
  // Cover original boats with water
  ctx.drawImage(boatWaterPatch, boatRegion.x, boatRegion.y);
  // Redraw boats shifted by bob
  ctx.drawImage(boatCutout, boatRegion.x, boatRegion.y + bob);
}

// ── Sea Shimmer ──
function drawSeaShimmer(tick) {
  const t = tick * 0.02;
  ctx.save();
  // Water area on exterior scene (right side, harbor)
  for (let ry = 75; ry < 140; ry += 2) {
    const d = (ry - 75) / 65;
    // Golden reflections
    ctx.fillStyle = `rgba(230,180,60,${0.04 + d * 0.03})`;
    for (let rx = 360; rx < 580; rx += 4) {
      const shimmer = Math.sin(rx * 0.05 + ry * 0.08 + t * 1.8) * 0.5 + 0.5;
      if (shimmer > 0.55) {
        ctx.fillRect(rx, ry, 2 + Math.floor(shimmer * 3), 1);
      }
    }
    // Dark wave troughs
    ctx.fillStyle = `rgba(0,20,40,${0.03 + d * 0.02})`;
    for (let rx = 360; rx < 580; rx += 6) {
      if (Math.sin(rx * 0.07 + ry * 0.12 - t * 1.1) > 0.4) {
        ctx.fillRect(rx, ry + 1, 3, 1);
      }
    }
  }
  ctx.restore();
}

// ── Bougainvillea Petals ──
const petals = [];
function initPetals() {
  petals.length = 0;
  for (let i = 0; i < 12; i++) {
    petals.push(newPetal());
  }
}
function newPetal() {
  return {
    x: 175 + Math.random() * 150,
    y: 20 + Math.random() * 40,
    vx: 0.1 + Math.random() * 0.3,
    vy: 0.2 + Math.random() * 0.4,
    rot: Math.random() * Math.PI * 2,
    rotV: (Math.random() - 0.5) * 0.05,
    size: 1.5 + Math.random() * 1.5,
    wobble: Math.random() * Math.PI * 2,
    wobbleSpeed: 0.02 + Math.random() * 0.02,
    alpha: 0.5 + Math.random() * 0.4,
    color: Math.random() < 0.7 ? '#E0489A' : (Math.random() < 0.5 ? '#D03878' : '#C83068'),
  };
}
function updatePetals() {
  for (const p of petals) {
    p.wobble += p.wobbleSpeed;
    p.x += p.vx + Math.sin(p.wobble) * 0.3;
    p.y += p.vy;
    p.rot += p.rotV;
    if (p.y > 380 || p.x > GW + 10) {
      Object.assign(p, newPetal());
    }
  }
}
function drawPetals() {
  for (const p of petals) {
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(p.rot);
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.ellipse(0, 0, p.size, p.size * 0.5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}


// ── Orange Cat ──
const cat = { x: 95, y: 243, phase: 0, blinkTimer: 0, blinking: false, tailPhase: 0 };
function updateCat(dt) {
  cat.phase += dt;
  cat.tailPhase += dt * 2.5;
  cat.blinkTimer += dt;
  if (!cat.blinking && cat.blinkTimer > 3 + Math.random() * 4) {
    cat.blinking = true;
    cat.blinkTimer = 0;
  }
  if (cat.blinking && cat.blinkTimer > 0.15) {
    cat.blinking = false;
    cat.blinkTimer = 0;
  }
}
function drawCat() {
  const cx = cat.x, cy = cat.y;
  ctx.save();
  ctx.imageSmoothingEnabled = false;
  // Body (sitting loaf shape)
  ctx.fillStyle = '#D08030';
  ctx.fillRect(cx, cy, 10, 6);       // body
  ctx.fillRect(cx + 1, cy - 1, 8, 1); // back curve
  // Head
  ctx.fillRect(cx + 8, cy - 4, 6, 5); // head
  ctx.fillStyle = '#E09040';
  ctx.fillRect(cx + 9, cy - 3, 4, 3); // face highlight
  // Ears
  ctx.fillStyle = '#D08030';
  ctx.fillRect(cx + 8, cy - 6, 2, 2);  // left ear
  ctx.fillRect(cx + 12, cy - 6, 2, 2); // right ear
  ctx.fillStyle = '#E8A060';
  ctx.fillRect(cx + 9, cy - 5, 1, 1);  // inner ear
  ctx.fillRect(cx + 12, cy - 5, 1, 1);
  // Eyes
  if (!cat.blinking) {
    ctx.fillStyle = '#40A040';
    ctx.fillRect(cx + 9, cy - 2, 1, 1);
    ctx.fillRect(cx + 12, cy - 2, 1, 1);
  } else {
    ctx.fillStyle = '#D08030';
    ctx.fillRect(cx + 9, cy - 2, 1, 1);
    ctx.fillRect(cx + 12, cy - 2, 1, 1);
  }
  // Nose
  ctx.fillStyle = '#E07890';
  ctx.fillRect(cx + 11, cy - 1, 1, 1);
  // Stripes
  ctx.fillStyle = '#B06820';
  ctx.fillRect(cx + 2, cy, 1, 5);
  ctx.fillRect(cx + 5, cy, 1, 5);
  ctx.fillRect(cx + 10, cy - 4, 1, 2);
  // Tail (swishing)
  const tailSwing = Math.sin(cat.tailPhase) * 4;
  ctx.fillStyle = '#D08030';
  ctx.fillRect(cx - 1, cy + 3, 1, 1);
  ctx.fillRect(cx - 2, cy + 2 + tailSwing * 0.2, 1, 1);
  ctx.fillRect(cx - 3, cy + 1 + tailSwing * 0.4, 1, 1);
  ctx.fillRect(cx - 4, cy + tailSwing * 0.5, 1, 1);
  // Tip darker
  ctx.fillStyle = '#B06820';
  ctx.fillRect(cx - 4, cy + tailSwing * 0.5, 1, 1);
  // Paws
  ctx.fillStyle = '#E0A060';
  ctx.fillRect(cx + 1, cy + 5, 2, 1);
  ctx.fillRect(cx + 7, cy + 5, 2, 1);
  ctx.restore();
}

// ── Golden Hour Light Shaft ──
function drawLightShaft(tick) {
  ctx.save();
  const t = tick * 0.005;
  // Diagonal warm light from upper-right
  const lg = ctx.createLinearGradient(GW, 0, GW * 0.3, GH * 0.6);
  lg.addColorStop(0, `rgba(255,200,80,${0.04 + Math.sin(t) * 0.01})`);
  lg.addColorStop(0.4, `rgba(255,180,60,${0.02 + Math.sin(t + 1) * 0.005})`);
  lg.addColorStop(1, 'rgba(255,180,60,0)');
  ctx.fillStyle = lg;
  ctx.fillRect(0, 0, GW, GH);
  // Light beam rays (subtle streaks)
  ctx.globalAlpha = 0.015 + Math.sin(t * 0.7) * 0.005;
  ctx.fillStyle = '#FFD060';
  ctx.beginPath();
  ctx.moveTo(GW, 0);
  ctx.lineTo(GW * 0.55, GH * 0.7);
  ctx.lineTo(GW * 0.65, GH * 0.7);
  ctx.lineTo(GW, 20);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(GW - 40, 0);
  ctx.lineTo(GW * 0.4, GH * 0.5);
  ctx.lineTo(GW * 0.48, GH * 0.5);
  ctx.lineTo(GW - 10, 0);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

// ── Heat Haze ──
function drawHeatHaze(tick) {
  ctx.save();
  const t = tick * 0.03;
  ctx.globalAlpha = 0.02;
  for (let x = 50; x < GW - 50; x += 8) {
    const shift = Math.sin(x * 0.05 + t) * 1.5;
    ctx.fillStyle = '#FFD090';
    ctx.fillRect(x, 360 + shift, 4, 1);
  }
  ctx.restore();
}

// ── Ambient Sound Manager (Web Audio API — procedural, no files) ──
let audioCtx = null;
const ambientSounds = {
  wavesNode: null, cicadasNode: null, windNode: null, dripsInterval: null,
  bellPlayed: false, gullTimer: 0, gullInterval: 10,
  masterGain: null, active: false, currentScene: null,
};

// Per-scene ambient config: which layers play and at what volume
const sceneAmbientConfig = {
  exterior:  { waves: 0.12, wind: 0.04, gulls: true,  gullFreq: [8,7] },
  terrace:   { waves: 0.10, wind: 0.03, gulls: true,  gullFreq: [10,8] },
  kitchen:   { waves: 0.03, wind: 0.01 },
  port:      { waves: 0.18, wind: 0.06, gulls: true,  gullFreq: [5,4] },
  waterfront:{ waves: 0.14, wind: 0.04, gulls: true,  gullFreq: [8,6] },
  museum:    { waves: 0.02, wind: 0.01 },
  liotrivi:  { waves: 0.04, wind: 0.02 },
  cave:      { drips: true,  wind: 0.02 },
  windmill:  { waves: 0.06, wind: 0.12, gulls: true,  gullFreq: [12,10] },
  graveyard: { waves: 0.04, wind: 0.08 },
  church:    { waves: 0.02, wind: 0.01 },
  boat:      { waves: 0.22, wind: 0.10, gulls: true,  gullFreq: [6,5] },
  treasure:  { waves: 0.08, wind: 0.06 },
};

function getAudioCtx() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    ambientSounds.masterGain = audioCtx.createGain();
    ambientSounds.masterGain.gain.value = 1;
    ambientSounds.masterGain.connect(audioCtx.destination);
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}

function createWavesLoop() {
  const ctx = getAudioCtx();
  const bufferSize = ctx.sampleRate * 4;
  const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
  const data = buffer.getChannelData(0);
  let last = 0;
  for (let i = 0; i < bufferSize; i++) {
    const white = Math.random() * 2 - 1;
    last = (last + (0.02 * white)) / 1.02;
    const waveMod = 0.5 + 0.5 * Math.sin(i / ctx.sampleRate * Math.PI * 0.3);
    data[i] = last * 3.5 * waveMod;
  }
  const src = ctx.createBufferSource();
  src.buffer = buffer;
  src.loop = true;
  const lp = ctx.createBiquadFilter();
  lp.type = 'lowpass';
  lp.frequency.value = 400;
  const gain = ctx.createGain();
  gain.gain.value = 0.12;
  src.connect(lp);
  lp.connect(gain);
  gain.connect(ambientSounds.masterGain);
  src.start();
  return { src, gain };
}

function createCicadasLoop() {
  const ctx = getAudioCtx();
  const merger = ctx.createGain();
  merger.gain.value = 0;
  const oscs = [];
  const freqs = [4200, 4800, 5100, 5600, 6200];
  for (const f of freqs) {
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = f + (Math.random() - 0.5) * 200;
    const am = ctx.createGain();
    const lfo = ctx.createOscillator();
    lfo.frequency.value = 8 + Math.random() * 12;
    const lfoGain = ctx.createGain();
    lfoGain.gain.value = 0.5;
    lfo.connect(lfoGain);
    lfoGain.connect(am.gain);
    am.gain.value = 0.5;
    osc.connect(am);
    am.connect(merger);
    osc.start();
    lfo.start();
    oscs.push({ osc, lfo });
  }
  const bp = ctx.createBiquadFilter();
  bp.type = 'bandpass';
  bp.frequency.value = 5000;
  bp.Q.value = 2;
  const gain = ctx.createGain();
  gain.gain.value = 0.04;
  merger.connect(bp);
  bp.connect(gain);
  gain.connect(ambientSounds.masterGain);
  return { oscs, merger, gain };
}

function playSeagullCry() {
  const ctx = getAudioCtx();
  const now = ctx.currentTime;
  const osc = ctx.createOscillator();
  osc.type = 'sine';
  const baseF = 1800 + Math.random() * 600;
  osc.frequency.setValueAtTime(baseF, now);
  osc.frequency.linearRampToValueAtTime(baseF * 0.6, now + 0.15);
  osc.frequency.linearRampToValueAtTime(baseF * 1.1, now + 0.35);
  osc.frequency.linearRampToValueAtTime(baseF * 0.5, now + 0.6);
  const osc2 = ctx.createOscillator();
  osc2.type = 'sine';
  osc2.frequency.setValueAtTime(baseF * 1.5, now);
  osc2.frequency.linearRampToValueAtTime(baseF * 0.9, now + 0.15);
  osc2.frequency.linearRampToValueAtTime(baseF * 1.6, now + 0.35);
  osc2.frequency.linearRampToValueAtTime(baseF * 0.75, now + 0.6);
  const vib = ctx.createOscillator();
  vib.frequency.value = 20 + Math.random() * 15;
  const vibGain = ctx.createGain();
  vibGain.gain.value = 40;
  vib.connect(vibGain);
  vibGain.connect(osc.frequency);
  vibGain.connect(osc2.frequency);
  const env = ctx.createGain();
  env.gain.setValueAtTime(0, now);
  env.gain.linearRampToValueAtTime(0.06 + Math.random() * 0.04, now + 0.05);
  env.gain.setValueAtTime(0.06, now + 0.35);
  env.gain.linearRampToValueAtTime(0, now + 0.7);
  const noiseLen = ctx.sampleRate;
  const noiseBuf = ctx.createBuffer(1, noiseLen, ctx.sampleRate);
  const nd = noiseBuf.getChannelData(0);
  for (let i = 0; i < noiseLen; i++) nd[i] = Math.random() * 2 - 1;
  const noiseSrc = ctx.createBufferSource();
  noiseSrc.buffer = noiseBuf;
  const noiseBP = ctx.createBiquadFilter();
  noiseBP.type = 'bandpass';
  noiseBP.frequency.value = 2000;
  noiseBP.Q.value = 3;
  const noiseGain = ctx.createGain();
  noiseGain.gain.setValueAtTime(0, now);
  noiseGain.gain.linearRampToValueAtTime(0.015, now + 0.05);
  noiseGain.gain.linearRampToValueAtTime(0, now + 0.7);
  noiseSrc.connect(noiseBP);
  noiseBP.connect(noiseGain);
  noiseGain.connect(ambientSounds.masterGain);
  osc.connect(env);
  osc2.connect(env);
  env.connect(ambientSounds.masterGain);
  osc.start(now);
  osc2.start(now);
  vib.start(now);
  noiseSrc.start(now);
  osc.stop(now + 0.75);
  osc2.stop(now + 0.75);
  vib.stop(now + 0.75);
  noiseSrc.stop(now + 0.75);
}

function playChurchBell() {
  const ctx = getAudioCtx();
  const now = ctx.currentTime;
  const partials = [1, 2.0, 2.98, 4.07, 5.2, 6.5];
  const baseF = 280;
  const mix = ctx.createGain();
  mix.gain.value = 0.12;
  for (let i = 0; i < partials.length; i++) {
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = baseF * partials[i];
    const g = ctx.createGain();
    const amp = 1 / (i + 1);
    const decay = 3 - i * 0.3;
    g.gain.setValueAtTime(amp, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + Math.max(0.5, decay));
    osc.connect(g);
    g.connect(mix);
    osc.start(now);
    osc.stop(now + 4);
  }
  mix.connect(ambientSounds.masterGain);
}

function createWindLoop(volume) {
  const ctx = getAudioCtx();
  const bufferSize = ctx.sampleRate * 6;
  const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
  const data = buffer.getChannelData(0);
  let last = 0;
  for (let i = 0; i < bufferSize; i++) {
    const white = Math.random() * 2 - 1;
    last = (last + (0.01 * white)) / 1.01;
    // Slow modulation for gusting effect
    const gust = 0.4 + 0.6 * Math.sin(i / ctx.sampleRate * Math.PI * 0.15)
                          * Math.sin(i / ctx.sampleRate * Math.PI * 0.07 + 1.3);
    data[i] = last * 4 * Math.max(0, gust);
  }
  const src = ctx.createBufferSource();
  src.buffer = buffer;
  src.loop = true;
  const hp = ctx.createBiquadFilter();
  hp.type = 'highpass';
  hp.frequency.value = 200;
  const lp = ctx.createBiquadFilter();
  lp.type = 'lowpass';
  lp.frequency.value = 1200;
  const gain = ctx.createGain();
  gain.gain.value = volume;
  src.connect(hp);
  hp.connect(lp);
  lp.connect(gain);
  gain.connect(ambientSounds.masterGain);
  src.start();
  return { src, gain };
}

function playCaveDrip() {
  const ctx = getAudioCtx();
  const now = ctx.currentTime;
  const freq = 1200 + Math.random() * 2000;
  const osc = ctx.createOscillator();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(freq, now);
  osc.frequency.exponentialRampToValueAtTime(freq * 0.3, now + 0.15);
  const env = ctx.createGain();
  env.gain.setValueAtTime(0.08 + Math.random() * 0.04, now);
  env.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
  // Simple delay for echo
  const delay = ctx.createDelay();
  delay.delayTime.value = 0.12 + Math.random() * 0.08;
  const delayGain = ctx.createGain();
  delayGain.gain.value = 0.3;
  osc.connect(env);
  env.connect(ambientSounds.masterGain);
  env.connect(delay);
  delay.connect(delayGain);
  delayGain.connect(ambientSounds.masterGain);
  osc.start(now);
  osc.stop(now + 0.4);
}

function initAmbientSound() {
  ambientSounds.gullTimer = 0;
  ambientSounds.gullInterval = 8 + Math.random() * 7;
}

function startSceneAmbience(sceneId) {
  stopSceneAmbience();
  const cfg = sceneAmbientConfig[sceneId];
  if (!cfg) return;
  ambientSounds.currentScene = sceneId;
  try {
    // Waves layer
    if (cfg.waves) {
      ambientSounds.wavesNode = createWavesLoop();
      ambientSounds.wavesNode.gain.gain.value = cfg.waves;
    }
    // Wind layer
    if (cfg.wind) {
      ambientSounds.windNode = createWindLoop(cfg.wind);
    }
    // Seagull timer
    if (cfg.gulls) {
      ambientSounds.gullTimer = 0;
      ambientSounds.gullInterval = cfg.gullFreq[0] + Math.random() * cfg.gullFreq[1];
    }
    // Cave drips — periodic random drips
    if (cfg.drips) {
      const dripFn = () => {
        playCaveDrip();
        ambientSounds.dripsInterval = setTimeout(dripFn, 1500 + Math.random() * 3000);
      };
      ambientSounds.dripsInterval = setTimeout(dripFn, 500 + Math.random() * 1000);
    }
    // One-time church bell on first exterior visit
    if (!ambientSounds.bellPlayed && sceneId === 'exterior') {
      ambientSounds.bellPlayed = true;
      setTimeout(() => playChurchBell(), 2500);
    }
  } catch (e) { /* Web Audio not available */ }
  // Visual ambience
  if (sceneId === 'exterior' || sceneId === 'terrace') {
    initBoatBob();
    initPetals();
  }
  ambientSounds.active = true;
}

function stopSceneAmbience() {
  if (ambientSounds.wavesNode) {
    try { ambientSounds.wavesNode.src.stop(); } catch (e) {}
    ambientSounds.wavesNode = null;
  }
  if (ambientSounds.windNode) {
    try { ambientSounds.windNode.src.stop(); } catch (e) {}
    ambientSounds.windNode = null;
  }
  if (ambientSounds.cicadasNode) {
    try {
      for (const o of ambientSounds.cicadasNode.oscs) { o.osc.stop(); o.lfo.stop(); }
    } catch (e) {}
    ambientSounds.cicadasNode = null;
  }
  if (ambientSounds.dripsInterval) {
    clearTimeout(ambientSounds.dripsInterval);
    ambientSounds.dripsInterval = null;
  }
  boatCutout = null;
  boatWaterPatch = null;
  petals.length = 0;
  ambientSounds.active = false;
  ambientSounds.currentScene = null;
}

function updateAmbientSound(dt) {
  if (!ambientSounds.active) return;
  const cfg = sceneAmbientConfig[state.scene];
  if (!cfg || !cfg.gulls) return;
  ambientSounds.gullTimer += dt;
  if (ambientSounds.gullTimer >= ambientSounds.gullInterval) {
    ambientSounds.gullTimer = 0;
    ambientSounds.gullInterval = cfg.gullFreq[0] + Math.random() * cfg.gullFreq[1];
    playSeagullCry();
  }
}

// ── Master draw/update for scene ambience ──
function updateSceneAmbience(dt) {
  updateAmbientSound(dt);
  if (state.scene === 'exterior') {
    updateBoatBob(dt);
    updatePetals();
    updateCat(dt);
  }
}

function drawSceneAmbience(tick) {
  if (state.scene === 'exterior') {
    drawBoatBob();
    drawSeaShimmer(tick);
    drawLightShaft(tick);
    drawPetals();
    drawCat();
    drawHeatHaze(tick);
  } else if (state.scene === 'terrace') {
    drawSeaShimmer(tick);
    drawLightShaft(tick);
  } else if (state.scene === 'cave') {
    drawCaveAmbience(tick);
  }
}

// Cave ambience: god-rays, torch flicker, water shimmer, dripping water
function drawCaveAmbience(tick) {
  ctx.save();

  // ── GOD-RAYS from entrance (right side) ──
  // Animated diagonal light beams streaming through the arch
  const rayBase = 520; // x center of entrance arch
  for (let r = 0; r < 5; r++) {
    const phase = tick * 0.008 + r * 1.3;
    const alpha = (Math.sin(phase) * 0.5 + 0.5) * 0.06 + 0.02;
    const spread = r * 28 - 56;
    ctx.fillStyle = `rgba(255,210,120,${alpha})`;
    // Angled rays: narrow at top, spread toward floor
    ctx.beginPath();
    ctx.moveTo(rayBase + spread, 60 + r * 15);
    ctx.lineTo(rayBase + spread - 30, 60 + r * 15);
    ctx.lineTo(rayBase + spread - 120, 320);
    ctx.lineTo(rayBase + spread - 80, 320);
    ctx.closePath();
    ctx.fill();
  }
  // Warm ambient glow near entrance
  const entrGlow = Math.sin(tick * 0.012) * 0.01 + 0.04;
  ctx.fillStyle = `rgba(255,200,100,${entrGlow})`;
  ctx.fillRect(440, 40, 200, 280);

  // ── TORCH FLICKER (two torches flanking the stone door) ──
  const torchL = { x: 205, y: 150 }; // left torch
  const torchR = { x: 345, y: 150 }; // right torch
  [torchL, torchR].forEach((t, i) => {
    const flicker = Math.sin(tick * 0.15 + i * 2.1) * 0.02
                  + Math.sin(tick * 0.23 + i * 3.7) * 0.01;
    // Warm glow pool around each torch
    ctx.fillStyle = `rgba(255,160,50,${0.04 + flicker})`;
    ctx.fillRect(t.x - 40, t.y - 35, 80, 70);
    ctx.fillStyle = `rgba(255,180,80,${0.06 + flicker})`;
    ctx.fillRect(t.x - 20, t.y - 18, 40, 36);
    // Tiny bright core
    ctx.fillStyle = `rgba(255,220,140,${0.08 + flicker * 2})`;
    ctx.fillRect(t.x - 3, t.y - 4, 6, 8);
  });

  // ── TIDAL POOL SHIMMER ──
  for (let wx = 140; wx < 370; wx += 6) {
    const wave = Math.sin(tick * 0.035 + wx * 0.06);
    if (wave > 0.1) {
      ctx.fillStyle = `rgba(80,200,200,${0.06 + wave * 0.08})`;
      ctx.fillRect(wx, 272 + wave * 3, 5, 1);
    }
    // Bright reflections from torchlight on water
    if (Math.sin(tick * 0.05 + wx * 0.15) > 0.7) {
      ctx.fillStyle = `rgba(255,210,120,${0.08 + Math.sin(tick * 0.08 + wx) * 0.04})`;
      ctx.fillRect(wx + 2, 278 + Math.sin(wx * 0.3) * 2, 2, 1);
    }
  }

  // ── DRIPPING WATER (from stalactites) ──
  // Drip 1: from center stalactite
  const drip1 = tick % 110;
  if (drip1 < 22) {
    const dy = drip1 * 3.2 + 45;
    if (dy < 268) {
      ctx.fillStyle = 'rgba(100,200,220,0.5)';
      ctx.fillRect(280, dy, 1, 2);
      if (drip1 > 8) ctx.fillRect(280, dy + 2, 1, 1);
    }
  }
  if (drip1 >= 22 && drip1 < 27) {
    const sp = drip1 - 22;
    ctx.fillStyle = `rgba(100,200,220,${0.3 - sp * 0.06})`;
    ctx.fillRect(278 - sp * 2, 270, 1, 1);
    ctx.fillRect(282 + sp * 2, 270, 1, 1);
  }
  // Drip 2: offset timing, different stalactite
  const drip2 = (tick + 55) % 140;
  if (drip2 < 18) {
    const dy2 = drip2 * 2.8 + 38;
    if (dy2 < 265) {
      ctx.fillStyle = 'rgba(80,180,200,0.4)';
      ctx.fillRect(180, dy2, 1, 2);
    }
  }

  // ── DUST MOTES in god-ray beams ──
  for (let d = 0; d < 8; d++) {
    const dx = 430 + Math.sin(tick * 0.012 + d * 1.9) * 80;
    const dy = 80 + Math.sin(tick * 0.009 + d * 2.4) * 110 + d * 20;
    const da = Math.sin(tick * 0.04 + d * 3.1);
    if (da > 0.2 && dx > 380) {
      ctx.fillStyle = `rgba(255,220,150,${da * 0.15})`;
      ctx.fillRect(dx, dy, 1, 1);
    }
  }

  ctx.restore();
}

// ════════════════════════════════════════════════════════════
// CHARACTER RENDERING (ported from Galaxidi Adventure)
// ════════════════════════════════════════════════════════════
const CHAR_HEIGHTS = { ntemis: 118, ajax: 84, clio: 92 };

// Per-character anatomy: waist split ratio & max leg stride (pixels)
const WALK_ANATOMY = {
  ntemis:  { waist: 0.62, stride: 7 },
  ajax:    { waist: 0.58, stride: 6 },
  clio:    { waist: 0.60, stride: 6 },
  ghost:   { waist: 0.55, stride: 0 },
  athos:   { waist: 0.60, stride: 5 },
  stathis: { waist: 0.58, stride: 6 },
  akis:    { waist: 0.60, stride: 6 },
  giannis: { waist: 0.58, stride: 5 },
  curator: { waist: 0.62, stride: 4 },
};

function drawSprite(who, gx, gy, dir, walking, frame, tick, frameOffset) {
  const img = CHAR_IMGS[who];
  if (!img || !img.complete || !img.naturalWidth) {
    drawFallbackPerson(gx, gy, who);
    return;
  }
  const sprW = img.naturalWidth;
  const sprH = img.naturalHeight;
  const anat = WALK_ANATOMY[who] || { waist: 0.60, stride: 6 };

  if (walking) {
    // ── WALK PHASE ──
    const walkPhase = frame * Math.PI * 3 + frameOffset * Math.PI / 3;
    const bob = -Math.abs(Math.sin(walkPhase)) * 3;
    const lean = dir * 0.025;
    const strideDir = Math.sin(walkPhase); // -1 to 1

    const waistY = Math.floor(sprH * anat.waist);
    const legH = sprH - waistY;
    const maxStride = anat.stride;

    // Ground shadow (stretches with stride)
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = '#4A3A28';
    const sw = sprW * 0.6 + Math.abs(strideDir) * 3;
    ctx.beginPath();
    ctx.ellipse(gx, gy + 3, sw, 3.5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.translate(gx, gy + bob);
    if (dir < 0) ctx.scale(-1, 1);
    ctx.rotate(lean);

    // ── UPPER BODY (slight counter-sway) ──
    const counterSway = -strideDir * 1.5;
    ctx.drawImage(img,
      0, 0, sprW, waistY,
      -sprW/2 + counterSway, -sprH, sprW, waistY
    );

    // ── BACK LEG (drawn first, darker, shifted opposite, lifted) ──
    const bandH = 2;
    ctx.save();
    ctx.globalAlpha = 0.7;
    for (let y = 0; y < legH; y += bandH) {
      const progress = y / Math.max(1, legH - 1);
      const backOff = -strideDir * maxStride * 0.7 * (0.3 + 0.7 * progress);
      const lift = Math.abs(strideDir) * 3 * progress;
      const h = Math.min(bandH, legH - y);
      ctx.drawImage(img,
        0, waistY + y, sprW, h,
        -sprW/2 + backOff, -sprH + waistY + y - lift, sprW, h
      );
    }
    ctx.restore();

    // ── FRONT LEG (on top, full brightness, shifted forward) ──
    for (let y = 0; y < legH; y += bandH) {
      const progress = y / Math.max(1, legH - 1);
      const frontOff = strideDir * maxStride * (0.3 + 0.7 * progress);
      const h = Math.min(bandH, legH - y);
      ctx.drawImage(img,
        0, waistY + y, sprW, h,
        -sprW/2 + frontOff, -sprH + waistY + y, sprW, h
      );
    }

    ctx.restore();

  } else {
    // ── IDLE ANIMATION ──
    const bp = tick * 0.03 + frameOffset * 3;
    const breathe = Math.sin(bp) * 1.0 + Math.sin(bp * 0.6 + 0.5) * 0.4;
    const sway = Math.sin(tick * 0.01 + frameOffset * 2.5) * 0.008
               + Math.sin(tick * 0.023 + frameOffset) * 0.003;
    const bc = Math.sin(bp);
    const squashX = 1 + bc * 0.005;
    const squashY = 1 - bc * 0.005;

    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = '#4A3A28';
    ctx.beginPath();
    ctx.ellipse(gx, gy + 3, sprW * 0.6, 4, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.translate(gx, gy + breathe);
    if (dir < 0) ctx.scale(-1, 1);
    ctx.rotate(sway);
    ctx.scale(squashX, squashY);
    ctx.drawImage(img, -sprW/2, -sprH);
    ctx.restore();
  }
}

function drawFallbackPerson(x, y, who) {
  const colors = {
    ntemis: { shirt: '#2A4466', pants: '#1a2a3a', skin: '#DDAA88' },
    ajax:   { shirt: '#4A6644', pants: '#2a3a2a', skin: '#DDBB99' },
    clio:   { shirt: '#664466', pants: '#3a2a3a', skin: '#DDC0A0' },
  };
  const c = colors[who] || colors.ntemis;
  const h = who === 'ntemis' ? 40 : 32;
  // Simple rectangle person
  ctx.fillStyle = c.skin;
  ctx.fillRect(x - 4, y - h, 8, 10); // head
  ctx.fillStyle = c.shirt;
  ctx.fillRect(x - 6, y - h + 10, 12, 14); // body
  ctx.fillStyle = c.pants;
  ctx.fillRect(x - 5, y - h + 24, 10, h - 24); // legs
}

function drawCharacter(who, tick) {
  const c = chars[who];
  if (!c.visible) return;
  const offsets = { ntemis: 0, ajax: 1.05, clio: 2.1 };
  // Fade-in alpha with smoothstep
  let alpha = Math.min(1, c.fadeIn);
  if (alpha < 1) {
    alpha = alpha * alpha * (3 - 2 * alpha); // smoothstep
    ctx.save();
    ctx.globalAlpha = alpha;
  }
  drawSprite(who, c.x, c.y, c.dir, c.walking, c.frame, tick, offsets[who]);
  if (alpha < 1) ctx.restore();
}

function drawNPC(who, tick) {
  const npc = npcChars[who];
  if (!npc || !npc.visible || npc.scene !== state.scene) return;
  const img = CHAR_IMGS[who];
  if (!img || !img.complete || !img.naturalWidth) return;

  const sprW = img.naturalWidth;
  const sprH = img.naturalHeight;
  const gx = npc.x;
  const gy = npc.y;

  // Idle animation (same as family chars)
  const bp = tick * 0.03;
  const breathe = Math.sin(bp) * 1.0 + Math.sin(bp * 0.6 + 0.5) * 0.4;
  const sway = Math.sin(tick * 0.01) * 0.008 + Math.sin(tick * 0.023) * 0.003;
  const bc = Math.sin(bp);
  const squashX = 1 + bc * 0.005;
  const squashY = 1 - bc * 0.005;

  // Ground shadow
  ctx.save();
  ctx.globalAlpha = who === 'ghost' ? 0.06 : 0.18;
  ctx.fillStyle = '#4A3A28';
  ctx.beginPath();
  ctx.ellipse(gx, gy + 3, sprW * 0.6, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  ctx.save();
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';

  // Ghost special effects
  if (who === 'ghost') {
    ctx.globalAlpha = 0.45 + Math.sin(tick * 0.02) * 0.1;
    // Blue glow aura
    ctx.shadowColor = 'rgba(100,180,255,0.5)';
    ctx.shadowBlur = 12;
  }

  ctx.translate(gx, gy + breathe);
  if (npc.dir < 0) ctx.scale(-1, 1);
  ctx.rotate(sway);
  ctx.scale(squashX, squashY);
  ctx.drawImage(img, -sprW / 2, -sprH);
  ctx.restore();
}

// ════════════════════════════════════════════════════════════
// WALKING SYSTEM
// ════════════════════════════════════════════════════════════
function startWalk(who, targetX, cb) {
  const c = chars[who];
  const dist = Math.abs(targetX - c.x);
  if (dist < 5) { if (cb) cb(); return; }
  targetX = Math.max(30, Math.min(GW - 30, targetX));
  c.dir = targetX > c.x ? 1 : -1;
  c.walking = true;
  c.startX = c.x;
  c.targetX = targetX;
  c.walkT = 0;
  c.walkDur = Math.max(0.4, Math.min(2.0, (dist / GW) * 2.5));
  c.frame = 0;
  walkDoneCallback = cb;
}

function updateWalking(dt) {
  for (const who of ['ntemis','ajax','clio']) {
    const c = chars[who];
    if (!c.walking) continue;
    c.walkT += dt;
    const p = Math.min(1, c.walkT / c.walkDur);
    const ep = easeInOutCubic(p);
    c.x = c.startX + (c.targetX - c.startX) * ep;

    // Store raw walk time for smooth interpolation in drawSprite
    c.frame = c.walkT;

    if (p >= 1) {
      c.x = c.targetX;
      c.walking = false;
      c.targetX = null;
      c.dir = 1;
      if (who === 'ntemis' && walkDoneCallback) {
        const cb = walkDoneCallback;
        walkDoneCallback = null;
        cb();
      }
    }
  }
}

// Family follow: Ajax and Clio follow Ntemis with offset
function familyFollow(targetX) {
  const nX = targetX;
  // Ajax follows to the right, Clio to the left
  const ajaxTarget = Math.min(GW - 30, nX + 70);
  const clioTarget = Math.max(30, nX - 70);
  setTimeout(() => startWalk('ajax', ajaxTarget), 150);
  setTimeout(() => startWalk('clio', clioTarget), 280);
}

// ════════════════════════════════════════════════════════════
// HOTSPOT HIT TESTING
// ════════════════════════════════════════════════════════════
function hitTestObj(gx, gy) {
  if (!state.scene) return null;
  const sc = scenes[state.scene];
  for (const obj of sc.objects) {
    if (gx >= obj.x && gx <= obj.x + obj.w && gy >= obj.y && gy <= obj.y + obj.h) {
      return obj;
    }
  }
  return null;
}

function hitTestExit(gx, gy) {
  if (!state.scene) return null;
  const sc = scenes[state.scene];
  if (!sc.exits) return null;
  for (const exit of sc.exits) {
    if (exit.side === 'left' && gx < 25) return exit;
    if (exit.side === 'right' && gx > GW - 25) return exit;
  }
  return null;
}

// ════════════════════════════════════════════════════════════
// VOICE SYSTEM
// ════════════════════════════════════════════════════════════
const voiceAudio = new Audio();
voiceAudio.volume = 0.8;

const VOICE_MAP = {
  // ── Ntemis (Eric) ──
  'Φτάσαμε, παιδιά. Αυτό είναι το σπίτι μας για το Σαββατοκύριακο.': 'music/voices/ntemis/01-ftasame.mp3',
  'Ας μπούμε μέσα.': 'music/voices/ntemis/02-as-mpoume.mp3',
  'Καλωσορίσατε στο Γαλαξίδι.': 'music/voices/ntemis/03-kalosorisate.mp3',
  'Δεν μπορώ να μιλήσω σε αυτό.': 'music/voices/ntemis/04-den-mporo.mp3',
  'Δεν ανοίγει.': 'music/voices/ntemis/05-den-anoigei.mp3',
  'Δεν ξέρω πώς.': 'music/voices/ntemis/06-den-xero.mp3',
  'Φυσικά.': 'music/voices/ntemis/07-fysika.mp3',
  'Δεν είναι δική μας. Ας κοιτάξω μέσα πρώτα.': 'music/voices/ntemis/08-den-einai-diki.mp3',
  '«Σας περιμέναμε»... Ποιος μας περιμένει;': 'music/voices/ntemis/09-sas-perimenavame.mp3',
  // ── Ajax (Charlie) ──
  'Τέλειο! Πάμε κατευθείαν στο λιμάνι;': 'music/voices/ajax/01-teleio-pame.mp3',
  'Μπαμπά, θα πάμε βόλτα με βάρκα;': 'music/voices/ajax/02-volta-varka.mp3',
  'Άδειο. Κρίμα!': 'music/voices/ajax/03-adeio-krima.mp3',
  'Δελφίνια μέσα στο λιμάνι; Αυτό δεν είναι συνηθισμένο...': 'music/voices/ajax/04-delfinia.mp3',
  'Μπαμπά, μπορώ να φάω ένα;': 'music/voices/ajax/05-fao-ena.mp3',
  'Και κάτι πάνω στην καρέκλα... μια τσάντα;': 'music/voices/ajax/06-tsanta.mp3',
  'Πάμε στο λιμάνι!': 'music/voices/ajax/07-pame-limani.mp3',
  // ── Clio (Jessica) ──
  'Πρώτα ας αφήσουμε τις βαλίτσες. Θέλω να δω τη βεράντα.': 'music/voices/clio/01-valitses.mp3',
  'Μπαμπά, μην τις κόβεις! Είναι τέλειες έτσι.': 'music/voices/clio/02-min-tis-koveis.mp3',
  'Μπαμπά, κοίτα! Δελφίνια!': 'music/voices/clio/03-delfinia.mp3',
  'Αυτό είναι το πιο όμορφο μέρος στον κόσμο.': 'music/voices/clio/04-pio-omorfo.mp3',
  'Μπαμπά, κοίτα — υπάρχει κάτι μέσα.': 'music/voices/clio/05-kati-mesa.mp3',
  'Κοιτάξτε — κάποιος μας άφησε σύκα!': 'music/voices/clio/06-syka.mp3',
  'Ο «Γ.» ξέρει ότι είμαστε τρεις. Πρέπει να πάμε.': 'music/voices/clio/07-gamma-xerei.mp3',
  'Οι Αμφικτίονες ξεκινούσαν από τους Δελφούς... Το Γαλαξίδι ήταν λιμάνι τους.': 'music/voices/clio/08-amfiktiones.mp3',
  'Μπαμπά, μην ακουμπάς, φαίνεται παλιό!': 'music/voices/clio/09-min-akoumpas.mp3',
  // ── Narrator (George) ──
  'Ξύλινη πόρτα βαμμένη μπλε. Το χρώμα του Αιγαίου.': 'music/voices/narrator/01-porta-mple.mp3',
  'Ροζ μπουκαμβίλιες σκαρφαλώνουν στον τοίχο. Εδώ το καλοκαίρι αρνείται να φύγει.': 'music/voices/narrator/02-boukamvilies.mp3',
  'Πήλινες γλάστρες με βασιλικό. Κάποιος τα περιποιείται ακόμα κι όταν το σπίτι μένει κλειστό.': 'music/voices/narrator/03-vasiliko.mp3',
  'Ένα παλιό ξύλινο βαρέλι. Μυρίζει κρασί και αλμύρα.': 'music/voices/narrator/04-vareli.mp3',
  'Χρωματιστά ψαροκάικα δεμένα στο λιμάνι. Κουνιούνται αργά στο απογευματινό φως.': 'music/voices/narrator/05-korinthiakos.mp3',
  'Ο Κορινθιακός κόλπος λάμπει χρυσαφί στο ηλιοβασίλεμα. Μαγικό.': 'music/voices/narrator/05-korinthiakos.mp3',
  'Ο ήλιος βάφει χρυσά τα καλντερίμια. Μυρωδιά πεύκου ανακατεμένη με θαλασσινό αλάτι.': 'music/voices/narrator/06-ilios-kalderimia.mp3',
  'Τρία δελφίνια κόβουν βόλτες στο λιμάνι.': 'music/voices/narrator/07-delfinia.mp3',
  'Τα δελφίνια συνεχίζουν τους κύκλους τους. Σαν να φυλάνε κάτι.': 'music/voices/narrator/08-delfinia-kyklous.mp3',
  'Κεραμίδια, σκεπές, καμινάδες. Κάθε σπίτι κι ένας καπετάνιος κάποτε.': 'music/voices/narrator/09-keramidia.mp3',
  'Ο Παρνασσός στο βάθος. Οι Δελφοί κάπου εκεί πάνω.': 'music/voices/narrator/10-parnassos.mp3',
  'Πέτρινο κάγκελο με θέα ολόκληρο το Γαλαξίδι. Θα μπορούσες να κάτσεις εδώ ώρες.': 'music/voices/narrator/11-kagelo.mp3',
  'Η θέα κόβει την ανάσα.': 'music/voices/narrator/12-thea-kovei.mp3',
  'Φρέσκα σύκα σε πήλινο μπολ. Η μυρωδιά γεμίζει το δωμάτιο.': 'music/voices/narrator/13-syka.mp3',
  'Τρως ένα σύκο. Γλυκό σαν μέλι.': 'music/voices/narrator/14-syko-meli.mp3',
  'Μια παλιά δερμάτινη τσάντα πάνω στην καρέκλα. Δεν είναι δική σας.': 'music/voices/narrator/15-tsanta.mp3',
  'Η τσάντα είναι άδεια τώρα.': 'music/voices/narrator/16-tsanta-adeia.mp3',
  'Απογευματινό φως μέσα από γαλάζια πατζούρια. Σκιές χορεύουν στον τοίχο.': 'music/voices/narrator/17-patzouria.mp3',
  'Ανοίγεις τα πατζούρια. Μυρωδιά θυμαριού και τζιτζίκια.': 'music/voices/narrator/18-anoigeis-patzouria.mp3',
  'Χάλκινα σκεύη κρεμασμένα στον τοίχο. Κάποτε τάιζαν οικογένειες ναυτικών.': 'music/voices/narrator/19-halkina.mp3',
  'Πέτρινο τζάκι. Μέσα υπάρχουν ακόμα στάχτες από τον τελευταίο χειμώνα.': 'music/voices/narrator/20-tzaki.mp3',
  'Η κουζίνα μυρίζει θυμάρι και παλιό ξύλο.': 'music/voices/narrator/21-kouzina.mp3',
  'Τίποτα ιδιαίτερο.': 'music/voices/narrator/22-tipota.mp3',
  '«Σας περιμέναμε. Ελάτε στο λιμάνι απόψε. Τραπέζι για τρεις. — Γ.»': 'music/voices/narrator/23-sas-perimenavame.mp3',
  'Το χαρτί μυρίζει θάλασσα. Παλιομοδίτικο γράψιμο.': 'music/voices/narrator/24-harti-thalassa.mp3',
  'Ο ήλιος βυθίζεται πίσω από τα βουνά. Το λιμάνι περιμένει.': 'music/voices/narrator/25-ilios-vythizetai.mp3',
  'Γεράνια σε πήλινη γλάστρα. Τα χρώματα λάμπουν στο ηλιοβασίλεμα.': 'music/voices/narrator/26-gerania.mp3',
  'Ο Κορινθιακός λάμπει σαν λιωμένο χρυσάφι. Ψαροκάικα κουνιούνται αργά στο λιμάνι.': 'music/voices/narrator/27-korinthiakos-hrysafi.mp3',
};

function playVoice(text) {
  voiceAudio.pause();
  voiceAudio.currentTime = 0;
  const src = VOICE_MAP[text];
  if (src) {
    voiceAudio.src = src;
    voiceAudio.play().catch(() => {});
  }
}

function stopVoice() {
  voiceAudio.pause();
  voiceAudio.currentTime = 0;
}

// ════════════════════════════════════════════════════════════
// DIALOGUE SYSTEM
// ════════════════════════════════════════════════════════════
function showDlg(lines, cb) {
  const filtered = lines.filter(l => l.t);
  if (!filtered.length) { if (cb) cb(); return; }
  state.dlg.queue = [...filtered];
  state.dlg.active = true;
  state.dlg.cb = cb || null;
  nextDlgLine();
}

function nextDlgLine() {
  if (!state.dlg.queue.length) { closeDlg(); return; }
  const l = state.dlg.queue.shift();
  state.dlg.speaker = l.s || '';
  state.dlg.text = l.t;
  state.dlg.displayed = '';
  state.dlg.charIdx = 0;
  state.dlg.timer = 0;
  playVoice(l.t);
}

function updateDlg(dt) {
  if (!state.dlg.active) return;
  if (state.dlg.charIdx < state.dlg.text.length) {
    state.dlg.timer += dt;
    while (state.dlg.timer >= 0.03 && state.dlg.charIdx < state.dlg.text.length) {
      state.dlg.timer -= 0.03;
      state.dlg.charIdx++;
      state.dlg.displayed = state.dlg.text.substring(0, state.dlg.charIdx);
    }
  }
}

function advanceDlg() {
  if (!state.dlg.active) return;
  if (state.dlg.charIdx < state.dlg.text.length) {
    // Skip typewriter
    state.dlg.charIdx = state.dlg.text.length;
    state.dlg.displayed = state.dlg.text;
  } else {
    nextDlgLine();
  }
}

function closeDlg() {
  state.dlg.active = false;
  state.dlg.queue = [];
  stopVoice();
  if (state.dlg.cb) { const cb = state.dlg.cb; state.dlg.cb = null; cb(); }
  checkEnd();
}

function drawDialogue() {
  if (!state.dlg.active) return;
  const boxH = 90;
  const boxY = GH - boxH;

  // Background
  ctx.save();
  ctx.globalAlpha = 0.92;
  ctx.fillStyle = '#0a0806';
  ctx.fillRect(0, boxY, GW, boxH);
  ctx.restore();

  // Top border
  ctx.fillStyle = '#D4A03C';
  ctx.fillRect(0, boxY, GW, 2);

  // Portrait — only show for named speakers
  const portSize = 56;
  const portX = 12;
  const portY = boxY + 8;
  const hasSpeaker = !!state.dlg.speaker;

  let textX;
  if (hasSpeaker) {
    ctx.strokeStyle = '#D4A03C';
    ctx.lineWidth = 2;
    ctx.strokeRect(portX, portY, portSize, portSize);
    ctx.fillStyle = '#1a1714';
    ctx.fillRect(portX + 1, portY + 1, portSize - 2, portSize - 2);

    const portImg = PORTRAITS[state.dlg.speaker];
    if (portImg && portImg.complete) {
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(portImg, portX + 2, portY + 2, portSize - 4, portSize - 4);
      ctx.imageSmoothingEnabled = false;
    } else {
      ctx.fillStyle = '#4a4a4a';
      ctx.font = '16px serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('?', portX + portSize/2, portY + portSize/2);
    }

    textX = portX + portSize + 12;

    ctx.fillStyle = '#D4A03C';
    ctx.font = '9px "Press Start 2P", monospace';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText(state.dlg.speaker, textX, portY + 2);
  } else {
    // Narration — no portrait box, full width
    textX = 16;
  }

  // Dialogue text with word wrapping
  ctx.fillStyle = hasSpeaker ? '#e8dcc8' : '#D4A03C';
  ctx.font = '8px "Press Start 2P", monospace';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  const maxW = GW - textX - 16;
  const lineH = 16;
  const startY = portY + (state.dlg.speaker ? 18 : 6);
  wrapText(state.dlg.displayed, textX, startY, maxW, lineH);

  // Continue indicator
  if (state.dlg.charIdx >= state.dlg.text.length) {
    const blink = Math.sin(state.tick * 0.12) > 0;
    if (blink) {
      ctx.fillStyle = '#4a4a4a';
      ctx.font = '8px "Press Start 2P", monospace';
      ctx.textAlign = 'right';
      ctx.fillText('▶', GW - 12, boxY + boxH - 14);
    }
  }
}

function wrapText(text, x, y, maxW, lineH) {
  const words = text.split(' ');
  let line = '';
  let curY = y;
  for (const word of words) {
    const test = line ? line + ' ' + word : word;
    const m = ctx.measureText(test);
    if (m.width > maxW && line) {
      ctx.fillText(line, x, curY);
      line = word;
      curY += lineH;
    } else {
      line = test;
    }
  }
  if (line) ctx.fillText(line, x, curY);
}

// ════════════════════════════════════════════════════════════
// VERB SYSTEM
// ════════════════════════════════════════════════════════════
const verbLabels = { look:'Κοίταξε', talk:'Μίλησε', open:'Άνοιξε', use:'Χρησιμοποίησε' };
// Verb fallbacks: "use" tries pick/push/close; "open" tries use
const verbFallbacks = { use: ['pick','push','close','open'], open: ['use'] };

function setVerb(v) {
  state.verb = v;
  document.querySelectorAll('.vb').forEach(b => b.classList.remove('on'));
  document.querySelector(`[data-v="${v}"]`)?.classList.add('on');
  updateActionLine();
}

function updateActionLine() {
  const al = document.getElementById('action-line');
  const obj = state.hoverObj;
  al.textContent = obj ? `${verbLabels[state.verb]} ${obj.label}` : (verbLabels[state.verb] || '');
}

function objClick(obj) {
  if (state.dlg.active) return;
  const objCenterX = obj.x + obj.w / 2;

  // Walk Ntemis to object, then execute verb
  startWalk('ntemis', objCenterX, () => {
    let d = obj.verbs[state.verb];
    // Verb fallback: "use" tries open/push/close if no direct match
    if (!d && verbFallbacks[state.verb]) {
      for (const fb of verbFallbacks[state.verb]) {
        if (obj.verbs[fb]) { d = obj.verbs[fb]; break; }
      }
    }
    if (!d) {
      const defs = {
        look:[{s:'',t:'Τίποτα ιδιαίτερο.'}],
        talk:[{s:'ΝΤΕΜΗΣ',t:'Δεν μπορώ να μιλήσω σε αυτό.'}],
        open:[{s:'ΝΤΕΜΗΣ',t:'Δεν ανοίγει.'}],
        use:[{s:'ΝΤΕΜΗΣ',t:'Δεν ξέρω πώς.'}],
      };
      if (defs[state.verb]?.length) showDlg(defs[state.verb]);
      return;
    }
    if (typeof d === 'string') { changeScene(d); return; }
    if (typeof d === 'function') d = d();
    if (Array.isArray(d) && d.length) showDlg(d);
  });
  familyFollow(objCenterX);
}

// ════════════════════════════════════════════════════════════
// INVENTORY
// ════════════════════════════════════════════════════════════
function addInv(item) {
  if (state.inv.find(i => i.id === item.id)) return;
  state.inv.push(item);
  renderInvUI();
}

// Inventory item icons — pixel art drawn on mini canvases (52x52)
const INV_ICONS = {
  note: (c) => {
    // Rolled scroll with wax seal
    c.fillStyle='#c4a870'; c.fillRect(12,4,28,40);
    c.fillStyle='#d8c490'; c.fillRect(14,6,24,36);
    // Roll top
    c.fillStyle='#b09058'; c.fillRect(10,4,32,5);
    c.fillStyle='#c4a870';
    c.beginPath(); c.ellipse(10,7,3,4,0,0,Math.PI*2); c.fill();
    c.beginPath(); c.ellipse(42,7,3,4,0,0,Math.PI*2); c.fill();
    // Text lines
    c.fillStyle='#8a7a58';
    for(let y=14;y<38;y+=5) c.fillRect(18,y,18,2);
    // Wax seal
    c.fillStyle='#b03030'; c.beginPath(); c.arc(36,38,5,0,Math.PI*2); c.fill();
    c.fillStyle='#d04040'; c.beginPath(); c.arc(35,37,3,0,Math.PI*2); c.fill();
    // "Γ" on seal
    c.fillStyle='#e8c8c8'; c.font='bold 5px sans-serif'; c.textAlign='center'; c.textBaseline='middle';
    c.fillText('Γ',36,38);
  },
  compass: (c) => {
    // Brass compass body
    c.fillStyle='#8a6a30'; c.beginPath(); c.arc(26,26,18,0,Math.PI*2); c.fill();
    c.fillStyle='#b08838'; c.beginPath(); c.arc(26,26,16,0,Math.PI*2); c.fill();
    c.fillStyle='#1a1810'; c.beginPath(); c.arc(26,26,14,0,Math.PI*2); c.fill();
    // Compass rose
    c.fillStyle='#c03030'; c.beginPath(); c.moveTo(26,12); c.lineTo(28,26); c.lineTo(24,26); c.fill();
    c.fillStyle='#e0d0c0'; c.beginPath(); c.moveTo(26,40); c.lineTo(28,26); c.lineTo(24,26); c.fill();
    c.fillStyle='#607090'; c.beginPath(); c.moveTo(12,26); c.lineTo(26,24); c.lineTo(26,28); c.fill();
    c.fillStyle='#607090'; c.beginPath(); c.moveTo(40,26); c.lineTo(26,24); c.lineTo(26,28); c.fill();
    // Center pin
    c.fillStyle='#d4a03c'; c.beginPath(); c.arc(26,26,2,0,Math.PI*2); c.fill();
    // N marker
    c.fillStyle='#c03030'; c.font='bold 5px sans-serif'; c.textAlign='center'; c.fillText('N',26,11);
  },
  shell: (c) => {
    // Scallop shell
    c.fillStyle='#e8d0b0'; c.beginPath(); c.ellipse(26,28,16,12,0,0,Math.PI*2); c.fill();
    c.fillStyle='#d4b89c'; c.beginPath(); c.ellipse(26,30,14,10,0,0,Math.PI); c.fill();
    // Ridges
    c.strokeStyle='#a08060'; c.lineWidth=1.5;
    for(let i=0;i<7;i++){c.beginPath();c.moveTo(26,16);c.lineTo(12+i*5,40);c.stroke();}
    // Highlight
    c.fillStyle='rgba(255,255,255,0.2)'; c.beginPath(); c.ellipse(22,24,6,4,-.3,0,Math.PI*2); c.fill();
  },
  candle: (c) => {
    // Candlestick with flame
    c.fillStyle='#8a6a30'; c.fillRect(20,36,12,8); // base
    c.fillStyle='#a08038'; c.fillRect(22,34,8,4); // holder
    c.fillStyle='#e8dcc0'; c.fillRect(24,16,4,20); // wax body
    c.fillStyle='#d4c8a0'; c.fillRect(23,16,6,3); // wax top
    // Wick
    c.fillStyle='#2a2a2a'; c.fillRect(25,12,2,5);
    // Flame
    c.fillStyle='#d4a03c'; c.beginPath(); c.ellipse(26,10,5,8,0,0,Math.PI*2); c.fill();
    c.fillStyle='#f0d060'; c.beginPath(); c.ellipse(26,10,3,5,0,0,Math.PI*2); c.fill();
    c.fillStyle='#fff8e0'; c.beginPath(); c.ellipse(26,11,1,3,0,0,Math.PI*2); c.fill();
  },
  key: (c) => {
    // Ornate brass key
    c.fillStyle='#c49030'; c.strokeStyle='#8a6020'; c.lineWidth=1;
    // Bow (head)
    c.beginPath(); c.arc(16,20,8,0,Math.PI*2); c.fill(); c.stroke();
    c.fillStyle='#1a1208'; c.beginPath(); c.arc(16,20,4,0,Math.PI*2); c.fill();
    // Shaft
    c.fillStyle='#c49030'; c.fillRect(23,18,20,4);
    c.strokeStyle='#8a6020'; c.strokeRect(23,18,20,4);
    // Teeth
    c.fillStyle='#c49030';
    c.fillRect(38,22,3,6); c.fillRect(34,22,2,4); c.fillRect(42,18,2,4);
    c.strokeStyle='#8a6020';
    c.strokeRect(38,22,3,6); c.strokeRect(34,22,2,4);
  },
};

function renderInvUI() {
  const grid = document.getElementById('inv-grid');
  grid.innerHTML = '';
  for (const item of state.inv) {
    const slot = document.createElement('div');
    slot.className = 'inv-slot';
    slot.dataset.id = item.id;
    slot.onclick = () => invClick(item.id);
    if (INV_ICONS[item.id]) {
      const cvs = document.createElement('canvas');
      cvs.width = 52; cvs.height = 52;
      cvs.style.cssText = 'width:52px;height:52px;image-rendering:pixelated';
      INV_ICONS[item.id](cvs.getContext('2d'));
      slot.appendChild(cvs);
    } else {
      const txt = document.createElement('span');
      txt.className = 'inv-text';
      txt.textContent = item.label;
      slot.appendChild(txt);
    }
    slot.title = item.label;
    grid.appendChild(slot);
  }
}

function scrollInv(dir) {
  const grid = document.getElementById('inv-grid');
  grid.scrollLeft += dir * 50;
}

function invClick(id) {
  if (id === 'note' && state.verb === 'look') {
    showDlg([{s:'',t:'«Σας περιμέναμε. Ελάτε στο λιμάνι απόψε. Τραπέζι για τρεις. — Γ.»'},{s:'',t:'Το χαρτί μυρίζει θάλασσα. Παλιομοδίτικο γράψιμο.'}]);
  }
  document.querySelectorAll('.inv-slot').forEach(s => s.classList.remove('on'));
  document.querySelector(`[data-id="${id}"]`)?.classList.add('on');
}

// ════════════════════════════════════════════════════════════
// SCENE MANAGEMENT
// ════════════════════════════════════════════════════════════
function startScene(id) {
  const sc = scenes[id];
  state.scene = id;
  state.hoverObj = null;

  document.getElementById('ui-panel').classList.add('on');
  document.getElementById('action-line').classList.add('on');

  // Position characters
  for (const [who, pos] of Object.entries(sc.charPos)) {
    chars[who].x = pos.x;
    chars[who].y = pos.y;
    chars[who].walking = false;
    chars[who].visible = true;
    chars[who].fadeIn = 0; // start fade-in
    chars[who].dir = 1;
  }

  initParticles();
  initAmbientSound();
  startSceneAmbience(id);
  changeSceneMusic(id);

  // Entry dialogue (first visit only)
  if (!state.visited.has(id) && sc.entry) {
    state.visited.add(id);
    setTimeout(() => showDlg(sc.entry), 600);
  } else {
    state.visited.add(id);
    // Clio auto-comment on revisit (after a short delay)
    scheduleClio(id);
  }
}

// ── Clio Auto-Comments — spontaneous observations on scene entry ──
const clioComments = {
  exterior: [
    'Μπαμπά, η μπουκαμβίλια μεγάλωσε από χθες!',
    'Ακούω τζιτζίκια. Πόσο αγαπώ αυτόν τον ήχο.',
    'Κοίτα πώς λάμπει η θάλασσα.',
    'Μυρίζει πεύκο και αλάτι.',
  ],
  terrace: [
    'Θα μπορούσα να μείνω εδώ για πάντα.',
    'Κοίτα τα βουνά, μπαμπά!',
    'Βλέπω ένα καράβι στο βάθος.',
    'Ο αέρας εδώ πάνω είναι μαγικός.',
  ],
  kitchen: [
    'Η κουζίνα μυρίζει σαν το σπίτι του παππού.',
    'Μπαμπά, πεινάω...',
    'Κοίτα πόσα σκεύη! Κάποτε μαγείρευαν για πολλούς.',
    'Φαντάζομαι τον παππού να κάθεται εδώ.',
  ],
  port: [
    'Τα καΐκια κουνιούνται σαν να χορεύουν.',
    'Μπαμπά, μπορώ να πατήσω πάνω στα σχοινιά;',
    'Μυρίζει ψάρι και θαλασσινό αλάτι.',
    'Φαντάζομαι πώς ήταν γεμάτο καράβια κάποτε.',
  ],
  museum: [
    'Σσσ... πρέπει να είμαστε ήσυχοι εδώ μέσα;',
    'Πόσα μυστικά κρύβουν αυτά τα πλοία...',
    'Κοίτα τη χάρτα! Πόσα ταξίδια!',
  ],
  liotrivi: [
    'Μυρίζει ελιά. Λατρεύω αυτή τη μυρωδιά.',
    'Φαντάσου πόσα χέρια γύρισαν αυτή την πέτρα.',
  ],
  cave: [
    'Είναι σκοτεινά εδώ μέσα...',
    'Μπαμπά, κρατήσε με σφιχτά.',
    'Ακούω σταγόνες. Σαν να χτυπάει ρολόι.',
  ],
  windmill: [
    'Βλέπω ολόκληρο το Γαλαξίδι από εδώ πάνω!',
    'Ο αέρας θέλει να με πάρει!',
  ],
  graveyard: [
    'Κάθε πέτρα κι ένα ταξίδι...',
    'Είναι ήσυχα εδώ. Σαν να ακούω τη θάλασσα να τους νανουρίζει.',
  ],
  church: [
    'Τι ωραία εκκλησία...',
    'Μπαμπά, να ρίξω νόμισμα στο σιντριβάνι;',
  ],
  boat: [
    'Κουνιέται! Κρατήσου καλά, Αίαντα!',
    'Βλέπω το Γαλαξίδι από εδώ. Είναι τόσο μικρό...',
  ],
  treasure: [
    'Νιώθω ότι είμαστε κοντά...',
  ],
};

// Track which comments Clio has already said per scene
const clioSaid = {};
let clioTimer = null;

function scheduleClio(sceneId) {
  if (clioTimer) { clearTimeout(clioTimer); clioTimer = null; }
  const pool = clioComments[sceneId];
  if (!pool || pool.length === 0) return;
  if (!clioSaid[sceneId]) clioSaid[sceneId] = new Set();
  // Find unsaid comments
  const unsaid = pool.filter((_, i) => !clioSaid[sceneId].has(i));
  if (unsaid.length === 0) return; // all said, stay quiet
  // Pick a random unsaid comment
  const idx = pool.indexOf(unsaid[Math.floor(Math.random() * unsaid.length)]);
  clioSaid[sceneId].add(idx);
  // Delay: 3-5 seconds after scene loads, only if no dialog active
  const delay = 3000 + Math.random() * 2000;
  clioTimer = setTimeout(() => {
    clioTimer = null;
    if (state.dlg.active || state.scene !== sceneId) return;
    showDlg([{ s: 'ΚΛΕΙΩ', t: pool[idx] }]);
  }, delay);
}

function changeScene(id) {
  if (clioTimer) { clearTimeout(clioTimer); clioTimer = null; }
  // Iris wipe centered on Ntemis
  state.fade.active = true;
  state.fade.alpha = 0;
  state.fade.dir = 1; // iris close
  state.fade.mode = 'iris';
  state.fade.cx = chars.ntemis.x;
  state.fade.cy = chars.ntemis.y - 30; // chest height
  state.fade.cb = () => {
    startScene(id);
    state.fade.cx = chars.ntemis.x;
    state.fade.cy = chars.ntemis.y - 30;
    state.fade.dir = -1; // iris open
    state.fade.cb = () => { state.fade.active = false; state.fade.mode = null; };
  };
}

function checkEnd() {
  if (state.flags.note && !state.flags.done) {
    state.flags.done = 1;
    setTimeout(() => showDlg([
      {s:'ΝΤΕΜΗΣ',t:'«Σας περιμέναμε»... Ποιος μας περιμένει;'},
      {s:'ΚΛΕΙΩ',t:'Ο «Γ.» ξέρει ότι είμαστε τρεις. Πρέπει να πάμε.'},
      {s:'ΑΙΑΣ',t:'Πάμε στο λιμάνι!'},
      {s:'',t:'Ο ήλιος βυθίζεται πίσω από τα βουνά. Το λιμάνι περιμένει.'},
      {s:'',t:'— Τέλος Σκηνής 1 —'},
      {s:'',t:'Συνέχεια στη Σκηνή 2: Το Γράμμα...'},
    ]), 1500);
  }
}

// ════════════════════════════════════════════════════════════
// RENDER — Main drawing function
// ════════════════════════════════════════════════════════════
function render() {
  ctx.clearRect(0, 0, GW, GH);

  // Canvas-rendered title screen
  if (state.phase === 'title') {
    drawTitleScreen(state.tick);
    return;
  }

  if (state.phase !== 'playing') return;
  if (!state.scene) return;

  const sc = scenes[state.scene];

  // Background
  const bgImg = images[sc.bg];
  if (bgImg) {
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(bgImg, 0, 0, GW, GH);
    ctx.imageSmoothingEnabled = false;
  } else {
    ctx.fillStyle = '#1a1510';
    ctx.fillRect(0, 0, GW, GH);
  }

  // Ambient overlay
  const grad = ctx.createLinearGradient(0, 0, 0, GH);
  grad.addColorStop(0, 'rgba(212,160,60,0.03)');
  grad.addColorStop(0.3, 'rgba(0,0,0,0)');
  grad.addColorStop(0.7, 'rgba(0,0,0,0)');
  grad.addColorStop(1, 'rgba(0,0,0,0.15)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, GW, GH);

  // Scene-specific ambience (behind characters)
  drawSceneAmbience(state.tick);

  // Dust particles
  drawParticles();

  // Hotspot shimmer hints — subtle sparkles on all interactive objects
  if (sc.objects) {
    const t = state.tick;
    for (let i = 0; i < sc.objects.length; i++) {
      const obj = sc.objects[i];
      if (obj === state.hoverObj) continue;
      const seed = (obj.x * 7 + obj.y * 13 + i * 31);
      const sparkleT = (t + seed) * 0.03;
      const alpha = Math.max(0, Math.sin(sparkleT) * 0.6 - 0.2);
      if (alpha > 0) {
        ctx.save();
        ctx.globalAlpha = alpha * 0.5;
        const sx = obj.x + (seed * 17 % obj.w);
        const sy = obj.y + (seed * 23 % obj.h);
        ctx.fillStyle = '#FFE8A0';
        ctx.beginPath();
        ctx.moveTo(sx, sy - 2); ctx.lineTo(sx + 0.7, sy);
        ctx.lineTo(sx, sy + 2); ctx.lineTo(sx - 0.7, sy);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }
  }

  // Hotspot highlight on hover — soft pulsing glow
  if (state.hoverObj && state.hoverObj.w) {
    const obj = state.hoverObj;
    const pulse = 0.35 + Math.sin(state.tick * 0.08) * 0.15;
    ctx.save();
    ctx.shadowColor = 'rgba(255,220,120,0.6)';
    ctx.shadowBlur = 6;
    ctx.strokeStyle = `rgba(212,160,60,${pulse})`;
    ctx.lineWidth = 1.5;
    const r = 3, hx = obj.x - 2, hy = obj.y - 2, hw = obj.w + 4, hh = obj.h + 4;
    ctx.beginPath();
    ctx.moveTo(hx + r, hy);
    ctx.lineTo(hx + hw - r, hy); ctx.arcTo(hx + hw, hy, hx + hw, hy + r, r);
    ctx.lineTo(hx + hw, hy + hh - r); ctx.arcTo(hx + hw, hy + hh, hx + hw - r, hy + hh, r);
    ctx.lineTo(hx + r, hy + hh); ctx.arcTo(hx, hy + hh, hx, hy + hh - r, r);
    ctx.lineTo(hx, hy + r); ctx.arcTo(hx, hy, hx + r, hy, r);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }

  // Exit zone highlights with pulsing arrow
  if (sc.exits) {
    const arrowPulse = 0.6 + Math.sin(state.tick * 0.06) * 0.4;
    const arrowBob = Math.sin(state.tick * 0.08) * 2;
    for (const exit of sc.exits) {
      const isHover = (exit.side === 'left' && state.mouseGX < 25) ||
                      (exit.side === 'right' && state.mouseGX > GW - 25);
      if (isHover) {
        ctx.save();
        const exGrad = exit.side === 'left'
          ? ctx.createLinearGradient(0, 0, 30, 0)
          : ctx.createLinearGradient(GW, 0, GW - 30, 0);
        exGrad.addColorStop(0, `rgba(212,160,60,${0.12 + arrowPulse * 0.08})`);
        exGrad.addColorStop(1, 'rgba(212,160,60,0)');
        ctx.fillStyle = exGrad;
        if (exit.side === 'left') ctx.fillRect(0, 0, 30, GH);
        else ctx.fillRect(GW - 30, 0, 30, GH);
        // Pulsing bobbing arrow
        ctx.globalAlpha = arrowPulse;
        ctx.fillStyle = '#FFE8A0';
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const ax = exit.side === 'left' ? 12 + arrowBob : GW - 12 - arrowBob;
        ctx.fillText(exit.side === 'left' ? '◀' : '▶', ax, GH / 2);
        ctx.restore();
      }
    }
  }

  // NPCs in current scene
  for (const npcId of Object.keys(npcChars)) {
    drawNPC(npcId, state.tick);
  }

  // Characters — back to front for depth
  drawCharacter('clio', state.tick);
  drawCharacter('ajax', state.tick);
  drawCharacter('ntemis', state.tick);

  // Scene label
  ctx.save();
  ctx.fillStyle = '#D4A03C';
  ctx.font = '8px "Press Start 2P", monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.shadowColor = '#000';
  ctx.shadowBlur = 4;
  ctx.shadowOffsetX = 2;
  ctx.shadowOffsetY = 2;
  ctx.fillText(sc.label, GW / 2, 8);
  ctx.restore();

  // Music toggle icon
  ctx.save();
  ctx.globalAlpha = state.musicOn ? 0.5 : 0.2;
  ctx.fillStyle = '#D4A03C';
  ctx.font = '14px sans-serif';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'top';
  ctx.fillText('♪', GW - 8, 8);
  ctx.restore();

  // Dialogue overlay
  drawDialogue();

  // Transition overlay — iris wipe or flat fade
  if (state.fade.active && state.fade.alpha > 0) {
    ctx.save();
    if (state.fade.mode === 'iris') {
      // Iris wipe: circle shrinks/grows centered on character
      const maxR = Math.sqrt(GW * GW + GH * GH) * 0.6;
      const radius = maxR * (1 - state.fade.alpha);
      const cx = state.fade.cx || GW / 2;
      const cy = state.fade.cy || GH / 2;
      // Draw black everywhere except the circle
      ctx.beginPath();
      ctx.rect(0, 0, GW, GH);
      ctx.arc(cx, cy, Math.max(0, radius), 0, Math.PI * 2, true); // counter-clockwise = hole
      ctx.fillStyle = '#000';
      ctx.fill('evenodd');
    } else {
      ctx.globalAlpha = state.fade.alpha;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, GW, GH);
    }
    ctx.restore();
  }
}

// ════════════════════════════════════════════════════════════
// UPDATE — Main logic update
// ════════════════════════════════════════════════════════════
function update(dt) {
  state.tick++;

  // Title screen — start music on first interaction (handled by click)
  if (state.phase === 'title') return;

  if (state.phase !== 'playing') return;

  // Walking
  updateWalking(dt);

  // Character fade-in
  for (const who of ['ntemis','ajax','clio']) {
    if (chars[who].fadeIn < 1) {
      const delays = { ntemis: 0.1, ajax: 0.3, clio: 0.5 };
      if (state.tick > delays[who] * 60) {
        chars[who].fadeIn = Math.min(1, chars[who].fadeIn + dt * 1.5);
      }
    }
  }

  // Dialogue typewriter
  updateDlg(dt);

  // Particles
  updateParticles();

  // Scene ambience (seagulls, petals, cat, sounds)
  updateSceneAmbience(dt);

  // Fade/iris transition
  if (state.fade.active) {
    const speed = state.fade.mode === 'iris' ? 1.5 : 2.0;
    state.fade.alpha += state.fade.dir * dt * speed;
    if (state.fade.dir > 0 && state.fade.alpha >= 1) {
      state.fade.alpha = 1;
      if (state.fade.cb) { const cb = state.fade.cb; state.fade.cb = null; cb(); }
    }
    if (state.fade.dir < 0 && state.fade.alpha <= 0) {
      state.fade.alpha = 0;
      if (state.fade.cb) { const cb = state.fade.cb; state.fade.cb = null; cb(); }
    }
  }
}

// ════════════════════════════════════════════════════════════
// GAME LOOP
// ════════════════════════════════════════════════════════════
let lastTime = 0;

function gameLoop(timestamp) {
  const dt = lastTime ? Math.min((timestamp - lastTime) / 1000, 0.05) : 0.016;
  lastTime = timestamp;

  // Resize canvas to fill available space
  const rect = CVS.getBoundingClientRect();
  // Keep internal resolution fixed, CSS handles scaling

  update(dt);
  render();
  requestAnimationFrame(gameLoop);
}

// ════════════════════════════════════════════════════════════
// INPUT HANDLING
// ════════════════════════════════════════════════════════════
CVS.addEventListener('mousemove', (e) => {
  const g = screenToGame(e.clientX, e.clientY);
  state.mouseGX = g.x;
  state.mouseGY = g.y;

  if (state.phase === 'title') {
    CVS.style.cursor = 'pointer';
    return;
  }

  if (state.phase !== 'playing' || state.dlg.active) {
    CVS.style.cursor = state.dlg.active ? 'pointer' : 'default';
    state.hoverObj = null;
    updateActionLine();
    return;
  }

  // Check hotspots
  const obj = hitTestObj(g.x, g.y);
  state.hoverObj = obj;

  // Check exits for cursor change
  const exit = hitTestExit(g.x, g.y);
  if (exit) {
    CVS.style.cursor = exit.side === 'left' ? 'w-resize' : 'e-resize';
    state.hoverObj = { label: exit.label }; // fake obj for action line
  } else if (obj) {
    // Verb-aware cursor
    const verbCursors = { look: 'zoom-in', talk: 'help', open: 'grab', use: 'pointer' };
    CVS.style.cursor = verbCursors[state.verb] || 'pointer';
  } else {
    CVS.style.cursor = g.y > 200 ? 'crosshair' : 'default';
  }
  updateActionLine();
});

CVS.addEventListener('click', (e) => {
  const g = screenToGame(e.clientX, e.clientY);

  // Title clicks handled by dedicated handler
  if (state.phase !== 'playing') return;

  // Dialogue advance
  if (state.dlg.active) { advanceDlg(); return; }

  // Music toggle (top-right corner)
  if (g.x > GW - 30 && g.y < 25) { toggleMusic(); return; }

  // Check exit zones
  const exit = hitTestExit(g.x, g.y);
  if (exit) { changeScene(exit.target); return; }

  // Check hotspots
  const obj = hitTestObj(g.x, g.y);
  if (obj) { objClick(obj); return; }

  // Click ground — walk Ntemis
  if (g.y > 200) { // Only walk on ground area
    startWalk('ntemis', g.x);
    familyFollow(g.x);
  }
});

// Keyboard
document.addEventListener('keydown', e => {
  if (e.key === ' ' || e.key === 'Enter') {
    e.preventDefault();
    if (state.dlg.active) advanceDlg();
  }
  const vk = {'1':'look','2':'talk','3':'open','4':'use'};
  if (vk[e.key] && state.phase === 'playing') setVerb(vk[e.key]);
});

// ════════════════════════════════════════════════════════════
// MUSIC
// ════════════════════════════════════════════════════════════
const bgm = document.getElementById('bgm');
bgm.volume = 0.25;

// Per-scene music map
const sceneMusic = {
  exterior: 'music/arrival-at-galaxidi-scene-1-1.mp3',
  terrace:  'music/arrival-at-galaxidi-scene-1-1.mp3',
  kitchen:  'music/the-grandfather-s-house-1.mp3',
  port:     'music/the-harbor-at-dusk-1.mp3',
  museum:   'music/the-maritime-museum-1.mp3',
  liotrivi: 'music/the-old-olive-press-1.mp3',
  cave:     'music/the-cave-of-karkaros-1.mp3',
  graveyard:'music/the-captain-s-rest-1.mp3',
  church:   'music/the-map-in-the-church-1.mp3',
  boat:     'music/the-crossing-1.mp3',
  cave_final:'music/the-treasure-1.mp3',
  epilogue:  'music/the-sea-remembers-1.mp3',
};

let currentMusicSrc = '';

function changeSceneMusic(sceneId) {
  const newSrc = sceneMusic[sceneId];
  if (!newSrc || newSrc === currentMusicSrc) return;
  // Crossfade: old out, new in
  const oldVol = bgm.volume;
  const fadeDur = 1500;
  const fadeStart = performance.now();
  const fadeOut = () => {
    const t = Math.min(1, (performance.now() - fadeStart) / fadeDur);
    bgm.volume = oldVol * (1 - t);
    if (t < 1) { requestAnimationFrame(fadeOut); return; }
    bgm.pause();
    bgm.src = newSrc;
    currentMusicSrc = newSrc;
    bgm.volume = 0;
    bgm.play().catch(() => {});
    // Fade in
    const fadeInStart = performance.now();
    const fadeIn = () => {
      const t2 = Math.min(1, (performance.now() - fadeInStart) / fadeDur);
      bgm.volume = 0.25 * t2;
      if (t2 < 1) requestAnimationFrame(fadeIn);
    };
    requestAnimationFrame(fadeIn);
  };
  requestAnimationFrame(fadeOut);
}

function toggleMusic() {
  if (state.musicOn) {
    bgm.pause(); state.musicOn = false;
  } else {
    bgm.play().catch(() => {}); state.musicOn = true;
  }
}

// ════════════════════════════════════════════════════════════
// TITLE SCREEN — Bright sunny harbor with animated title
// ════════════════════════════════════════════════════════════
const titleMusic = document.getElementById('title-music');
titleMusic.volume = 0.7;
let titleFadeOut = 0;
let titleStartTick = -1;

// Title text animation config
const titleLine1 = 'ΤΟ ΜΥΣΤΗΡΙΟ';
const titleLine2 = 'του';
const titleLine3 = 'ΓΑΛΑΞΕΙΔΙΟΥ';
const LETTER_DELAY = 4;
const LINE2_DELAY = 55;
const LINE3_DELAY = 25;
const PROMPT_DELAY = 70;

function drawTitleScreen(tick) {
  if (titleStartTick < 0) titleStartTick = tick;
  const elapsed = tick - titleStartTick;

  // ═══════════════════════════════════════
  // BACKGROUND — static pixel art
  // ═══════════════════════════════════════
  const bg = images['title-bg'];

  if (bg && bg.complete) {
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(bg, 0, 0, GW, GH);
    ctx.imageSmoothingEnabled = false;
  } else {
    ctx.fillStyle = '#4A9FD8';
    ctx.fillRect(0, 0, GW, GH);
  }

  // Subtle vignette
  const vig = ctx.createRadialGradient(GW/2, GH/2, GW*0.3, GW/2, GH/2, GW*0.75);
  vig.addColorStop(0, 'rgba(0,0,0,0)');
  vig.addColorStop(1, 'rgba(0,0,0,0.12)');
  ctx.fillStyle = vig;
  ctx.fillRect(0, 0, GW, GH);

  // ═══════════════════════════════════════
  // ANIMATED TITLE — letters unfold cinematically
  // ═══════════════════════════════════════
  const l1N = titleLine1.length;
  const l1End = l1N * LETTER_DELAY;
  const l2Start = l1End + LINE2_DELAY;
  const l2End = l2Start + 15;
  const l3Start = l2End + LINE3_DELAY;
  const l3N = titleLine3.length;
  const l3End = l3Start + l3N * LETTER_DELAY;
  const promptAt = l3End + PROMPT_DELAY;

  ctx.save();
  ctx.textBaseline = 'middle';

  // Single letter renderer with scale-in animation
  function drawLetter(ch, cx, cy, size, progress) {
    if (progress <= 0) return;
    const p = Math.min(1, progress);
    const scale = p < 0.5 ? 1.5 - p : 1.0 + Math.sin((p-0.5)*Math.PI)*0.05;
    const alpha = Math.min(1, p * 2);
    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(scale, scale);
    ctx.globalAlpha = alpha;
    ctx.font = `bold ${size}px "Press Start 2P", monospace`;
    ctx.textAlign = 'center';
    // Shadow layers
    const shd = [['#060200',5],['#1A0804',4],['#2E1508',3],['#4A2010',2],['#7A5018',1]];
    for (const [c,d] of shd) { ctx.fillStyle = c; ctx.fillText(ch, d, d); }
    // Gold with glow
    const g = 0.3 + Math.sin(tick*0.024 + cx*0.01)*0.15;
    ctx.shadowColor = `rgba(255,180,40,${g*alpha})`;
    ctx.shadowBlur = 20;
    ctx.fillStyle = '#D4A03C';
    ctx.fillText(ch, 0, 0);
    ctx.shadowBlur = 0;
    ctx.fillStyle = `rgba(255,235,170,${0.35*alpha})`;
    ctx.fillText(ch, 0, -1);
    ctx.restore();
  }

  // Line 1: "ΤΟ ΜΥΣΤΗΡΙΟ"
  const l1Size = 36, l1Y = 100;
  ctx.font = `bold ${l1Size}px "Press Start 2P", monospace`;
  ctx.textAlign = 'left';
  const l1W = ctx.measureText(titleLine1).width;
  let l1X = (GW - l1W) / 2;
  for (let i = 0; i < l1N; i++) {
    const ch = titleLine1[i];
    const chW = ctx.measureText(ch).width;
    drawLetter(ch, l1X + chW/2, l1Y, l1Size, (elapsed - i*LETTER_DELAY)/20);
    l1X += chW;
  }

  // Line 2: "του"
  if (elapsed > l2Start) {
    const p2 = Math.min(1, (elapsed - l2Start) / 25);
    ctx.save();
    ctx.globalAlpha = p2;
    ctx.translate(GW/2, l1Y + 50);
    ctx.scale(1.3 - p2*0.3, 1.3 - p2*0.3);
    ctx.font = 'bold 14px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#1A0804'; ctx.fillText(titleLine2, 2, 2);
    ctx.fillStyle = '#B8842C'; ctx.fillText(titleLine2, 0, 0);
    ctx.restore();
  }

  // Line 3: "ΓΑΛΑΞΕΙΔΙΟΥ"
  const l3Size = 38, l3Y = l1Y + 102;
  ctx.font = `bold ${l3Size}px "Press Start 2P", monospace`;
  const l3W = ctx.measureText(titleLine3).width;
  let l3X = (GW - l3W) / 2;
  for (let i = 0; i < l3N; i++) {
    const ch = titleLine3[i];
    const chW = ctx.measureText(ch).width;
    drawLetter(ch, l3X + chW/2, l3Y, l3Size, (elapsed - l3Start - i*LETTER_DELAY)/20);
    l3X += chW;
  }
  ctx.restore();


  // Blinking start prompt
  if (elapsed > promptAt) {
    const blink = 0.2 + Math.sin(tick*0.06)*0.45;
    ctx.save();
    ctx.font = '8px "Press Start 2P", monospace';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.globalAlpha = Math.max(0, blink);
    ctx.fillStyle = '#D4A03C';
    ctx.shadowColor = 'rgba(212,160,60,0.5)'; ctx.shadowBlur = 10;
    ctx.fillText('► ΚΛΙΚ ΓΙΑ ΕΝΑΡΞΗ ◄', GW/2, GH - 35);
    ctx.restore();
  }

  // Fade overlay
  if (titleFadeOut > 0) {
    ctx.save();
    ctx.globalAlpha = titleFadeOut;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, GW, GH);
    ctx.restore();
  }
}



// ════════════════════════════════════════════════════════════
// TITLE & INTRO FLOW
// ════════════════════════════════════════════════════════════
let titleClicked = false;
let titleMusicStarted = false;

// Start title music on any user gesture (needed for autoplay policy)
function ensureTitleMusic() {
  if (!titleMusicStarted && state.phase === 'title') {
    titleMusic.currentTime = 0;
    const p = titleMusic.play();
    if (p) p.then(() => { titleMusicStarted = true; console.log('Title music playing'); }).catch(e => console.warn('Title music blocked:', e));
  }
}
// Try immediately + on any interaction
ensureTitleMusic();
document.addEventListener('click', ensureTitleMusic);
document.addEventListener('keydown', ensureTitleMusic);
document.addEventListener('touchstart', ensureTitleMusic);

CVS.addEventListener('click', function titleClickHandler(e) {
  if (state.phase !== 'title' || titleClicked) return;
  // First click just starts music — need a second click to proceed
  if (!titleMusicStarted) {
    ensureTitleMusic();
    return;
  }
  titleClicked = true;

  // Keep title music playing through intro — don't fade it here

  // Animate fade to black
  const fadeStep = () => {
    titleFadeOut += 0.02;
    if (titleFadeOut < 1) {
      requestAnimationFrame(fadeStep);
    } else {
      titleFadeOut = 1;
      // Switch to intro — title music keeps playing
      state.phase = 'intro';
      state.musicOn = true;
      const intro = document.getElementById('intro-screen');
      intro.classList.add('show');
      showIntroPage();
    }
  };
  requestAnimationFrame(fadeStep);
}, { once: false });

function showIntroPage() {
  const t = document.getElementById('intro-text');
  const h = document.getElementById('intro-hint');
  t.style.opacity = '0';
  h.classList.remove('on');
  setTimeout(() => {
    t.innerHTML = introPages[state.introPage].replace(/\n/g, '<br>');
    t.style.opacity = '1';
    setTimeout(() => h.classList.add('on'), 1200);
  }, 300);
}

document.getElementById('intro-screen').onclick = () => {
  state.introPage++;
  if (state.introPage >= introPages.length) {
    const is = document.getElementById('intro-screen');
    is.style.opacity = '0';

    // Crossfade: title music out, scene music in (2 second overlap)
    currentMusicSrc = sceneMusic['exterior'];
    bgm.volume = 0;
    bgm.play().catch(() => {});
    const crossfadeDur = 2000; // 2 seconds
    const crossfadeStart = performance.now();
    const crossfadeStep = () => {
      const elapsed = performance.now() - crossfadeStart;
      const t = Math.min(1, elapsed / crossfadeDur);
      // Ease: smooth cubic
      const ease = t < 0.5 ? 4*t*t*t : 1-Math.pow(-2*t+2,3)/2;
      titleMusic.volume = Math.max(0, 0.7 * (1 - ease));
      bgm.volume = 0.25 * ease;
      if (t < 1) {
        requestAnimationFrame(crossfadeStep);
      } else {
        titleMusic.pause();
        titleMusic.volume = 0.7;
        bgm.volume = 0.25;
      }
    };
    requestAnimationFrame(crossfadeStep);

    setTimeout(() => {
      is.style.display = 'none';
      state.phase = 'playing';
      state.musicOn = true;
      startScene('exterior');
    }, 1500);
  } else {
    showIntroPage();
  }
};

// ════════════════════════════════════════════════════════════
// BOOT
// ════════════════════════════════════════════════════════════
loadAllAssets().then(() => {
  requestAnimationFrame(gameLoop);
});
</script>
</body>
</html>
