<!DOCTYPE html>
<html lang="el">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Το Μυστήριο του Γαλαξειδίου — Canvas Engine</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
  body { background: #000; overflow: hidden; font-family: 'Press Start 2P', monospace; display: flex; flex-direction: column; height: 100vh; }

  /* ── CANVAS ── */
  #game-canvas {
    display: block; background: #0a0812;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    cursor: crosshair;
    flex: 1;
    width: 100%;
    min-height: 0;
  }

  /* ── ACTION LINE — Trunk wood strip ── */
  #action-line {
    height: 36px; display: none; align-items: center; justify-content: center;
    font-family: 'Press Start 2P', monospace;
    font-size: .65rem; color: #FFE8A0; letter-spacing: 1px;
    background:
      /* Tree ring curves flowing through */
      radial-gradient(ellipse 120px 200px at -10% 50%, transparent 65%, rgba(45,28,8,0.12) 66%, transparent 67%, transparent 72%, rgba(40,25,8,0.08) 73%, transparent 74%),
      radial-gradient(ellipse 140px 220px at 110% 50%, transparent 60%, rgba(42,26,8,0.1) 61%, transparent 62%, transparent 68%, rgba(48,30,10,0.07) 69%, transparent 70%),
      /* Grain lines */
      repeating-linear-gradient(87deg, transparent 0px, transparent 5px, rgba(80,55,20,0.1) 5px, rgba(80,55,20,0.1) 6px, transparent 6px, transparent 18px),
      repeating-linear-gradient(93deg, transparent 0px, transparent 11px, rgba(0,0,0,0.07) 11px, rgba(0,0,0,0.07) 12px, transparent 12px, transparent 30px),
      /* Stains */
      radial-gradient(ellipse 80px 20px at 25% 60%, rgba(90,60,20,0.12) 0%, transparent 100%),
      radial-gradient(ellipse 60px 18px at 70% 30%, rgba(40,25,8,0.1) 0%, transparent 100%),
      linear-gradient(180deg, #5a4228 0%, #4e3820 20%, #3e2c18 50%, #4a3620 75%, #2e1e0e 100%);
    border-top: 3px solid #8a6e42;
    border-bottom: 2px solid #1a0e04;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.9), 0 0 10px rgba(255,220,120,0.25);
    box-shadow: inset 0 1px 0 rgba(255,220,160,0.12), inset 0 -1px 0 rgba(0,0,0,0.3);
  }
  #action-line.on { display: flex; }

  /* ── UI PANEL — MI2 rough-hewn trunk wood ── */
  #ui-panel {
    background:
      /* === ETCHED ROSES — carved into the wood === */
      /* Rose 1 — top-left, full bloom */
      radial-gradient(ellipse 11px 10px at 8% 18%, rgba(90,25,15,0.22) 0%, rgba(65,18,10,0.12) 45%, transparent 100%),
      radial-gradient(ellipse 14px 13px at 8% 18%, transparent 55%, rgba(75,20,12,0.1) 60%, transparent 68%),
      radial-gradient(ellipse 18px 16px at 8% 18%, transparent 62%, rgba(60,16,8,0.07) 66%, transparent 74%),
      radial-gradient(ellipse 8px 10px at 6% 15%, rgba(95,28,18,0.15) 0%, transparent 70%),
      radial-gradient(ellipse 9px 7px at 10% 21%, rgba(85,22,14,0.13) 0%, transparent 65%),
      radial-gradient(ellipse 7px 9px at 7% 22%, rgba(80,20,12,0.11) 0%, transparent 60%),
      /* Rose 2 — center-right, bud */
      radial-gradient(ellipse 9px 8px at 72% 28%, rgba(85,22,14,0.2) 0%, rgba(60,16,8,0.1) 50%, transparent 100%),
      radial-gradient(ellipse 12px 11px at 72% 28%, transparent 50%, rgba(70,18,10,0.08) 56%, transparent 65%),
      radial-gradient(ellipse 7px 8px at 70% 25%, rgba(90,25,16,0.12) 0%, transparent 65%),
      radial-gradient(ellipse 6px 7px at 74% 31%, rgba(80,20,12,0.1) 0%, transparent 60%),
      /* Rose 3 — bottom-center */
      radial-gradient(ellipse 10px 9px at 45% 82%, rgba(88,24,15,0.18) 0%, rgba(62,17,9,0.09) 48%, transparent 100%),
      radial-gradient(ellipse 14px 12px at 45% 82%, transparent 52%, rgba(68,18,10,0.07) 58%, transparent 68%),
      radial-gradient(ellipse 8px 9px at 43% 79%, rgba(92,26,16,0.12) 0%, transparent 65%),
      radial-gradient(ellipse 7px 8px at 47% 85%, rgba(82,21,13,0.1) 0%, transparent 60%),
      /* Rose 4 — far right */
      radial-gradient(ellipse 7px 6px at 92% 65%, rgba(80,20,12,0.18) 0%, rgba(55,14,7,0.08) 50%, transparent 100%),
      radial-gradient(ellipse 10px 9px at 92% 65%, transparent 48%, rgba(65,16,8,0.07) 55%, transparent 65%),
      /* === TWISTING VINES — carved S-curves === */
      radial-gradient(ellipse 300px 180px at -5% -20%, transparent 96%, rgba(28,45,15,0.14) 96.5%, rgba(28,45,15,0.14) 97%, transparent 97.5%),
      radial-gradient(ellipse 280px 200px at 35% 130%, transparent 93%, rgba(25,40,12,0.12) 93.5%, rgba(25,40,12,0.12) 94%, transparent 94.5%),
      radial-gradient(ellipse 320px 160px at 70% -30%, transparent 95%, rgba(30,48,16,0.13) 95.5%, rgba(30,48,16,0.13) 96%, transparent 96.5%),
      radial-gradient(ellipse 250px 180px at 105% 120%, transparent 94%, rgba(26,42,14,0.11) 94.5%, rgba(26,42,14,0.11) 95%, transparent 95.5%),
      radial-gradient(ellipse 200px 120px at 15% 110%, transparent 95.5%, rgba(22,38,12,0.1) 96%, rgba(22,38,12,0.1) 96.3%, transparent 96.8%),
      radial-gradient(ellipse 180px 140px at 85% -10%, transparent 94.5%, rgba(24,40,13,0.09) 95%, rgba(24,40,13,0.09) 95.3%, transparent 95.8%),
      /* === THORNS === */
      radial-gradient(ellipse 3px 6px at 12% 35%, rgba(30,48,16,0.16) 0%, transparent 100%),
      radial-gradient(ellipse 3px 5px at 25% 72%, rgba(28,45,14,0.14) 0%, transparent 100%),
      radial-gradient(ellipse 4px 6px at 38% 25%, rgba(32,50,18,0.13) 0%, transparent 100%),
      radial-gradient(ellipse 3px 5px at 55% 80%, rgba(26,42,13,0.15) 0%, transparent 100%),
      radial-gradient(ellipse 3px 6px at 65% 38%, rgba(30,48,16,0.12) 0%, transparent 100%),
      radial-gradient(ellipse 4px 5px at 78% 70%, rgba(28,45,14,0.14) 0%, transparent 100%),
      radial-gradient(ellipse 3px 6px at 88% 42%, rgba(32,50,18,0.11) 0%, transparent 100%),
      /* === LEAVES along vines === */
      radial-gradient(ellipse 10px 5px at 15% 30%, rgba(30,52,18,0.14) 0%, rgba(25,42,14,0.06) 50%, transparent 100%),
      radial-gradient(ellipse 8px 4px at 22% 68%, rgba(28,48,16,0.12) 0%, transparent 100%),
      radial-gradient(ellipse 9px 5px at 35% 22%, rgba(32,55,20,0.11) 0%, transparent 100%),
      radial-gradient(ellipse 11px 5px at 52% 78%, rgba(26,45,15,0.13) 0%, transparent 100%),
      radial-gradient(ellipse 8px 4px at 62% 35%, rgba(30,50,18,0.1) 0%, transparent 100%),
      radial-gradient(ellipse 10px 5px at 75% 68%, rgba(28,48,16,0.12) 0%, transparent 100%),
      radial-gradient(ellipse 9px 4px at 85% 40%, rgba(32,52,18,0.1) 0%, transparent 100%),
      radial-gradient(ellipse 7px 4px at 48% 15%, rgba(26,44,14,0.11) 0%, transparent 100%),
      /* === TREE RINGS === */
      radial-gradient(ellipse 180px 300px at -20% 50%,
        transparent 58%, rgba(45,28,8,0.12) 59%, transparent 60%,
        transparent 63%, rgba(50,30,10,0.08) 64%, transparent 65%,
        transparent 69%, rgba(40,25,8,0.1) 70%, transparent 71%,
        transparent 76%, rgba(55,35,12,0.07) 77%, transparent 78%
      ),
      radial-gradient(ellipse 200px 350px at 110% 40%,
        transparent 55%, rgba(40,25,8,0.1) 56%, transparent 57%,
        transparent 61%, rgba(50,32,10,0.07) 62%, transparent 63%,
        transparent 68%, rgba(42,26,8,0.09) 69%, transparent 70%
      ),
      /* === GRAIN LINES === */
      repeating-linear-gradient(87deg, transparent 0px, transparent 4px, rgba(0,0,0,0.07) 4px, rgba(0,0,0,0.07) 5.5px, transparent 5.5px, transparent 10px, rgba(55,35,12,0.05) 10px, rgba(55,35,12,0.05) 11px, transparent 11px, transparent 18px),
      repeating-linear-gradient(92deg, transparent 0px, transparent 6px, rgba(0,0,0,0.05) 6px, rgba(0,0,0,0.05) 7px, transparent 7px, transparent 15px, rgba(60,40,15,0.04) 15px, rgba(60,40,15,0.04) 16px, transparent 16px, transparent 25px),
      /* === KNOTS === */
      radial-gradient(ellipse 18px 14px at 18% 45%, rgba(20,10,2,0.3) 0%, rgba(35,20,5,0.15) 35%, transparent 60%),
      radial-gradient(ellipse 12px 10px at 62% 60%, rgba(22,12,3,0.25) 0%, rgba(40,25,8,0.1) 40%, transparent 65%),
      /* === WORN patches === */
      radial-gradient(ellipse 80px 45px at 30% 50%, rgba(100,70,30,0.06) 0%, transparent 100%),
      radial-gradient(ellipse 70px 40px at 78% 55%, rgba(90,62,25,0.05) 0%, transparent 100%),
      /* === BASE wood === */
      linear-gradient(180deg,
        #6b5030 0%, #5e4528 5%, #523c22 12%, #5a4428 18%,
        #4a3620 28%, #523e24 35%, #443018 45%, #4e3a22 55%,
        #3e2c16 62%, #463420 70%, #382814 78%, #3e3018 85%,
        #2e2010 93%, #241a0c 100%
      );
    border-top: 4px solid #7a5e38;
    display: none; flex-direction: column;
    box-shadow:
      inset 0 2px 0 rgba(255,200,120,0.1),
      inset 0 -3px 6px rgba(0,0,0,0.5),
      0 -2px 8px rgba(0,0,0,0.5);
    position: relative;
    overflow: hidden;
  }
  #ui-panel.on { display: flex; }
  /* Vine + rosette border along top */
  #ui-panel::before {
    content: '';
    position: absolute; top: 0; left: 0; right: 0; height: 8px;
    background:
      radial-gradient(ellipse 40px 12px at 10% 60%, rgba(30,50,18,0.18) 0%, transparent 80%),
      radial-gradient(ellipse 35px 10px at 30% 40%, rgba(28,46,16,0.15) 0%, transparent 75%),
      radial-gradient(ellipse 45px 12px at 50% 65%, rgba(32,52,20,0.17) 0%, transparent 80%),
      radial-gradient(ellipse 38px 10px at 70% 35%, rgba(26,44,14,0.14) 0%, transparent 75%),
      radial-gradient(ellipse 42px 12px at 90% 55%, rgba(30,48,18,0.16) 0%, transparent 80%),
      radial-gradient(circle 3px at 20% 50%, rgba(90,25,15,0.2) 0%, rgba(70,18,10,0.08) 50%, transparent 100%),
      radial-gradient(circle 3px at 50% 50%, rgba(85,22,14,0.18) 0%, transparent 100%),
      radial-gradient(circle 3px at 80% 50%, rgba(88,24,15,0.2) 0%, transparent 100%),
      linear-gradient(180deg, rgba(138,110,66,0.6) 0%, rgba(100,78,40,0.3) 40%, transparent 100%);
    pointer-events: none; z-index: 1;
  }
  /* Bottom vine border */
  #ui-panel::after {
    content: '';
    position: absolute; bottom: 0; left: 0; right: 0; height: 6px;
    background:
      radial-gradient(ellipse 35px 10px at 15% 40%, rgba(28,46,16,0.15) 0%, transparent 75%),
      radial-gradient(ellipse 40px 12px at 40% 60%, rgba(30,50,18,0.16) 0%, transparent 80%),
      radial-gradient(ellipse 38px 10px at 65% 35%, rgba(26,44,14,0.14) 0%, transparent 75%),
      radial-gradient(ellipse 42px 12px at 88% 55%, rgba(32,52,20,0.16) 0%, transparent 80%),
      radial-gradient(circle 2.5px at 28% 50%, rgba(88,24,15,0.18) 0%, transparent 100%),
      radial-gradient(circle 2.5px at 55% 50%, rgba(85,22,14,0.16) 0%, transparent 100%),
      radial-gradient(circle 2.5px at 78% 50%, rgba(90,25,15,0.18) 0%, transparent 100%),
      linear-gradient(180deg, transparent 0%, rgba(26,16,8,0.4) 60%, rgba(20,12,4,0.6) 100%);
    pointer-events: none; z-index: 1;
  }

  /* Bottom row: verbs LEFT, inventory RIGHT */
  #ui-bottom {
    display: flex; height: 150px; padding: 8px 10px;
  }

  /* ── VERB GRID — Rough carved buttons ── */
  #verb-panel {
    display: grid; grid-template-columns: repeat(2, 1fr); grid-template-rows: repeat(2, 1fr);
    gap: 5px; width: 300px; flex-shrink: 0;
  }
  .vb {
    font-family: 'Press Start 2P', monospace; font-size: .6rem; color: #c8a868;
    background:
      /* Tree ring arc through button */
      radial-gradient(ellipse 80px 120px at -15% 50%,
        transparent 55%, rgba(42,26,8,0.13) 56%, transparent 57%,
        transparent 63%, rgba(38,22,6,0.09) 64%, transparent 65%
      ),
      /* Grain lines at angles */
      repeating-linear-gradient(86deg, transparent 0px, transparent 4px, rgba(0,0,0,0.07) 4px, rgba(0,0,0,0.07) 5.5px, transparent 5.5px, transparent 11px),
      repeating-linear-gradient(93deg, transparent 0px, transparent 8px, rgba(60,40,15,0.05) 8px, rgba(60,40,15,0.05) 9px, transparent 9px, transparent 20px),
      /* Small knot */
      radial-gradient(ellipse 8px 6px at 75% 35%, rgba(25,14,4,0.2) 0%, rgba(40,25,8,0.08) 50%, transparent 100%),
      /* Uneven color patches */
      radial-gradient(ellipse 40px 25px at 30% 40%, rgba(70,48,18,0.12) 0%, transparent 100%),
      radial-gradient(ellipse 35px 20px at 70% 60%, rgba(40,25,8,0.1) 0%, transparent 100%),
      linear-gradient(180deg, #4a3822 0%, #3e2e18 25%, #3a2a16 50%, #352814 75%, #2e2010 100%);
    border: 3px solid #5a4428;
    border-top-color: #7a6040; border-left-color: #6a5438;
    border-bottom-color: #2a1c0c; border-right-color: #2a1c0c;
    cursor: pointer; transition: all .12s;
    display: flex; align-items: center; justify-content: center;
    padding: 4px 8px; text-align: center;
    text-shadow: 1px 1px 1px rgba(0,0,0,0.8), 0 1px 0 rgba(0,0,0,0.5);
    box-shadow:
      inset 0 1px 0 rgba(255,200,120,0.08),
      inset -1px -1px 0 rgba(0,0,0,0.15),
      2px 2px 4px rgba(0,0,0,0.45);
    border-radius: 1px;
  }
  .vb:hover {
    color: #FFE090;
    background:
      radial-gradient(ellipse 80px 120px at -15% 50%, transparent 55%, rgba(52,34,12,0.13) 56%, transparent 57%, transparent 63%, rgba(48,30,10,0.09) 64%, transparent 65%),
      repeating-linear-gradient(86deg, transparent 0px, transparent 4px, rgba(0,0,0,0.07) 4px, rgba(0,0,0,0.07) 5.5px, transparent 5.5px, transparent 11px),
      repeating-linear-gradient(93deg, transparent 0px, transparent 8px, rgba(60,40,15,0.05) 8px, rgba(60,40,15,0.05) 9px, transparent 9px, transparent 20px),
      radial-gradient(ellipse 8px 6px at 75% 35%, rgba(25,14,4,0.2) 0%, rgba(40,25,8,0.08) 50%, transparent 100%),
      radial-gradient(ellipse 40px 25px at 30% 40%, rgba(90,60,22,0.12) 0%, transparent 100%),
      linear-gradient(180deg, #5a4828 0%, #4e3e20 30%, #443418 60%, #3a2c14 100%);
    border-top-color: #9a7848; border-left-color: #8a6840;
    text-shadow: 0 0 8px rgba(255,224,144,0.3), 1px 1px 1px rgba(0,0,0,0.8);
    box-shadow:
      inset 0 1px 0 rgba(255,200,120,0.12),
      inset -1px -1px 0 rgba(0,0,0,0.1),
      2px 2px 5px rgba(0,0,0,0.35),
      0 0 8px rgba(180,140,60,0.08);
  }
  .vb:active { transform: scale(.97); }
  .vb.on {
    color: #FFE8A0;
    background:
      radial-gradient(ellipse 80px 120px at -15% 50%, transparent 55%, rgba(55,38,14,0.12) 56%, transparent 57%, transparent 63%, rgba(50,32,12,0.08) 64%, transparent 65%),
      repeating-linear-gradient(86deg, transparent 0px, transparent 4px, rgba(255,180,60,0.05) 4px, rgba(255,180,60,0.05) 5.5px, transparent 5.5px, transparent 11px),
      radial-gradient(ellipse 8px 6px at 75% 35%, rgba(25,14,4,0.18) 0%, rgba(40,25,8,0.06) 50%, transparent 100%),
      radial-gradient(ellipse 50px 30px at 50% 50%, rgba(100,70,25,0.12) 0%, transparent 100%),
      linear-gradient(180deg, #5e4828 0%, #503c1e 30%, #483416 60%, #3e2c12 100%);
    border: 3px solid #B8903C;
    border-top-color: #D4A848; border-left-color: #C49840;
    border-bottom-color: #705020; border-right-color: #705020;
    text-shadow: 0 0 10px rgba(255,232,160,0.4), 1px 1px 1px rgba(0,0,0,0.8);
    box-shadow:
      inset 0 1px 0 rgba(255,200,120,0.15),
      inset -1px -1px 0 rgba(0,0,0,0.08),
      0 0 12px rgba(212,168,72,0.18),
      2px 2px 4px rgba(0,0,0,0.3);
  }

  /* ── INVENTORY — Dark recessed hold ── */
  #inv-panel {
    flex: 1; display: flex; align-items: stretch;
    margin-left: 10px;
    border: 3px solid #3a2a16;
    border-top-color: #221408; border-left-color: #221408;
    border-bottom-color: #6a5438; border-right-color: #5a4428;
    background:
      /* Tree ring arcs inside the hold */
      radial-gradient(ellipse 150px 250px at -5% 50%,
        transparent 58%, rgba(35,20,5,0.1) 59%, transparent 60%,
        transparent 66%, rgba(30,18,4,0.07) 67%, transparent 68%,
        transparent 75%, rgba(32,19,5,0.06) 76%, transparent 77%
      ),
      radial-gradient(ellipse 130px 200px at 105% 40%,
        transparent 55%, rgba(32,18,4,0.08) 56%, transparent 57%,
        transparent 63%, rgba(28,16,4,0.06) 64%, transparent 65%
      ),
      /* Dark wood grain inside */
      repeating-linear-gradient(87deg, transparent 0px, transparent 5px, rgba(0,0,0,0.08) 5px, rgba(0,0,0,0.08) 6.5px, transparent 6.5px, transparent 14px),
      repeating-linear-gradient(92deg, transparent 0px, transparent 9px, rgba(40,25,8,0.06) 9px, rgba(40,25,8,0.06) 10px, transparent 10px, transparent 22px),
      /* Dark knot */
      radial-gradient(ellipse 14px 11px at 35% 45%, rgba(15,8,2,0.2) 0%, rgba(25,14,4,0.08) 50%, transparent 100%),
      /* Wear stains */
      radial-gradient(ellipse 60px 30px at 55% 50%, rgba(50,35,12,0.1) 0%, transparent 100%),
      radial-gradient(ellipse 50px 25px at 80% 30%, rgba(30,18,5,0.08) 0%, transparent 100%),
      linear-gradient(180deg, #1a1206 0%, #221a0a 15%, #201808 30%, #241c0c 45%, #1e1608 60%, #28200e 75%, #1a1408 90%, #161008 100%);
    box-shadow:
      inset 0 4px 8px rgba(0,0,0,0.6),
      inset 0 -1px 0 rgba(255,200,120,0.04),
      inset 4px 0 8px rgba(0,0,0,0.35),
      inset -4px 0 8px rgba(0,0,0,0.35);
    border-radius: 2px;
    padding: 0;
  }
  #inv-label { display: none; }
  #inv-arrows {
    display: flex; flex-direction: column; justify-content: center;
    gap: 8px; padding: 6px 8px; flex-shrink: 0;
    border-right: 2px solid #1e1408;
    background:
      radial-gradient(ellipse 20px 40px at 50% 50%, rgba(50,35,12,0.1) 0%, transparent 100%),
      linear-gradient(180deg, rgba(0,0,0,0.12) 0%, transparent 40%, transparent 60%, rgba(0,0,0,0.12) 100%);
  }
  #inv-arrows button {
    font-size: .8rem; color: #B89858;
    background:
      repeating-linear-gradient(89deg, transparent 0px, transparent 5px, rgba(0,0,0,0.05) 5px, rgba(0,0,0,0.05) 6px, transparent 6px, transparent 14px),
      linear-gradient(180deg, #4a3822 0%, #3a2c18 40%, #352814 70%, #302410 100%);
    border: 2px solid #5a4428;
    border-top-color: #7a6040; border-left-color: #6a5438;
    border-bottom-color: #2a1c0c; border-right-color: #2a1c0c;
    cursor: pointer; padding: 8px 10px; line-height: 1;
    transition: all .12s;
    border-radius: 1px;
    box-shadow: 1px 2px 3px rgba(0,0,0,0.4);
    text-shadow: 0 1px 1px rgba(0,0,0,0.6);
  }
  #inv-arrows button:hover {
    color: #FFE090; border-top-color: #9a7848;
    background:
      repeating-linear-gradient(89deg, transparent 0px, transparent 5px, rgba(0,0,0,0.05) 5px, rgba(0,0,0,0.05) 6px, transparent 6px, transparent 14px),
      linear-gradient(180deg, #5a4828 0%, #4a3820 40%, #403018 70%, #3a2c16 100%);
    text-shadow: 0 0 6px rgba(255,224,144,0.25);
    box-shadow: 1px 2px 3px rgba(0,0,0,0.3), 0 0 6px rgba(180,140,60,0.08);
  }
  #inv-grid {
    flex: 1; display: grid;
    grid-template-columns: repeat(auto-fill, 60px);
    grid-template-rows: repeat(2, 60px);
    grid-auto-flow: column;
    gap: 5px; padding: 6px;
    overflow: hidden;
    align-content: center;
  }
  .inv-slot {
    width: 60px; height: 60px;
    background:
      /* Subtle grain inside slots */
      repeating-linear-gradient(90deg, transparent 0px, transparent 6px, rgba(0,0,0,0.04) 6px, rgba(0,0,0,0.04) 7px, transparent 7px, transparent 15px),
      radial-gradient(ellipse 30px 30px at 50% 50%, rgba(40,28,10,0.1) 0%, transparent 100%),
      linear-gradient(180deg, #141008 0%, #1c1608 35%, #181208 65%, #141008 100%);
    border: 2px solid #3a2c18;
    border-top-color: #1e1408; border-left-color: #1e1408;
    border-bottom-color: #4a3822; border-right-color: #4a3822;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; transition: all .12s;
    box-shadow: inset 0 2px 5px rgba(0,0,0,0.5), inset 0 -1px 0 rgba(255,200,120,0.03);
    border-radius: 1px;
  }
  .inv-slot:hover {
    border-color: #7a5e38;
    border-bottom-color: #9a7848; border-right-color: #8a6838;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.35), 0 0 6px rgba(180,140,60,0.12);
  }
  .inv-slot.on {
    border: 2px solid #B8903C;
    border-top-color: #D4A848; border-left-color: #C49840;
    border-bottom-color: #705020; border-right-color: #705020;
    background:
      repeating-linear-gradient(90deg, transparent 0px, transparent 6px, rgba(255,180,60,0.03) 6px, rgba(255,180,60,0.03) 7px, transparent 7px, transparent 15px),
      linear-gradient(180deg, #2a2010 0%, #322810 50%, #2a2010 100%);
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.2), 0 0 10px rgba(212,168,72,0.2);
  }
  .inv-slot .inv-text {
    font-family: 'Press Start 2P', monospace; font-size: .35rem; color: #c8a868;
    text-align: center; line-height: 1.3;
    text-shadow: 1px 1px 1px rgba(0,0,0,0.7);
  }

  /* ── TITLE (canvas-rendered, no HTML overlay) ── */
  @keyframes blink { 0%,100%{opacity:.3} 50%{opacity:.9} }

  /* ── INTRO OVERLAY ── */
  #intro-screen {
    position: fixed; inset: 0; background: #0a0812;
    display: none; flex-direction: column; align-items: center; justify-content: center;
    z-index: 1500; padding: 2rem; cursor: pointer; transition: opacity 1.5s;
  }
  #intro-screen.show { display: flex; }
  #intro-text { max-width:600px; font-size:clamp(.6rem,1.2vw,.8rem); color:#D4A03C; line-height:2.5; text-align:center; opacity:0; transition: opacity 1.5s; }
  #intro-hint { font-size:.5rem; color:#4a4a4a; margin-top:2rem; opacity:0; transition: opacity .5s; }
  #intro-hint.on { opacity:1; animation: blink 2s infinite; }

  /* ── FADE ── */
  #fade { position: fixed; inset: 0; background: #000; z-index: 3000; opacity: 0; pointer-events: none; transition: opacity .5s; }
  #fade.on { opacity: 1; }
</style>
</head>
<body>

<div id="fade"></div>

<!-- Title screen is canvas-rendered -->

<div id="intro-screen">
  <div id="intro-text"></div>
  <div id="intro-hint">▶ ΚΛΙΚ</div>
</div>

<canvas id="game-canvas" width="640" height="400"></canvas>

<div id="action-line"></div>

<div id="ui-panel">
  <div id="ui-bottom">
    <div id="verb-panel">
      <button class="vb on" data-v="look" onclick="setVerb('look')">Κοίταξε</button>
      <button class="vb" data-v="talk" onclick="setVerb('talk')">Μίλησε</button>
      <button class="vb" data-v="open" onclick="setVerb('open')">Άνοιξε</button>
      <button class="vb" data-v="use" onclick="setVerb('use')">Χρησιμοποίησε</button>
    </div>
    <div id="inv-panel">
      <div id="inv-arrows">
        <button onclick="scrollInv(-1)">▲</button>
        <button onclick="scrollInv(1)">▼</button>
      </div>
      <div id="inv-grid"></div>
    </div>
  </div>
</div>

<audio id="title-music" loop preload="auto"><source src="music/galaxidi-title-theme-1.mp3" type="audio/mpeg"></audio>
<audio id="bgm" loop preload="auto"><source src="music/arrival-at-galaxidi-scene-1-1.mp3" type="audio/mpeg"></audio>

<script>
// ════════════════════════════════════════════════════════════
// CANVAS ENGINE — Pure requestAnimationFrame game loop
// ════════════════════════════════════════════════════════════
const CVS = document.getElementById('game-canvas');
const ctx = CVS.getContext('2d');
const GW = 640, GH = 400; // internal game resolution
CVS.width = GW; CVS.height = GH;

// ── Layer cache: offscreen buffers for static content ──
const bgBuffer = document.createElement('canvas');
bgBuffer.width = GW; bgBuffer.height = GH;
const bgCtx = bgBuffer.getContext('2d');
let bgCachedScene = null; // invalidate when scene changes

// ════════════════════════════════════════════════════════════
// STATE
// ════════════════════════════════════════════════════════════
const state = {
  phase: 'title', // title, intro, playing
  scene: null,
  verb: 'look',
  inv: [],
  flags: {},
  visited: new Set(),
  tick: 0,
  mouseGX: 0, mouseGY: 0,
  hoverObj: null,
  musicOn: false,
  dlg: { active: false, queue: [], text: '', displayed: '', charIdx: 0, timer: 0, speaker: '', cb: null },
  fade: { active: false, alpha: 0, dir: 0, cb: null },
  introPage: 0,
  cutscene: {
    active: false, id: null, frameIdx: 0, frameTime: 0, totalTime: 0,
    transitioning: false, fadeAlpha: 0,
    dlgText: '', dlgDisplayed: '', dlgSpeaker: '', dlgCharIdx: 0, dlgTimer: 0,
    dlgTriggered: new Set(),
  },
  seq: {
    active: false, steps: [], stepIdx: 0, stepTimer: 0,
    ghostMat: { progress: 0, alpha: 0, glowBlur: 30, active: false },
    env: { darken: 0, vignette: 0, spectral: 0 },
    swirlParticles: [],
    stoneGlow: { active: false, progress: 0 },
  },
};

// Characters
const chars = {
  ntemis: { x: 0, y: 0, dir: 1, walking: false, frame: 0, targetX: null, startX: 0, walkT: 0, walkDur: 0, visible: true, fadeIn: 0 },
  ajax:   { x: 0, y: 0, dir: 1, walking: false, frame: 0, targetX: null, startX: 0, walkT: 0, walkDur: 0, visible: true, fadeIn: 0 },
  clio:   { x: 0, y: 0, dir: 1, walking: false, frame: 0, targetX: null, startX: 0, walkT: 0, walkDur: 0, visible: true, fadeIn: 0 },
};

// NPC characters — static, scene-specific
const npcChars = {
  ghost:   { scene: 'graveyard', x: 460, y: 280, dir: -1, visible: false, tilt: 0, wave: 0 },
  athos:   { scene: 'liotrivi', x: 120, y: 335, dir: 1, visible: true },
  stathis: { scene: 'port', x: 80, y: 340, dir: 1, visible: true },
  akis:    { scene: 'port', x: 150, y: 342, dir: 1, visible: true },
  giannis: { scene: 'windmill', x: 150, y: 340, dir: 1, visible: true },
  curator: { scene: 'museum', x: 100, y: 340, dir: 1, visible: true },
};

let walkDoneCallback = null;

// ════════════════════════════════════════════════════════════
// IMAGE LOADING
// ════════════════════════════════════════════════════════════
const images = {};
function loadImg(key, src) {
  return new Promise(resolve => {
    const img = new Image();
    img.onload = () => { images[key] = img; resolve(img); };
    img.onerror = () => { console.warn('Failed to load:', src); resolve(null); };
    img.src = src;
  });
}

// Character idle sprites
const CHAR_IMGS = {};
const WALK_FRAMES = { ntemis: [], ajax: [], clio: [] };
const PORTRAITS = {};

async function loadAllAssets() {
  // Backgrounds
  await Promise.all([
    loadImg('title-bg', 'assets/title-bg.webp'),
    loadImg('bg-exterior', 'assets/pixel-exterior.webp'),
    loadImg('bg-terrace', 'assets/pixel-terrace.webp'),
    loadImg('bg-kitchen', 'assets/pixel-kitchen.webp'),
    loadImg('bg-port', 'assets/pixel-port.webp'),
    loadImg('bg-museum', 'assets/pixel-museum.webp'),
    loadImg('bg-liotrivi', 'assets/pixel-liotrivi.webp'),
    loadImg('bg-cave', 'assets/pixel-cave.webp'),
    loadImg('bg-church', 'assets/pixel-church.webp'),
    loadImg('bg-windmill', 'assets/pixel-windmill.webp'),
    loadImg('bg-boat', 'assets/pixel-boat.webp'),
    loadImg('bg-graveyard', 'assets/pixel-graveyard.webp'),
    // Cutscene backgrounds
    loadImg('cutscene-road', 'assets/cutscene-road.png'),
    loadImg('cutscene-descent', 'assets/cutscene-descent.png'),
    loadImg('cutscene-letter', 'assets/cutscene-letter.png'),
    loadImg('cutscene-cave', 'assets/cutscene-cave.png'),
    loadImg('cutscene-ghost', 'assets/cutscene-ghost.png'),
    loadImg('cutscene-crossing', 'assets/cutscene-crossing.png'),
    loadImg('cutscene-treasure', 'assets/cutscene-treasure.png'),
    loadImg('cutscene-epilogue', 'assets/cutscene-epilogue.png'),
  ]);

  // Character idle sprites (family + NPCs)
  const charPromises = ['ntemis','ajax','clio','ghost','athos','stathis','akis','giannis','curator'].map(id =>
    loadImg(`char-${id}`, `assets/char-${id}-final.png`).then(img => { CHAR_IMGS[id] = img; })
  );

  // Portraits (family + NPCs)
  const portPromises = [
    loadImg('port-ntemis', 'assets/portrait-ntemis.webp').then(img => { PORTRAITS['ΝΤΕΜΗΣ'] = img; }),
    loadImg('port-ajax', 'assets/portrait-ajax.webp').then(img => { PORTRAITS['ΑΙΑΣ'] = img; }),
    loadImg('port-clio', 'assets/portrait-clio.webp').then(img => { PORTRAITS['ΚΛΕΙΩ'] = img; }),
    loadImg('port-ghost', 'assets/portrait-ghost.webp').then(img => { PORTRAITS['ΦΑΝΤΑΣΜΑ'] = img; }),
    loadImg('port-athos', 'assets/portrait-athos.webp').then(img => { PORTRAITS['ΑΘΟΣ'] = img; }),
    loadImg('port-stathis', 'assets/portrait-stathis.webp').then(img => { PORTRAITS['ΣΤΑΘΗΣ'] = img; }),
    loadImg('port-akis', 'assets/portrait-akis.webp').then(img => { PORTRAITS['ΑΚΗΣ'] = img; }),
    loadImg('port-giannis', 'assets/portrait-giannis.webp').then(img => { PORTRAITS['ΓΙΑΝΝΗΣ'] = img; }),
    loadImg('port-curator', 'assets/portrait-curator.webp').then(img => { PORTRAITS['ΕΠΙΜΕΛΗΤΗΣ'] = img; }),
  ];

  await Promise.all([...charPromises, ...portPromises]);

  // Walk frames from JSON
  try {
    const resp = await fetch('assets/walk-frames-b64.json');
    const data = await resp.json();
    for (const who of ['ntemis','ajax','clio']) {
      if (data[who]) {
        for (let i = 0; i < data[who].length; i++) {
          const img = new Image();
          img.src = 'data:image/png;base64,' + data[who][i];
          WALK_FRAMES[who].push(img);
        }
      }
    }
  } catch(e) { console.warn('Walk frames load failed:', e); }
}

// ════════════════════════════════════════════════════════════
// SCENES DATA
// ════════════════════════════════════════════════════════════
const scenes = {
  exterior: {
    label: 'ΤΟ ΣΠΙΤΙ — ΓΑΛΑΞΙΔΙ', bg: 'bg-exterior',
    walkLine: [[30, 378], [200, 375], [400, 378], [610, 380]],
    charPos: {
      ntemis: { x: 290, y: 375 },
      ajax:   { x: 370, y: 378 },
      clio:   { x: 210, y: 378 },
    },
    objects: [
      { id:'door', x:115, y:100, w:70, h:120, label:'Πόρτα',
        verbs: { look:[{s:'',t:'Ξύλινη πόρτα βαμμένη μπλε. Το χρώμα του Αιγαίου.'}],
                 open:[{s:'ΝΤΕΜΗΣ',t:'Ας μπούμε μέσα.'}], walk:'kitchen', use:'kitchen' }},
      { id:'bougainvillea', x:175, y:20, w:150, h:120, label:'Μπουκαμβίλιες',
        verbs: { look:[{s:'',t:'Ροζ μπουκαμβίλιες σκαρφαλώνουν στον τοίχο. Εδώ το καλοκαίρι αρνείται να φύγει.'}],
                 pick:[{s:'ΚΛΕΙΩ',t:'Μπαμπά, μην τις κόβεις! Είναι τέλειες έτσι.'}] }},
      { id:'flowerpots', x:75, y:195, w:65, h:55, label:'Γλάστρες',
        verbs: { look:[{s:'',t:'Πήλινες γλάστρες με βασιλικό. Κάποιος τα περιποιείται ακόμα κι όταν το σπίτι μένει κλειστό.'}] }},
      { id:'barrel', x:245, y:180, w:55, h:60, label:'Βαρέλι',
        verbs: { look:[{s:'',t:'Ένα παλιό ξύλινο βαρέλι. Μυρίζει κρασί και αλμύρα.'}],
                 open:[{s:'ΑΙΑΣ',t:'Άδειο. Κρίμα!'}] }},
      { id:'boats', x:380, y:120, w:140, h:80, label:'Ψαροκάικα',
        verbs: { look:[{s:'',t:'Χρωματιστά ψαροκάικα δεμένα στο λιμάνι. Κουνιούνται αργά στο απογευματινό φως.'},{s:'ΑΙΑΣ',t:'Μπαμπά, θα πάμε βόλτα με βάρκα;'}] }},
      { id:'sea', x:350, y:60, w:230, h:60, label:'Η θάλασσα',
        verbs: { look:[{s:'',t:'Ο Κορινθιακός κόλπος λάμπει χρυσαφί στο ηλιοβασίλεμα. Μαγικό.'}] }},
    ],
    exits: [
      { side:'right', target:'terrace', label:'Βεράντα →' },
      { side:'left', target:'port', label:'← Λιμάνι' },
    ],
    entry: [
      {s:'',t:'Ο ήλιος βάφει χρυσά τα καλντερίμια. Μυρωδιά πεύκου ανακατεμένη με θαλασσινό αλάτι.'},
      {s:'ΝΤΕΜΗΣ',t:'Φτάσαμε, παιδιά. Αυτό είναι το σπίτι μας για το Σαββατοκύριακο.'},
      {s:'ΑΙΑΣ',t:'Τέλειο! Πάμε κατευθείαν στο λιμάνι;'},
      {s:'ΚΛΕΙΩ',t:'Πρώτα ας αφήσουμε τις βαλίτσες. Θέλω να δω τη βεράντα.'},
    ],
  },
  terrace: {
    label: 'Η ΒΕΡΑΝΤΑ', bg: 'bg-terrace',
    walkLine: [[30, 385], [200, 380], [400, 382], [610, 387]],
    charPos: {
      ntemis: { x: 320, y: 382 },
      ajax:   { x: 420, y: 384 },
      clio:   { x: 225, y: 381 },
    },
    objects: [
      { id:'harbor', x:140, y:120, w:280, h:100, label:'Το λιμάνι',
        verbs: { look:()=>{
          if(!state.flags.dolphins){state.flags.dolphins=1;return[
            {s:'',t:'Ο Κορινθιακός λάμπει σαν λιωμένο χρυσάφι. Ψαροκάικα κουνιούνται αργά στο λιμάνι.'},
            {s:'ΚΛΕΙΩ',t:'Μπαμπά, κοίτα! Δελφίνια!'},
            {s:'',t:'Τρία δελφίνια κόβουν βόλτες στο λιμάνι.'},
            {s:'ΑΙΑΣ',t:'Δελφίνια μέσα στο λιμάνι; Αυτό δεν είναι συνηθισμένο...'}];}
          return[{s:'',t:'Τα δελφίνια συνεχίζουν τους κύκλους τους. Σαν να φυλάνε κάτι.'}];}}},
      { id:'rooftops', x:30, y:80, w:130, h:100, label:'Σκεπές',
        verbs: { look:[{s:'',t:'Κεραμίδια, σκεπές, καμινάδες. Κάθε σπίτι κι ένας καπετάνιος κάποτε.'}] }},
      { id:'mountains', x:250, y:12, w:300, h:80, label:'Παρνασσός',
        verbs: { look:[{s:'',t:'Ο Παρνασσός στο βάθος. Οι Δελφοί κάπου εκεί πάνω.'},{s:'ΚΛΕΙΩ',t:'Οι Αμφικτίονες ξεκινούσαν από τους Δελφούς... Το Γαλαξίδι ήταν λιμάνι τους.'}] }},
      { id:'balustrade', x:90, y:240, w:370, h:40, label:'Κάγκελο',
        verbs: { look:[{s:'',t:'Πέτρινο κάγκελο με θέα ολόκληρο το Γαλαξίδι. Θα μπορούσες να κάτσεις εδώ ώρες.'}],
                 push:[{s:'ΚΛΕΙΩ',t:'Μπαμπά, μην ακουμπάς, φαίνεται παλιό!'}] }},
      { id:'flowerpot', x:10, y:220, w:65, h:60, label:'Γλάστρα',
        verbs: { look:[{s:'',t:'Γεράνια σε πήλινη γλάστρα. Τα χρώματα λάμπουν στο ηλιοβασίλεμα.'}] }},
    ],
    exits: [{ side:'left', target:'exterior', label:'← Σπίτι' }, { side:'right', target:'graveyard', label:'Νεκροταφείο →' }],
    entry: [
      {s:'',t:'Η θέα κόβει την ανάσα.'},
      {s:'ΚΛΕΙΩ',t:'Αυτό είναι το πιο όμορφο μέρος στον κόσμο.'},
      {s:'ΝΤΕΜΗΣ',t:'Καλωσορίσατε στο Γαλαξίδι.'},
    ],
  },
  kitchen: {
    label: 'Η ΚΟΥΖΙΝΑ', bg: 'bg-kitchen',
    walkLine: [[30, 378], [320, 375], [610, 378]],
    charPos: {
      ntemis: { x: 350, y: 375 },
      ajax:   { x: 450, y: 377 },
      clio:   { x: 100, y: 377 },
    },
    objects: [
      { id:'figs', x:180, y:175, w:100, h:55, label:'Σύκα',
        verbs: { look:[{s:'',t:'Φρέσκα σύκα σε πήλινο μπολ. Η μυρωδιά γεμίζει το δωμάτιο.'}],
                 pick:[{s:'ΑΙΑΣ',t:'Μπαμπά, μπορώ να φάω ένα;'},{s:'ΝΤΕΜΗΣ',t:'Φυσικά.'}],
                 use:[{s:'',t:'Τρως ένα σύκο. Γλυκό σαν μέλι.'}] }},
      { id:'satchel', x:340, y:168, w:80, h:85, label:'Δερμάτινη τσάντα',
        verbs: {
          look:()=>{if(!state.flags.note)return[{s:'',t:'Μια παλιά δερμάτινη τσάντα πάνω στην καρέκλα. Δεν είναι δική σας.'},{s:'ΚΛΕΙΩ',t:'Μπαμπά, κοίτα — υπάρχει κάτι μέσα.'}];return[{s:'',t:'Η τσάντα είναι άδεια τώρα.'}];},
          open:()=>{if(!state.flags.note){state.flags.note=1;addInv({id:'note',label:'Σημείωμα'});return[{s:'',t:'Ανοίγεις την τσάντα. Μέσα βρίσκεις ένα σημείωμα.'},{s:'ΚΛΕΙΩ',t:'Διάβασέ το!'},{s:'',t:'«Σας περιμέναμε. Ελάτε στο λιμάνι απόψε. Τραπέζι για τρεις. — Γ.»'},{s:'ΑΙΑΣ',t:'Ποιος είναι ο «Γ.»;'},{s:'ΝΤΕΜΗΣ',t:'Και πώς ξέρει ότι είμαστε τρεις;'}];}return[{s:'',t:'Η τσάντα είναι πλέον άδεια.'}];},
          pick:[{s:'ΝΤΕΜΗΣ',t:'Δεν είναι δική μας. Ας κοιτάξω μέσα πρώτα.'}] }},
      { id:'window', x:455, y:50, w:95, h:115, label:'Παράθυρο',
        verbs: { look:[{s:'',t:'Απογευματινό φως μέσα από γαλάζια πατζούρια. Σκιές χορεύουν στον τοίχο.'}],
                 open:[{s:'',t:'Ανοίγεις τα πατζούρια. Μυρωδιά θυμαριού και τζιτζίκια.'}] }},
      { id:'pots', x:150, y:35, w:240, h:65, label:'Χάλκινα σκεύη',
        verbs: { look:[{s:'',t:'Χάλκινα σκεύη κρεμασμένα στον τοίχο. Κάποτε τάιζαν οικογένειες ναυτικών.'}] }},
      { id:'fireplace', x:0, y:75, w:95, h:145, label:'Τζάκι',
        verbs: { look:[{s:'',t:'Πέτρινο τζάκι. Μέσα υπάρχουν ακόμα στάχτες από τον τελευταίο χειμώνα.'}] }},
    ],
    exits: [{ side:'left', target:'exterior', label:'← Έξω' }],
    entry: [
      {s:'',t:'Η κουζίνα μυρίζει θυμάρι και παλιό ξύλο.'},
      {s:'ΚΛΕΙΩ',t:'Κοιτάξτε — κάποιος μας άφησε σύκα!'},
      {s:'ΑΙΑΣ',t:'Και κάτι πάνω στην καρέκλα... μια τσάντα;'},
    ],
  },


  // ── SCENE 2: THE PORT ──
  port: {
    label: 'ΤΟ ΛΙΜΑΝΙ', bg: 'bg-port',
    walkLine: [[30, 378], [320, 375], [500, 378], [610, 380]],
    charPos: { ntemis: { x: 320, y: 375 }, ajax: { x: 400, y: 378 }, clio: { x: 240, y: 377 } },
    objects: [
      { id:'boats_port', x:120, y:80, w:200, h:100, label:'Ψαρόβαρκες',
        verbs: { look:[{s:'',t:'Χρωματιστά καΐκια δεμένα στα μπαλόνια. Η μπογιά ξεφλουδίζει — αλμύρα και χρόνια.'},{s:'ΑΙΑΣ',t:'Μπαμπά, μπορώ να πηδήξω σε κάποιο;'},{s:'ΝΤΕΜΗΣ',t:'Μπορείς να κοιτάξεις. Από εδώ.'}] }},
      { id:'bollards', x:380, y:250, w:80, h:60, label:'Δέστρες',
        verbs: { look:[{s:'',t:'Μεταλλικές δέστρες ψηλότερες από την Κλειώ. Φτιαγμένες για τρικάταρτα, όχι για βαρκούλες.'},{s:'ΚΛΕΙΩ',t:'Γιατί είναι τόσο μεγάλες;'},{s:'ΝΤΕΜΗΣ',t:'Γιατί κάποτε εδώ δένανε ιστιοφόρα πενήντα μέτρων.'}] }},
      { id:'nets', x:30, y:200, w:100, h:100, label:'Δίχτυα',
        verbs: { look:[{s:'',t:'Ένας ψαράς μπαλώνει τα δίχτυα του. Τα χέρια του κινούνται αυτόματα — πενήντα χρόνια πρακτική.'}],
                 talk:[{s:'ΝΤΕΜΗΣ',t:'Καλησπέρα! Πολύ ψάρι σήμερα;'},{s:'',t:'Ο ψαράς σηκώνει το βλέμμα. Τα μάτια του είναι γαλάζια σαν τον κόλπο.'},{s:'',t:'«Ψάρι λίγο. Ιστορίες πολλές. Κάτσε να σου πω.»'}] }},
      { id:'warehouses', x:450, y:60, w:150, h:140, label:'Αποθήκες',
        verbs: { look:[{s:'',t:'Πέτρινες αποθήκες με σιδερένιες πόρτες. Κάποτε γεμάτες σταφίδα και λάδι για εξαγωγή. Τώρα σιωπή.'}] }},
      { id:'seagulls', x:300, y:10, w:150, h:50, label:'Γλάροι',
        verbs: { look:[{s:'',t:'Γλάροι κράζουν πάνω από το λιμάνι. Αιώνιοι κάτοικοι.'},{s:'ΚΛΕΙΩ',t:'Αυτοί ξέρουν τα πάντα. Αν μιλούσαν...'}] }},
      { id:'cats', x:500, y:290, w:60, h:50, label:'Γάτες',
        verbs: { look:[{s:'',t:'Τρεις γάτες ξαπλωμένες στον ήλιο. Σε κοιτάνε με αδιαφορία.'},{s:'ΚΛΕΙΩ',t:'Πόσο τέλεια! Αυτή η πορτοκαλί μου αρέσει πολύ.'}] }},
      { id:'stathis', x:55, y:270, w:70, h:100, label:'Στάθης',
        verbs: { look:[{s:'',t:'Ο Στάθης με την κιθάρα του. Φίλος από τα παλιά.'}],
                 talk:[{s:'ΣΤΑΘΗΣ',t:'Ντέμη! Τι κάνεις εδώ; Πάρε μια καρέκλα!'},{s:'ΝΤΕΜΗΣ',t:'Στάθη! Πόσο καιρό!'},{s:'ΣΤΑΘΗΣ',t:'Ψάχνεις κάτι; Ρώτα τον Άθο στο Λιοτρίβι. Ξέρει τα πάντα για τις παλιές οικογένειες.'}] }},
      { id:'akis', x:125, y:272, w:60, h:98, label:'Άκης',
        verbs: { look:[{s:'',t:'Ο Άκης παίζει φλογέρα στο λιμάνι. Η μελωδία ταξιδεύει στο νερό.'}],
                 talk:[{s:'ΑΚΗΣ',t:'Ε, Ντέμη! Τα παιδιά μεγάλωσαν!'},{s:'ΚΛΕΙΩ',t:'Θείε Άκη, τι παίζεις;'},{s:'ΑΚΗΣ',t:'Ένα παλιό τραγούδι ναυτικό. Πήγαινε στο μουσείο — θα καταλάβεις.'}] }},
    ],
    exits: [{ side:'right', target:'exterior', label:'Σπίτι →' }, { side:'left', target:'museum', label:'← Μουσείο' }],
    entry: [
      {s:'',t:'Το λιμάνι του Γαλαξειδίου. Μισοφέγγαρο από πέτρα, κυμαρισμένο φως, μυρωδιά αλμύρας.'},
      {s:'ΑΙΑΣ',t:'Αυτό το λιμάνι φαίνεται τεράστιο για τόσο μικρό χωριό.'},
      {s:'ΝΤΕΜΗΣ',t:'Γιατί κάποτε δεν ήταν μικρό χωριό. Ήταν ναυτική δύναμη.'},
      {s:'ΚΛΕΙΩ',t:'Τριακόσια καράβια, μπαμπά. Το διάβασα.'},
    ],
  },

  // ── SCENE 3: THE NAUTICAL MUSEUM ──
  museum: {
    label: 'ΤΟ ΝΑΥΤΙΚΟ ΜΟΥΣΕΙΟ', bg: 'bg-museum',
    walkLine: [[30, 380], [320, 377], [610, 380]],
    charPos: { ntemis: { x: 320, y: 377 }, ajax: { x: 420, y: 380 }, clio: { x: 200, y: 379 } },
    objects: [
      { id:'model_ship', x:20, y:100, w:180, h:150, label:'Μοντέλο ιστιοφόρου',
        verbs: { look:[{s:'',t:'Ένα πανέμορφο μοντέλο τρικάταρτου μέσα σε γυάλινη βιτρίνα. Κάθε λεπτομέρεια τέλεια.'},{s:'ΚΛΕΙΩ',t:'Κοιτάξτε τα πανιά! Ένα-ένα ραμμένα.'},{s:'',t:'Η πινακίδα γράφει: «Σκούνα Χρυσούλα, 1904 — το τελευταίο ιστιοφόρο του Γαλαξειδίου.»'}] }},
      { id:'steamship', x:380, y:100, w:180, h:150, label:'Ατμόπλοιο',
        verbs: { look:[{s:'',t:'Μια γωνιά αφιερωμένη στα ατμόπλοια. Ένα σιδερένιο μοντέλο, μικρότερο, λιγότερο εντυπωσιακό.'},{s:'ΝΤΕΜΗΣ',t:'Αυτό ήταν το μέλλον. Και το Γαλαξίδι δεν το είδε.'},{s:'ΑΙΑΣ',t:'Γιατί; Ήταν χαζοί;'},{s:'ΝΤΕΜΗΣ',t:'Όχι. Ήταν οι καλύτεροι στα πανιά. Γι\u0027 αυτό ακριβώς δεν άλλαξαν.'}] }},
      { id:'portraits_mus', x:200, y:20, w:180, h:100, label:'Πορτρέτα καπεταναίων',
        verbs: { look:[{s:'',t:'Πορτρέτα σε χρυσές κορνίζες. Σοβαρά πρόσωπα, κομψά μουστάκια, μάτια που έχουν δει θάλασσα.'},{s:'ΚΛΕΙΩ',t:'Αυτός μοιάζει λίγο με τον μπαμπά.'},{s:'ΑΙΑΣ',t:'Ε, λίγο μόνο.'},{s:'ΝΤΕΜΗΣ',t:'Ευχαριστώ, νομίζω.'}] }},
      { id:'instruments', x:30, y:310, w:150, h:60, label:'Ναυτικά όργανα',
        verbs: { look:[{s:'',t:'Πυξίδες, εξάντες, χάρτες. Τα εργαλεία που οδηγούσαν τα πλοία σε κάθε γωνιά της Μεσογείου.'},{s:'ΚΛΕΙΩ',t:'Χωρίς GPS; Πώς;'},{s:'ΝΤΕΜΗΣ',t:'Αστέρια, εμπειρία, και θάρρος.'}] }},
      { id:'flags', x:100, y:5, w:400, h:40, label:'Σημαίες',
        verbs: { look:[{s:'',t:'Ναυτικές σημαίες κρέμονται από το ταβάνι. Ελληνική, γαλλική, ρωσική — τα λιμάνια που γνώριζαν.'}] }},
      { id:'map_table', x:350, y:300, w:120, h:60, label:'Χάρτης',
        verbs: { look:[{s:'',t:'Ένας παλιός χάρτης του Κορινθιακού ξαπλωμένος σε τραπέζι. Σημειώσεις με μελάνι — δρόμοι ναυσιπλοΐας.'},{s:'ΚΛΕΙΩ',t:'Μπαμπά, σημείωσε αυτό. Μπορεί να μας χρειαστεί.'}] }},
      { id:'curator_npc', x:75, y:270, w:90, h:100, label:'Επιμελητής',
        verbs: { look:[{s:'',t:'Ο επιμελητής του μουσείου. Τα μάτια του λάμπουν πίσω από τα στρογγυλά γυαλιά.'}],
                 talk:[{s:'ΕΠΙΜΕΛΗΤΗΣ',t:'Καλώς ήρθατε! Βλέπω ξέρετε να εκτιμάτε την ιστορία.'},{s:'ΝΤΕΜΗΣ',t:'Τα παιδιά μου ήθελαν να δουν τα καράβια.'},{s:'ΕΠΙΜΕΛΗΤΗΣ',t:'Τριακόσια πλοία! Η Χρυσούλα ήταν το τελευταίο. Τα ατμόπλοια τα σκότωσαν όλα.'},{s:'ΚΛΕΙΩ',t:'Γιατί δεν έφτιαξαν κι αυτοί ατμόπλοια;'},{s:'ΕΠΙΜΕΛΗΤΗΣ',t:'Ωραία ερώτηση, μικρή. Ήταν τόσο καλοί στα πανιά, που δεν φαντάζονταν κόσμο χωρίς αυτά.'}] }},
    ],
    exits: [{ side:'right', target:'port', label:'Λιμάνι →' }, { side:'left', target:'liotrivi', label:'← Λιοτρίβι' }],
    entry: [
      {s:'',t:'Το Ναυτικό Μουσείο του Γαλαξειδίου. Μυρωδιά ξύλου και παλιού χαρτιού.'},
      {s:'ΚΛΕΙΩ',t:'Πόσα μοντέλα! Θέλω να τα δω ΟΛΑ.'},
      {s:'ΑΙΑΣ',t:'Εγώ θέλω να δω αν έχει κανόνια.'},
      {s:'ΝΤΕΜΗΣ',t:'Σσσ. Μουσείο, παιδιά. Ησυχία.'},
    ],
  },

  // ── SCENE 4: LIOTRIVI BAR ──
  liotrivi: {
    label: 'ΛΙΟΤΡΙΒΙ', bg: 'bg-liotrivi',
    walkLine: [[30, 378], [320, 375], [610, 378]],
    charPos: { ntemis: { x: 320, y: 375 }, ajax: { x: 400, y: 377 }, clio: { x: 240, y: 377 } },
    objects: [
      { id:'olive_press', x:10, y:80, w:140, h:180, label:'Ελαιοτριβείο',
        verbs: { look:[{s:'',t:'Το παλιό ελαιοτριβείο — πέτρα και ξύλο. Κάποτε έβγαζε λάδι, τώρα βγάζει ιστορίες.'},{s:'ΚΛΕΙΩ',t:'Φανταστείτε πόσα χέρια το γύρισαν.'}] }},
      { id:'bar_counter', x:200, y:80, w:180, h:120, label:'Μπαρ',
        verbs: { look:[{s:'',t:'Ξύλινο μπαρ γεμάτο μπουκάλια. Τσίπουρο, ρακή, κρασιά ντόπια. Φανάρια ρίχνουν ζεστό φως.'},{s:'ΑΙΑΣ',t:'Εγώ μπορώ να πάρω λεμονάδα;'}] }},
      { id:'window_liot', x:420, y:50, w:130, h:140, label:'Παράθυρο',
        verbs: { look:[{s:'',t:'Γαλάζια πατζούρια ανοιχτά στο φεγγαρόφωτο. Το λιμάνι λάμπει ασημί.'},{s:'ΚΛΕΙΩ',t:'Μαγικό. Σαν πίνακας ζωγραφικής.'}] }},
      { id:'photos_liot', x:150, y:20, w:100, h:60, label:'Παλιές φωτογραφίες',
        verbs: { look:[{s:'',t:'Ασπρόμαυρες φωτογραφίες στον τοίχο. Ψαράδες, καπετάνιοι, γυναίκες που περίμεναν.'},{s:'ΝΤΕΜΗΣ',t:'Κάθε φωτογραφία και μια ιστορία. Κάθε πρόσωπο και μια ζωή.'}] }},
      { id:'stools', x:280, y:250, w:80, h:60, label:'Σκαμπό',
        verbs: { look:[{s:'',t:'Ξύλινα σκαμπό τριγμένα από χρόνια. Πόσες κουβέντες έχουν ακούσει.'}],
                 use:[{s:'ΝΤΕΜΗΣ',t:'Κάτσε. Ξεκουράσου. Η νύχτα είναι μακριά.'}] }},
      { id:'checkered_floor', x:100, y:300, w:400, h:80, label:'Πλακάκια',
        verbs: { look:[{s:'',t:'Πλακάκια σε σκακιέρα — κίτρινα και καφέ. Λαμπυρίζουν στο φως των φαναριών.'}] }},
      { id:'athos_npc', x:95, y:265, w:65, h:100, label:'Άθος',
        verbs: { look:[{s:'',t:'Ο Άθος. Δικηγόρος και ιδιοκτήτης του Λιοτριβιού. Τα μάτια του κρύβουν χίλια μυστικά.'}],
                 talk:[{s:'ΑΘΟΣ',t:'Λατσούδη! Περίμενα πότε θα φτάσεις.'},{s:'ΝΤΕΜΗΣ',t:'Με ξέρεις;'},{s:'ΑΘΟΣ',t:'Ξέρω τον παππού σου. Ήξερα. Και ξέρω τι ψάχνεις.'},{s:'ΑΘΟΣ',t:'Ο Βισβίκης άφησε διαθήκη. Αν θέλεις απαντήσεις, ψάξε στο σπήλαιο του Κάρκαρου.'},{s:'ΚΛΕΙΩ',t:'Σπήλαιο; Θα πάμε σε σπήλαιο;!'}] }},
    ],
    exits: [{ side:'right', target:'museum', label:'Μουσείο →' }, { side:'left', target:'church', label:'← Εκκλησία' }],
    entry: [
      {s:'',t:'Το Λιοτρίβι. Πέτρα, ξύλο, ζεστό φως. Μυρωδιά τσίπουρου και ελιάς.'},
      {s:'ΑΙΑΣ',t:'Αυτό μοιάζει σαν πειρατικό καπηλειό!'},
      {s:'ΚΛΕΙΩ',t:'Μυρίζει ωραία. Σαν τη γιαγιά.'},
      {s:'ΝΤΕΜΗΣ',t:'Ελάτε, ας δούμε ποιος είναι εδώ.'},
    ],
  },

  // ── SCENE 5: THE CAVE OF KARKAROS ──
  cave: {
    label: 'ΤΟ ΣΠΗΛΑΙΟ ΤΟΥ ΚΑΡΚΑΡΟΥ', bg: 'bg-cave',
    walkLine: [[30, 383], [310, 380], [610, 383]],
    charPos: { ntemis: { x: 310, y: 380 }, ajax: { x: 390, y: 382 }, clio: { x: 230, y: 381 } },
    objects: [
      { id:'stone_door', x:190, y:85, w:170, h:130, label:'Πέτρινη πόρτα',
        verbs: { look:[{s:'',t:'Μια τεράστια πέτρινη πόρτα με δώδεκα κυκλικές εσοχές. Σχήμα τιμονιού.'},{s:'ΚΛΕΙΩ',t:'Δώδεκα θέσεις. Σαν ρολόι.'},{s:'ΑΙΑΣ',t:'Ή σαν τιμόνι καραβιού!'},{s:'ΝΤΕΜΗΣ',t:'Κάτι πρέπει να μπει σε κάθε εσοχή. Αλλά τι;'}],
                 open:[{s:'ΝΤΕΜΗΣ',t:'Δεν κουνιέται. Χρειαζόμαστε κάτι για τις εσοχές.'}],
                 use:[{s:'ΝΤΕΜΗΣ',t:'Δεν έχουμε αρκετά ακόμα. Πρέπει να ψάξουμε περισσότερο.'}] }},
      { id:'captain_marks', x:10, y:115, w:80, h:70, label:'Σημάδια καπεταναίων',
        verbs: { look:[{s:'',t:'Χαραγμένα σύμβολα στον βράχο. Νεκροκεφαλή, ψάρι, άγκυρα, μάτι.'},{s:'ΚΛΕΙΩ',t:'Αυτά δεν είναι πειρατικά. Είναι σημάδια καπεταναίων!'},{s:'ΝΤΕΜΗΣ',t:'Σωστά. Κάθε καπετάνιος είχε το δικό του σήμα. Αυτοί οι τοίχοι θυμούνται.'}] }},
      { id:'cave_water', x:130, y:260, w:250, h:75, label:'Νερό',
        verbs: { look:[{s:'',t:'Τυρκουάζ νερό λάμπει από το φως της εισόδου. Κρυστάλλινο.'},{s:'ΑΙΑΣ',t:'Μπορώ να κολυμπήσω;'},{s:'ΝΤΕΜΗΣ',t:'Όχι τώρα, Αία. Ποιος ξέρει πόσο βαθιά είναι.'}] }},
      { id:'stalactites', x:50, y:0, w:500, h:55, label:'Σταλακτίτες',
        verbs: { look:[{s:'',t:'Σταλακτίτες κρέμονται σαν δάχτυλα γίγαντα. Χιλιάδες χρόνια σε κάθε σταγόνα.'},{s:'ΚΛΕΙΩ',t:'Ο Κάρκαρος. Λέγανε ότι η φωνή σου γυρίζει πίσω τρεις φορές.'}] }},
      { id:'barrel_cave', x:25, y:225, w:55, h:50, label:'Βαρέλι',
        verbs: { look:[{s:'',t:'Ένα σάπιο βαρέλι. Μυρίζει θάλασσα και χρόνο.'},{s:'ΑΙΑΣ',t:'Μήπως είχε ρούμι;'},{s:'ΝΤΕΜΗΣ',t:'Πιθανόν, κάποτε.'}],
                 open:[{s:'',t:'Άδειο, εκτός από αλμύρα και σκόνη.'}] }},
      { id:'cave_entrance', x:460, y:50, w:170, h:240, label:'Είσοδος σπηλαίου',
        verbs: { look:[{s:'',t:'Χρυσό φως χύνεται μέσα από τη φυσική αψίδα. Σκόνη χορεύει στις ακτίνες.'},{s:'ΑΙΑΣ',t:'Σαν εκκλησία!'},{s:'ΚΛΕΙΩ',t:'Σαν να σε καλεί μέσα.'}] }},
    ],
    exits: [{ side:'right', target:'church', label:'Έξοδος →' }],
    entry: [
      {s:'',t:'Ο Κάρκαρος. Ο θόλος υψώνεται σαν καθεδρικός. Χρυσό φως χύνεται από την είσοδο.'},
      {s:'ΚΛΕΙΩ',t:'Μπαμπά... αυτό δεν μοιάζει σπήλαιο. Μοιάζει σαν κάποιος να το έφτιαξε.'},
      {s:'ΑΙΑΣ',t:'Η πόρτα! Κοιτάξτε αυτή την τεράστια πόρτα!'},
      {s:'ΝΤΕΜΗΣ',t:'Δώδεκα εσοχές. Σαν τιμόνι πλοίου. Κάτι μας λείπει.'},
    ],
  },

  // ── SCENE 6: CHURCH OF AGIOS NIKOLAOS ──
  church: {
    label: 'ΑΓΙΟΣ ΝΙΚΟΛΑΟΣ', bg: 'bg-church',
    walkLine: [[30, 378], [300, 375], [610, 378]],
    charPos: { ntemis: { x: 300, y: 375 }, ajax: { x: 390, y: 377 }, clio: { x: 210, y: 377 } },
    objects: [
      { id:'fountain', x:200, y:180, w:130, h:140, label:'Σιντριβάνι',
        verbs: { look:[{s:'',t:'Πέτρινο σιντριβάνι στην πλατεία. Το νερό τρέχει αθόρυβα.'},{s:'ΚΛΕΙΩ',t:'Ρίχνω ένα νόμισμα;'},{s:'ΝΤΕΜΗΣ',t:'Γιατί όχι; Κάνε μια ευχή.'}] }},
      { id:'church_dome', x:250, y:10, w:160, h:120, label:'Εκκλησία',
        verbs: { look:[{s:'',t:'Ο Άγιος Νικόλαος — προστάτης των ναυτικών. Ο τρούλος λάμπει κόκκινος στον ήλιο.'},{s:'ΝΤΕΜΗΣ',t:'Κάθε καπετάνιος προσευχόταν εδώ πριν φύγει. Και η οικογένειά του μετά.'}] }},
      { id:'bougainvillea_ch', x:0, y:60, w:90, h:180, label:'Μπουκαμβίλιες',
        verbs: { look:[{s:'',t:'Φούξια μπουκαμβίλιες σκεπάζουν τον τοίχο. Χρώμα που αψηφά τον χρόνο.'}] }},
      { id:'cat_church', x:420, y:300, w:60, h:40, label:'Γάτα',
        verbs: { look:[{s:'',t:'Μια πορτοκαλί γάτα κοιμάται αράχτη στα πλακάκια.'},{s:'ΚΛΕΙΩ',t:'Την ξαναβρήκα! Αυτή είναι η ίδια από το λιμάνι.'}],
                 talk:[{s:'ΚΛΕΙΩ',t:'Γεια σου, μικρούλα. Με ακολουθείς;'},{s:'',t:'Η γάτα νιαουρίζει απαλά.'}] }},
      { id:'benches', x:50, y:270, w:120, h:50, label:'Παγκάκια',
        verbs: { look:[{s:'',t:'Πέτρινα παγκάκια στη σκιά. Γέροι κάθονταν εδώ κάθε απόγευμα, εδώ και δεκαετίες.'}] }},
      { id:'pots_church', x:480, y:180, w:80, h:100, label:'Γλάστρες',
        verbs: { look:[{s:'',t:'Γλάστρες με γεράνια και λουλούδια. Κάποιος φροντίζει αυτή την πλατεία με αγάπη.'}] }},
    ],
    exits: [{ side:'right', target:'liotrivi', label:'Λιοτρίβι →' }, { side:'left', target:'cave', label:'← Σπήλαιο' }],
    entry: [
      {s:'',t:'Η πλατεία του Αγίου Νικολάου. Ησυχία, λουλούδια, και ήχος νερού.'},
      {s:'ΚΛΕΙΩ',t:'Τι ωραία πλατεία! Και γάτα!'},
      {s:'ΑΙΑΣ',t:'Πάλι γάτα;'},
      {s:'ΝΤΕΜΗΣ',t:'Ο Άγιος Νικόλαος. Προστάτης των ναυτικών. Κατάλληλος για το Γαλαξίδι.'},
    ],
  },

  // ── SCENE 7: THE WINDMILL ──
  windmill: {
    label: 'Ο ΜΥΛΟΣ', bg: 'bg-windmill',
    walkLine: [[30, 380], [350, 377], [610, 380]],
    charPos: { ntemis: { x: 350, y: 377 }, ajax: { x: 440, y: 379 }, clio: { x: 260, y: 378 } },
    objects: [
      { id:'telescope', x:60, y:140, w:80, h:120, label:'Τηλεσκόπιο',
        verbs: { look:[{s:'',t:'Ένα παλιό ορειχάλκινο τηλεσκόπιο. Κάποιος το άφησε εδώ;'},{s:'ΚΛΕΙΩ',t:'Αφήστε με να κοιτάξω!'}],
                 use:[{s:'ΚΛΕΙΩ',t:'Βλέπω... το λιμάνι! Και κάτι στο νερό...'},{s:'ΑΙΑΣ',t:'Τι; Τι βλέπεις;'},{s:'ΚΛΕΙΩ',t:'Ένα σημάδι στην προβλήτα. Σαν αστέρι.'},{s:'ΝΤΕΜΗΣ',t:'Σημείωσέ το, Κλειώ.'}] }},
      { id:'panorama', x:0, y:20, w:640, h:100, label:'Πανόραμα',
        verbs: { look:[{s:'',t:'Η θέα κόβει την ανάσα. Ολόκληρο το Γαλαξίδι, ο κόλπος, τα βουνά. Από εδώ βλέπεις τα πάντα.'},{s:'ΑΙΑΣ',t:'Μπαμπά, βλέπω μέχρι την Ιτέα!'},{s:'ΚΛΕΙΩ',t:'Και τους Δελφούς! Εκεί πάνω!'}] }},
      { id:'ruins', x:470, y:130, w:120, h:130, label:'Ερείπια',
        verbs: { look:[{s:'',t:'Πέτρινα ερείπια — ίσως ο παλιός μύλος. Αψίδα ακόμα όρθια, αψηφώντας τον χρόνο.'}] }},
      { id:'wildflowers', x:150, y:250, w:200, h:80, label:'Αγριολούλουδα',
        verbs: { look:[{s:'',t:'Παπαρούνες, μαργαρίτες, θυμάρι. Ο λόφος μυρίζει μέλι και καλοκαίρι.'},{s:'ΚΛΕΙΩ',t:'Θέλω να ζωγραφίσω αυτά.'}] }},
      { id:'stone_path_wm', x:300, y:300, w:200, h:60, label:'Μονοπάτι',
        verbs: { look:[{s:'',t:'Πέτρινο καλντερίμι ανεβαίνει τον λόφο. Λειασμένο από πόδια αιώνων.'}] }},
      { id:'giannis_npc', x:125, y:268, w:75, h:105, label:'Γιάννης Βελανής',
        verbs: { look:[{s:'',t:'Ο Γιάννης Βελανής. Ιδιοκτήτης του παλιού μύλου. Ήσυχος, βλέπει τα πάντα από ψηλά.'}],
                 talk:[{s:'ΓΙΑΝΝΗΣ',t:'...'},{s:'ΝΤΕΜΗΣ',t:'Γεια σου. Ψάχνουμε το σπήλαιο του Κάρκαρου.'},{s:'ΓΙΑΝΝΗΣ',t:'Το ξέρω. Σε βλέπω από εδώ πάνω.'},{s:'ΓΙΑΝΝΗΣ',t:'Πάρε αυτό. Θα το χρειαστείς.'},{s:'',t:'Ο Γιάννης σου δίνει ένα φανάρι.'}] }},
    ],
    exits: [{ side:'right', target:'graveyard', label:'Νεκροταφείο →' }, { side:'left', target:'church', label:'← Εκκλησία' }],
    entry: [
      {s:'',t:'Η κορυφή του λόφου. Αέρας, φως, και θέα που δεν τελειώνει.'},
      {s:'ΑΙΑΣ',t:'ΤΕΛΕΙΟ! Βλέπω τα πάντα από εδώ!'},
      {s:'ΚΛΕΙΩ',t:'Μπαμπά, κοίτα — ένα τηλεσκόπιο!'},
      {s:'ΝΤΕΜΗΣ',t:'Ένα σημείο παρατήρησης. Κάποιος παρακολουθούσε τα πλοία από εδώ.'},
    ],
  },

  // ── SCENE 8: THE BOAT (ELPIDA) ──
  boat: {
    label: 'ΤΟ ΚΑΡΑΒΙ — ΕΛΠΙΔΑ', bg: 'bg-boat',
    walkLine: [[30, 378], [350, 375], [610, 378]],
    charPos: { ntemis: { x: 350, y: 375 }, ajax: { x: 430, y: 377 }, clio: { x: 270, y: 377 } },
    objects: [
      { id:'nameplate', x:50, y:310, w:120, h:40, label:'ΕΛΠΙΔΑ',
        verbs: { look:[{s:'',t:'«ΕΛΠΙΔΑ» — χρυσά γράμματα σε ξεφλουδισμένο μπλε ξύλο.'},{s:'ΝΤΕΜΗΣ',t:'Ελπίδα. Πάντα υπάρχει ελπίδα.'}] }},
      { id:'chapel', x:30, y:60, w:150, h:150, label:'Παρεκκλήσι',
        verbs: { look:[{s:'',t:'Ένα μικρό λευκό παρεκκλήσι πάνω στον βράχο. Ελληνική σημαία κυματίζει.'},{s:'ΚΛΕΙΩ',t:'Ποιος πάει εκεί πάνω για λειτουργία;'},{s:'ΝΤΕΜΗΣ',t:'Οι ψαράδες. Πριν και μετά το ταξίδι.'}] }},
      { id:'sunset_sea', x:200, y:20, w:400, h:120, label:'Ηλιοβασίλεμα',
        verbs: { look:[{s:'',t:'Ο ήλιος βυθίζεται στον Κορινθιακό. Χρυσό, πορτοκαλί, ροζ. Τα βουνά γίνονται σκιές.'},{s:'',t:'Κανείς δεν μιλάει. Δεν χρειάζεται.'}] }},
      { id:'rope', x:350, y:250, w:80, h:60, label:'Σχοινιά',
        verbs: { look:[{s:'',t:'Σχοινιά τυλιγμένα στο κατάστρωμα. Μυρίζουν θάλασσα και πεύκο.'}],
                 use:[{s:'ΑΙΑΣ',t:'Ξέρω κόμπους! Ο παππούς μου έμαθε.'},{s:'ΝΤΕΜΗΣ',t:'Δείξε μας.'}] }},
      { id:'lifebuoy', x:460, y:290, w:60, h:60, label:'Σωσίβιο',
        verbs: { look:[{s:'',t:'Πορτοκαλί σωσίβιο. Λευκά γράμματα: ΕΛΠΙΔΑ — ΓΑΛΑΞΙΔΙ.'}] }},
      { id:'galaxidi_view', x:400, y:80, w:200, h:100, label:'Γαλαξίδι στο βάθος',
        verbs: { look:[{s:'',t:'Το Γαλαξίδι λάμπει στον ήλιο του δειλινού. Σπίτια, εκκλησίες, το λιμάνι — σαν μακέτα.'},{s:'ΚΛΕΙΩ',t:'Από εδώ φαίνεται σαν παραμύθι.'}] }},
    ],
    exits: [{ side:'left', target:'port', label:'← Λιμάνι' }],
    entry: [
      {s:'',t:'Η Ελπίδα πλέει αργά στον Κορινθιακό. Ο κόσμος σταμάτησε.'},
      {s:'ΚΛΕΙΩ',t:'Αυτό... αυτό είναι τέλειο.'},
      {s:'ΑΙΑΣ',t:'Μπαμπά, μπορούμε να μείνουμε για πάντα εδώ;'},
      {s:'ΝΤΕΜΗΣ',t:'Για λίγο ακόμα. Κοιτάξτε τον ήλιο.'},
    ],
  },

  // ── SCENE 9: THE GRAVEYARD ──
  graveyard: {
    label: 'ΤΟ ΝΕΚΡΟΤΑΦΕΙΟ', bg: 'bg-graveyard',
    walkLine: [[30, 380], [300, 377], [610, 380]],
    charPos: { ntemis: { x: 250, y: 377 }, ajax: { x: 340, y: 379 }, clio: { x: 160, y: 378 } },
    objects: [
      { id:'visvikis_grave', x:390, y:230, w:150, h:90, label:'Τάφος Βισβίκη',
        verbs: {
          look:[{s:'',t:'Μαρμάρινη πλάκα, πιο μεγαλοπρεπής από τις άλλες. Χαραγμένο: «Πλοίαρχος Λ. Βισβίκης».'},{s:'ΚΛΕΙΩ',t:'Κοίτα κάτω — «Η θάλασσα θυμάται».'},{s:'ΑΙΑΣ',t:'Αυτός είναι ο καπετάνιος από το γράμμα!'}],
          use: () => {
            if (state.flags.ghost_summoned) return [{s:'',t:'Η πέτρα ήδη τοποθετήθηκε. Η πλάκα λάμπει αχνά.'}];
            if (!state.inv.find(i => i.id === 'green_stone')) return [{s:'ΝΤΕΜΗΣ',t:'Λείπει κάτι. Η εσοχή στην πλάκα... σαν να περιμένει κάτι.'}];
            removeInv('green_stone');
            state.flags.ghost_summoned = true;
            showDlg([{s:'',t:'Ο Ντέμης τοποθετεί την πράσινη πέτρα τζέιντ στην εσοχή της πλάκας...'}], () => startGhostSequence());
            return [];
          },
        }},
      { id:'headstones', x:50, y:210, w:150, h:120, label:'Ταφόπλακες',
        verbs: { look:[{s:'',t:'Μαρμάρινοι σταυροί και πλάκες. Χαραγμένα πλοία στις πέτρες. Ονόματα καπεταναίων: Τσώνης, Ρήγας, Μαμάς.'},{s:'ΚΛΕΙΩ',t:'Κάθε πέτρα και ένα ταξίδι.'},{s:'ΝΤΕΜΗΣ',t:'Κάθε πέτρα και μια οικογένεια που περίμενε.'}] }},
      { id:'cypress', x:0, y:20, w:70, h:320, label:'Κυπαρίσσια',
        verbs: { look:[{s:'',t:'Κυπαρίσσια ψηλά σαν κατάρτια. Φρουροί αιώνιοι στο φεγγαρόφωτο.'}] }},
      { id:'angel_statue', x:560, y:170, w:70, h:150, label:'Άγγελος',
        verbs: { look:[{s:'',t:'Μαρμάρινος άγγελος με σκυμμένο κεφάλι. Προσεύχεται πάνω από τον τάφο του Βισβίκη.'},{s:'ΚΛΕΙΩ',t:'Σαν να τον φυλάει ακόμα.'}] }},
      { id:'poppies_gr', x:200, y:300, w:180, h:60, label:'Παπαρούνες',
        verbs: { look:[{s:'',t:'Κόκκινες παπαρούνες ανάμεσα στους τάφους, ζωντανές ακόμα και στο σκοτάδι.'},{s:'ΚΛΕΙΩ',t:'Μπαμπά, δεν είναι τρομακτικό. Είναι... ωραίο.'}] }},
      { id:'sea_view_gr', x:220, y:40, w:220, h:130, label:'Θέα στη θάλασσα',
        verbs: { look:[{s:'',t:'Το φεγγάρι ρίχνει ασημένιο δρόμο στη θάλασσα. Τα φώτα του Γαλαξειδίου αντανακλούν στο νερό.'},{s:'ΑΙΑΣ',t:'Τους έβαλαν εδώ επίτηδες. Να βλέπουν τη θάλασσα για πάντα.'}] }},
      { id:'moon', x:170, y:20, w:100, h:100, label:'Φεγγάρι',
        verbs: { look:[{s:'',t:'Ολόγιομο φεγγάρι πάνω από τον Κορινθιακό. Φωτίζει τους τάφους σαν ασημένιος φανός.'},{s:'ΚΛΕΙΩ',t:'Σαν να ξέρει ότι ήρθαμε.'}] }},
      { id:'candles', x:350, y:290, w:80, h:40, label:'Κεριά',
        verbs: { look:[{s:'',t:'Αναμμένα κεριά μπροστά στον τάφο. Κάποιος τα φροντίζει ακόμα.'},{s:'ΝΤΕΜΗΣ',t:'120 χρόνια και κάποιος ανάβει ακόμα κεριά. Αυτό είναι αφοσίωση.'}] }},
      { id:'path_stones_gr', x:150, y:310, w:200, h:50, label:'Πέτρινο μονοπάτι',
        verbs: { look:[{s:'',t:'Πλακόστρωτο μονοπάτι ανάμεσα στους τάφους. Λειασμένο από χιλιάδες επισκέψεις.'}] }},
      { id:'ghost_npc', x:430, y:220, w:65, h:120, label: 'Σκιά',
        verbs: {
          look: () => {
            if (!state.flags.ghost_summoned) return [{s:'',t:'Σκιές τρεμοπαίζουν ανάμεσα στα κυπαρίσσια. Σαν να κινείται κάτι...'},{s:'ΚΛΕΙΩ',t:'Μπαμπά... νιώθω κάτι εδώ.'}];
            return [{s:'',t:'Μια αχνή, ψηλή σιλουέτα πάνω από τον τάφο. Τρεμοπαίζει σαν φως σε νερό.'},{s:'ΚΛΕΙΩ',t:'Μπαμπά... βλέπω κάτι εκεί.'},{s:'ΑΙΑΣ',t:'Φάντασμα; Σοβαρά τώρα;'}];
          },
          talk: () => {
            if (!state.flags.ghost_summoned) return [{s:'',t:'Δεν υπάρχει κανείς εδώ... ακόμα.'}];
            return [{s:'ΦΑΝΤΑΣΜΑ',t:'...'},{s:'',t:'Το φάντασμα δεν μιλάει. Δείχνει προς την εκκλησία.'},{s:'ΚΛΕΙΩ',t:'Θέλει να πάμε στον Άγιο Νικόλαο!'},{s:'ΝΤΕΜΗΣ',t:'Μόλις μας έδωσε οδηγίες ένα φάντασμα.'}];
          },
        }},
    ],
    exits: [{ side:'left', target:'terrace', label:'← Βεράντα' }],
    entry: [
      {s:'',t:'Το παλιό νεκροταφείο. Το φεγγάρι φωτίζει τους τάφους, μυρωδιά θυμαριού, ησυχία.'},
      {s:'ΚΛΕΙΩ',t:'Μπαμπά... δεν μου αρέσουν τα νεκροταφεία τη νύχτα.'},
      {s:'ΝΤΕΜΗΣ',t:'Αυτό δεν είναι τρομακτικό. Είναι γεμάτο ιστορίες.'},
      {s:'ΑΙΑΣ',t:'Κοίτα — βλέπεις τη θάλασσα από κάθε τάφο. Αυτό ήθελαν.'},
    ],
  },

};

// ════════════════════════════════════════════════════════════
// INTRO PAGES
// ════════════════════════════════════════════════════════════
const introPages = [
  'Γαλαξίδι.\nΤέλη Σεπτεμβρίου, 2026.',
  'Ένα μικρό λιμάνι\nστον Κορινθιακό κόλπο.\n\nΕκεί που κάποτε ξεκινούσαν\nτα πιο τολμηρά καράβια\nτης Ελλάδας.',
  'Ο Ντέμης έφτασε\nμε τα δυο του παιδιά\nγια ένα ήσυχο\nΣαββατοκύριακο.\n\nΤουλάχιστον,\nαυτό νόμιζε.',
];

// ════════════════════════════════════════════════════════════
// CUTSCENE ENGINE
// ════════════════════════════════════════════════════════════

const cutscenes = {
  arrival: {
    frames: [
      {
        duration: 7,
        draw: drawArrivalRoad,
        dialogue: [
          { s: 'ΑΙΑΣ', t: 'Πόσο ακόμα, μπαμπά;', at: 1.2 },
          { s: 'ΝΤΕΜΗΣ', t: 'Λίγο ακόμα. Σχεδόν φτάσαμε.', at: 3.0 },
        ],
      },
      {
        duration: 6,
        draw: drawArrivalDescent,
        dialogue: [
          { s: 'ΚΛΕΙΩ', t: 'Βλέπω τη θάλασσα! Κοίτα, καράβια!', at: 0.8 },
          { s: 'ΑΙΑΣ', t: 'Θα κολυμπήσουμε;', at: 2.8 },
          { s: 'ΝΤΕΜΗΣ', t: 'Πρώτα θα βρούμε το σπίτι του παππού.', at: 4.2 },
        ],
      },
      {
        duration: 5,
        draw: drawArrivalHarbor,
        dialogue: [
          { s: 'ΝΤΕΜΗΣ', t: 'Φτάσαμε. Γαλαξίδι.', at: 1.5 },
          { s: 'ΚΛΕΙΩ', t: 'Μυρίζει αλάτι και πεύκο!', at: 3.2 },
        ],
      },
    ],
    onComplete: () => {
      document.getElementById('ui-panel').classList.add('on');
      document.getElementById('action-line').classList.add('on');
      state.phase = 'playing';
      // Crossfade title music out, scene music in
      currentMusicSrc = sceneMusic['exterior'];
      bgm.src = currentMusicSrc;
      bgm.volume = 0;
      bgm.play().catch(() => {});
      const fadeDur = 2000;
      const fadeStart = performance.now();
      const fadeStep = () => {
        const t = Math.min(1, (performance.now() - fadeStart) / fadeDur);
        const ease = t < 0.5 ? 4*t*t*t : 1-Math.pow(-2*t+2,3)/2;
        titleMusic.volume = Math.max(0, 0.4 * (1 - ease));
        bgm.volume = 0.25 * ease;
        if (t < 1) {
          requestAnimationFrame(fadeStep);
        } else {
          titleMusic.pause();
          titleMusic.volume = 0.7;
        }
      };
      requestAnimationFrame(fadeStep);
      startScene('exterior');
    },
  },

  // ── THE LETTER — Quest hook (triggered after finding the letter in Scene 2)
  letter: {
    frames: [
      {
        duration: 7,
        draw: drawLetterClose,
        dialogue: [
          { s: 'ΝΤΕΜΗΣ', t: '«Βρες το πράσινο πέτρωμα...»', at: 1.5 },
          { s: 'ΑΙΑΣ', t: 'Τι πράσινο πέτρωμα;', at: 3.5 },
          { s: 'ΝΤΕΜΗΣ', t: 'Ο Καπετάν Βισβίκης. Ο προπάππους μου.', at: 5.0 },
        ],
      },
      {
        duration: 6,
        draw: drawLetterRoom,
        dialogue: [
          { s: 'ΚΛΕΙΩ', t: 'Μπαμπά, αυτός μας ζητάει να βρούμε κάτι!', at: 1.0 },
          { s: 'ΝΤΕΜΗΣ', t: 'Μας ζητάει να βρούμε την αλήθεια.', at: 3.2 },
        ],
      },
    ],
    onComplete: () => {
      state.phase = 'playing';
    },
  },

  // ── THE CAVE — Entering Karkaros (triggered at cave entrance)
  cave_enter: {
    frames: [
      {
        duration: 8,
        draw: drawCaveEntrance,
        dialogue: [
          { s: 'ΑΙΑΣ', t: 'Σκοτεινά... Μπαμπά, κράτα ψηλά το φανάρι!', at: 1.0 },
          { s: 'ΚΛΕΙΩ', t: 'Κοίτα στον τοίχο! Ονόματα πλοίων!', at: 3.2 },
          { s: 'ΝΤΕΜΗΣ', t: 'Οι καπεταναίοι σημάδευαν το πέρασμά τους εδώ.', at: 5.5 },
        ],
      },
    ],
    onComplete: () => {
      state.phase = 'playing';
    },
  },

  // ── THE GHOST — Captain Visvikis appears (triggered after jade placement)
  ghost: {
    frames: [
      {
        duration: 8,
        draw: drawGhostAppear,
        dialogue: [
          { s: 'ΚΛΕΙΩ', t: 'Μπαμπά... κάποιος είναι εκεί.', at: 1.5 },
          { s: 'ΝΤΕΜΗΣ', t: 'Καπετάν Βισβίκη...', at: 3.5 },
          { s: 'ΑΙΑΣ', t: 'Μας κοιτάει. Δεν φοβάμαι.', at: 5.5 },
        ],
      },
      {
        duration: 6,
        draw: drawGhostFade,
        dialogue: [
          { s: 'ΚΛΕΙΩ', t: 'Γεια σου, καπετάνιε!', at: 1.0 },
          { s: 'ΝΤΕΜΗΣ', t: 'Δείχνει προς την εκκλησία... Πάμε.', at: 3.5 },
        ],
      },
    ],
    onComplete: () => {
      state.phase = 'playing';
    },
  },

  // ── THE CROSSING — Dawn on the Ελπίδα (triggered when boarding the boat)
  crossing: {
    frames: [
      {
        duration: 8,
        draw: drawCrossingWide,
        dialogue: [
          { s: 'ΧΡΥΣΟΣΤΟΜΟΣ', t: 'Δεν πίστευα ότι θα ζούσα να το δω.', at: 1.5 },
          { s: 'ΑΙΑΣ', t: 'Αυτό είναι το πλοίο του Βισβίκη;', at: 4.0 },
          { s: 'ΧΡΥΣΟΣΤΟΜΟΣ', t: 'Η Ελπίδα. Το τελευταίο του ταξίδι.', at: 5.5 },
        ],
      },
      {
        duration: 7,
        draw: drawCrossingClose,
        dialogue: [
          { s: 'ΚΛΕΙΩ', t: 'Βλέπω το νησάκι!', at: 1.5 },
          { s: 'ΧΡΥΣΟΣΤΟΜΟΣ', t: 'Η θάλασσα αλλάζει κι εσύ αλλάζεις μαζί της.', at: 3.5 },
          { s: 'ΝΤΕΜΗΣ', t: 'Αλλιώς πνίγεσαι.', at: 5.8 },
        ],
      },
    ],
    onComplete: () => {
      state.phase = 'playing';
    },
  },

  // ── THE TREASURE — The chest opens (triggered when digging on the island)
  treasure: {
    frames: [
      {
        duration: 7,
        draw: drawTreasureReveal,
        dialogue: [
          { s: 'ΑΙΑΣ', t: 'Χρυσάφι... Κοίτα, μπαμπά!', at: 1.5 },
          { s: 'ΚΛΕΙΩ', t: 'Και ένα κολιέ. Πράσινο σαν το πέτρωμα!', at: 3.5 },
          { s: 'ΝΤΕΜΗΣ', t: 'Το βιβλίο... Η αλληλασφάλεια. 104 υπογραφές.', at: 5.2 },
        ],
      },
      {
        duration: 8,
        draw: drawTreasureFamily,
        dialogue: [
          { s: 'ΝΤΕΜΗΣ', t: '«Κράτα την αλληλεγγύη. Άλλαξε το πλοίο.»', at: 1.5 },
          { s: 'ΑΙΑΣ', t: 'Τι εννοεί "άλλαξε το πλοίο";', at: 4.0 },
          { s: 'ΝΤΕΜΗΣ', t: 'Ότι δεν αρκεί να είσαι ο καλύτερος. Πρέπει να αλλάζεις.', at: 5.8 },
        ],
      },
    ],
    onComplete: () => {
      state.phase = 'playing';
    },
  },

  // ── EPILOGUE — The new αλληλασφάλεια (triggered at the end)
  epilogue: {
    frames: [
      {
        duration: 8,
        draw: drawEpilogueHarbor,
        dialogue: [
          { s: 'ΝΤΕΜΗΣ', t: 'Ο Βισβίκης δεν μας άφησε χρυσάφι.', at: 1.5 },
          { s: 'ΝΤΕΜΗΣ', t: 'Μας άφησε μια ιδέα. Την αλληλεγγύη.', at: 4.0 },
        ],
      },
      {
        duration: 8,
        draw: drawEpilogueClose,
        dialogue: [
          { s: 'ΑΚΗΣ', t: 'Γυρνάω την κάμερα. Αυτό πρέπει να το δει ο κόσμος.', at: 1.0 },
          { s: 'ΚΛΕΙΩ', t: 'Μπαμπά... η θάλασσα θυμάται;', at: 4.0 },
          { s: 'ΝΤΕΜΗΣ', t: 'Η θάλασσα θυμάται. Κι εμείς τώρα, επίσης.', at: 5.8 },
        ],
      },
    ],
    onComplete: () => {
      state.phase = 'playing';
      // Game complete — could show credits
    },
  },
};

function startCutscene(id) {
  const cs = cutscenes[id];
  if (!cs) { state.phase = 'playing'; startScene('exterior'); return; }
  state.cutscene.active = true;
  state.cutscene.id = id;
  state.cutscene.frameIdx = 0;
  state.cutscene.frameTime = 0;
  state.cutscene.totalTime = 0;
  state.cutscene.fadeAlpha = 1;
  state.cutscene.transitioning = false;
  state.cutscene.dlgText = '';
  state.cutscene.dlgDisplayed = '';
  state.cutscene.dlgSpeaker = '';
  state.cutscene.dlgCharIdx = 0;
  state.cutscene.dlgTimer = 0;
  state.cutscene.dlgTriggered = new Set();
  state.phase = 'cutscene';
  document.getElementById('ui-panel').classList.remove('on');
  document.getElementById('action-line').classList.remove('on');
}

function updateCutscene(dt) {
  if (!state.cutscene.active) return;
  const cs = cutscenes[state.cutscene.id];
  if (!cs) return;

  // Handle fade transitions between frames
  if (state.cutscene.transitioning) {
    state.cutscene.fadeAlpha = Math.min(1, state.cutscene.fadeAlpha + dt * 2.0);
    if (state.cutscene.fadeAlpha >= 1) {
      if (state.cutscene.frameIdx >= cs.frames.length - 1) {
        state.cutscene.active = false;
        cs.onComplete();
        return;
      }
      state.cutscene.frameIdx++;
      state.cutscene.frameTime = 0;
      state.cutscene.dlgText = '';
      state.cutscene.dlgDisplayed = '';
      state.cutscene.dlgSpeaker = '';
      state.cutscene.transitioning = false;
    }
    return;
  }

  const frame = cs.frames[state.cutscene.frameIdx];
  if (!frame) return;

  state.cutscene.frameTime += dt;
  state.cutscene.totalTime += dt;

  // Fade in at start of each frame
  if (state.cutscene.fadeAlpha > 0) {
    state.cutscene.fadeAlpha = Math.max(0, state.cutscene.fadeAlpha - dt * 1.5);
  }

  // Trigger dialogue at timestamps
  if (frame.dialogue) {
    for (let i = 0; i < frame.dialogue.length; i++) {
      const key = `${state.cutscene.frameIdx}-${i}`;
      if (!state.cutscene.dlgTriggered.has(key) && state.cutscene.frameTime >= frame.dialogue[i].at) {
        state.cutscene.dlgTriggered.add(key);
        state.cutscene.dlgSpeaker = frame.dialogue[i].s;
        state.cutscene.dlgText = frame.dialogue[i].t;
        state.cutscene.dlgDisplayed = '';
        state.cutscene.dlgCharIdx = 0;
        state.cutscene.dlgTimer = 0;
      }
    }
  }

  // Typewriter
  if (state.cutscene.dlgCharIdx < state.cutscene.dlgText.length) {
    state.cutscene.dlgTimer += dt;
    while (state.cutscene.dlgTimer >= 0.03 && state.cutscene.dlgCharIdx < state.cutscene.dlgText.length) {
      state.cutscene.dlgDisplayed += state.cutscene.dlgText[state.cutscene.dlgCharIdx];
      state.cutscene.dlgCharIdx++;
      state.cutscene.dlgTimer -= 0.03;
    }
  }

  // Auto-advance when frame duration reached
  if (state.cutscene.frameTime >= frame.duration) {
    advanceCutsceneFrame();
  }
}

function advanceCutsceneFrame() {
  if (state.cutscene.transitioning) return;
  state.cutscene.transitioning = true;
}

function skipCutscene() {
  if (!state.cutscene.active) return;
  const cs = cutscenes[state.cutscene.id];
  state.cutscene.active = false;
  state.cutscene.fadeAlpha = 0;
  cs.onComplete();
}

function renderCutscene() {
  if (!state.cutscene.active) return;
  const cs = cutscenes[state.cutscene.id];
  if (!cs) return;
  const frame = cs.frames[state.cutscene.frameIdx];
  if (!frame) return;

  const t = state.cutscene.frameTime;
  const p = Math.min(1, t / frame.duration);

  ctx.fillStyle = '#0a0812';
  ctx.fillRect(0, 0, GW, GH);

  // Draw scene content
  ctx.save();
  frame.draw(t, p, state.tick);
  ctx.restore();

  // Cinematic vignette
  ctx.save();
  const vig = ctx.createRadialGradient(GW / 2, GH / 2, GW * 0.28, GW / 2, GH / 2, GW * 0.72);
  vig.addColorStop(0, 'rgba(0,0,0,0)');
  vig.addColorStop(1, 'rgba(0,0,0,0.35)');
  ctx.fillStyle = vig;
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();

  // Letterbox bars
  const barH = 38;
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, GW, barH);
  ctx.fillRect(0, GH - barH, GW, barH);

  // Film grain
  ctx.save();
  ctx.globalAlpha = 0.02;
  for (let i = 0; i < 40; i++) {
    ctx.fillStyle = Math.random() > 0.5 ? '#fff' : '#000';
    ctx.fillRect(Math.random() * GW | 0, Math.random() * GH | 0, 1, 1);
  }
  ctx.restore();

  // Dialogue subtitles
  if (state.cutscene.dlgDisplayed) {
    const dlgY = GH - barH;
    ctx.save();
    ctx.globalAlpha = 0.6;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, dlgY - 42, GW, 42);
    ctx.globalAlpha = 1;
    if (state.cutscene.dlgSpeaker) {
      ctx.font = '6px "Press Start 2P", monospace';
      ctx.fillStyle = '#D4A03C';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.shadowColor = '#000';
      ctx.shadowBlur = 3;
      ctx.fillText(state.cutscene.dlgSpeaker, GW / 2, dlgY - 26);
    }
    ctx.font = '8px "Press Start 2P", monospace';
    ctx.fillStyle = '#e8dcc8';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.shadowColor = '#000';
    ctx.shadowBlur = 4;
    ctx.fillText(state.cutscene.dlgDisplayed, GW / 2, dlgY - 6);
    ctx.restore();
  }

  // Skip hint
  ctx.save();
  ctx.globalAlpha = 0.25;
  ctx.font = '5px "Press Start 2P", monospace';
  ctx.fillStyle = '#888';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'bottom';
  ctx.fillText('ESC: Παράλειψη', GW - 8, GH - 4);
  ctx.restore();

  // Fade overlay
  if (state.cutscene.fadeAlpha > 0) {
    ctx.save();
    ctx.globalAlpha = state.cutscene.fadeAlpha;
    ctx.fillStyle = '#0a0812';
    ctx.fillRect(0, 0, GW, GH);
    ctx.restore();
  }
}

// ═══════════════════════════════════════════════════════════
// CUTSCENE DRAWING HELPERS
// ═══════════════════════════════════════════════════════════

function drawPixelCar(x, y, scale, dir) {
  ctx.save();
  ctx.translate(x, y);
  ctx.scale(scale * dir, scale);

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.beginPath();
  ctx.ellipse(0, 6, 26, 4, 0, 0, Math.PI * 2);
  ctx.fill();

  // Lower body (dark blue Peugeot hatchback)
  ctx.fillStyle = '#2a3a5a';
  ctx.fillRect(-28, -8, 56, 14);
  // Cabin
  ctx.fillStyle = '#2e3e62';
  ctx.fillRect(-18, -20, 36, 14);
  // Roof
  ctx.fillStyle = '#2a3a5a';
  ctx.fillRect(-14, -22, 28, 4);

  // Window frame
  ctx.fillStyle = '#1e2e4a';
  ctx.fillRect(-17, -19, 34, 12);
  // Glass
  ctx.fillStyle = '#7aa8c8';
  ctx.fillRect(-15, -18, 12, 10); // rear
  ctx.fillRect(-1, -18, 14, 10);  // front
  ctx.fillStyle = '#8ab8d8';
  ctx.fillRect(13, -16, 3, 7);    // windshield angle

  // Character silhouettes
  ctx.fillStyle = '#1a2838';
  ctx.fillRect(4, -17, 6, 5);   // driver (Ntemis)
  ctx.fillRect(2, -12, 9, 3);
  ctx.fillRect(-13, -17, 5, 5); // Ajax
  ctx.fillRect(-14, -12, 7, 3);
  ctx.fillRect(-6, -17, 4, 4);  // Clio
  ctx.fillRect(-7, -13, 6, 2);

  // Headlights
  ctx.fillStyle = '#FFE8A0';
  ctx.fillRect(27, -5, 2, 3);
  ctx.fillRect(27, -2, 2, 2);
  // Taillights
  ctx.fillStyle = '#cc2222';
  ctx.fillRect(-29, -5, 2, 3);
  // Bumpers
  ctx.fillStyle = '#3a3a3a';
  ctx.fillRect(-29, -2, 2, 4);
  ctx.fillRect(27, -2, 2, 4);

  // Wheels
  ctx.fillStyle = '#111';
  ctx.beginPath(); ctx.arc(-15, 5, 5.5, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(17, 5, 5.5, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#555';
  ctx.beginPath(); ctx.arc(-15, 5, 2.5, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(17, 5, 2.5, 0, Math.PI * 2); ctx.fill();

  ctx.restore();
}

function drawCutsceneMountains(scrollOffset, baseY, amplitudes, color) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(-5, GH);
  for (let x = -5; x <= GW + 5; x += 2) {
    const sx = x + scrollOffset;
    const h = Math.abs(Math.sin(sx * 0.008) * amplitudes[0])
            + Math.abs(Math.sin(sx * 0.02 + 1.5) * amplitudes[1])
            + Math.abs(Math.sin(sx * 0.004 + 3) * amplitudes[2]);
    ctx.lineTo(x, baseY - h);
  }
  ctx.lineTo(GW + 5, GH);
  ctx.closePath();
  ctx.fill();
}

function drawOliveTree(x, y, scale) {
  const s = scale || 1;
  ctx.save();
  ctx.translate(x, y);
  ctx.scale(s, s);
  ctx.fillStyle = '#5a4428';
  ctx.fillRect(-2, -18, 4, 20);
  ctx.fillStyle = '#4a6a30';
  ctx.beginPath(); ctx.arc(0, -22, 10, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#5a7a38';
  ctx.beginPath(); ctx.arc(-5, -18, 7, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(6, -20, 8, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#6a8a42';
  ctx.beginPath(); ctx.arc(2, -25, 6, 0, Math.PI * 2); ctx.fill();
  ctx.restore();
}

// ═══════════════════════════════════════════════════════════
// CUTSCENE: THE ARRIVAL — Ken Burns Image Frames
// ═══════════════════════════════════════════════════════════

// Render an image with Ken Burns (pan + zoom) to fill the canvas
function drawKenBurns(imgKey, zoom, panX, panY) {
  const img = images[imgKey];
  if (!img) { ctx.fillStyle = '#0a0812'; ctx.fillRect(0, 0, GW, GH); return; }
  ctx.save();
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
  const baseScale = Math.max(GW / img.naturalWidth, GH / img.naturalHeight);
  const scale = baseScale * zoom;
  const dw = img.naturalWidth * scale;
  const dh = img.naturalHeight * scale;
  const dx = (GW - dw) / 2 + panX;
  const dy = (GH - dh) / 2 + panY;
  ctx.drawImage(img, dx, dy, dw, dh);
  ctx.imageSmoothingEnabled = false;
  ctx.restore();
}

function drawArrivalRoad(t, p, tick) {
  // Slow zoom out + slight leftward drift following the car
  drawKenBurns('cutscene-road', 1.18 - p * 0.12, -p * 15, -20 + p * 15);
  // Warm golden light pulse
  ctx.save();
  ctx.globalAlpha = 0.03 + Math.sin(tick * 0.02) * 0.01;
  ctx.fillStyle = '#FFD880';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

function drawArrivalDescent(t, p, tick) {
  // Pan down toward the town as we descend
  drawKenBurns('cutscene-descent', 1.15 - p * 0.08, p * 10, -30 + p * 45);
  // Location label fades in
  if (p > 0.3) {
    ctx.save();
    ctx.globalAlpha = Math.min(1, (p - 0.3) / 0.2) * 0.8;
    ctx.font = '10px "Press Start 2P", monospace';
    ctx.fillStyle = '#FFE8A0';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = '#000';
    ctx.shadowBlur = 8;
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;
    ctx.fillText('ΓΑΛΑΞΙΔΙ', GW / 2, 60);
    ctx.restore();
  }
}

function drawArrivalHarbor(t, p, tick) {
  // Existing exterior bg with gentle zoom in — visual continuity with gameplay
  drawKenBurns('bg-exterior', 1.08 + p * 0.06, 0, p * -10);
  // Warm overlay
  ctx.save();
  ctx.globalAlpha = 0.04;
  ctx.fillStyle = '#D4A03C';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

// ═══════════════════════════════════════════════════════════
// CUTSCENE: THE LETTER — Quest begins
// ═══════════════════════════════════════════════════════════

function drawLetterClose(t, p, tick) {
  // Slow zoom into the letter, candlelight flicker
  drawKenBurns('cutscene-letter', 1.05 + p * 0.15, 0, p * -20);
  ctx.save();
  ctx.globalAlpha = 0.04 + Math.sin(tick * 0.08) * 0.02;
  ctx.fillStyle = '#FFB040';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

function drawLetterRoom(t, p, tick) {
  // Pull back to reveal the captain's study
  drawKenBurns('cutscene-letter', 1.20 - p * 0.15, p * 10, -20 + p * 20);
  ctx.save();
  ctx.globalAlpha = 0.03;
  ctx.fillStyle = '#D4A03C';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

// ═══════════════════════════════════════════════════════════
// CUTSCENE: THE CAVE — Into darkness
// ═══════════════════════════════════════════════════════════

function drawCaveEntrance(t, p, tick) {
  // Pan forward into the cave, lantern light flickers
  drawKenBurns('cutscene-cave', 1.10 + p * 0.10, 0, p * -15);
  ctx.save();
  ctx.globalAlpha = 0.05 + Math.sin(tick * 0.06) * 0.03;
  ctx.fillStyle = '#FFa040';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
  // Darken edges for cave atmosphere
  ctx.save();
  const caveVig = ctx.createRadialGradient(GW / 2, GH / 2, GW * 0.15, GW / 2, GH / 2, GW * 0.55);
  caveVig.addColorStop(0, 'rgba(0,0,0,0)');
  caveVig.addColorStop(1, 'rgba(0,0,0,0.45)');
  ctx.fillStyle = caveVig;
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

// ═══════════════════════════════════════════════════════════
// CUTSCENE: THE GHOST — Captain Visvikis appears
// ═══════════════════════════════════════════════════════════

function drawGhostAppear(t, p, tick) {
  // Slow zoom, jade-green ethereal pulse
  drawKenBurns('cutscene-ghost', 1.08 + p * 0.08, 0, p * -10);
  // Jade green ethereal glow
  ctx.save();
  ctx.globalAlpha = 0.04 + Math.sin(tick * 0.04) * 0.03;
  ctx.fillStyle = '#40D8A0';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
  // Dusk vignette
  ctx.save();
  ctx.globalAlpha = 0.15;
  ctx.fillStyle = '#1a0a2e';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

function drawGhostFade(t, p, tick) {
  // Slow pull back as ghost fades
  drawKenBurns('cutscene-ghost', 1.16 - p * 0.08, 0, -10 + p * 10);
  // Fading jade light
  ctx.save();
  ctx.globalAlpha = (1 - p) * 0.06;
  ctx.fillStyle = '#40D8A0';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
  ctx.save();
  ctx.globalAlpha = 0.12 + p * 0.08;
  ctx.fillStyle = '#1a0a2e';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

// ═══════════════════════════════════════════════════════════
// CUTSCENE: THE CROSSING — Dawn on the Ελπίδα
// ═══════════════════════════════════════════════════════════

function drawCrossingWide(t, p, tick) {
  // Majestic wide shot, gentle drift right following the boat
  drawKenBurns('cutscene-crossing', 1.12 - p * 0.06, -10 + p * 20, 0);
  // Dawn pink-gold overlay
  ctx.save();
  ctx.globalAlpha = 0.05 + Math.sin(tick * 0.015) * 0.02;
  ctx.fillStyle = '#FFB8A0';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

function drawCrossingClose(t, p, tick) {
  // Zoom toward the bow and the island ahead
  drawKenBurns('cutscene-crossing', 1.06 + p * 0.14, p * 15, p * -20);
  ctx.save();
  ctx.globalAlpha = 0.03;
  ctx.fillStyle = '#FFD880';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

// ═══════════════════════════════════════════════════════════
// CUTSCENE: THE TREASURE — The chest opens
// ═══════════════════════════════════════════════════════════

function drawTreasureReveal(t, p, tick) {
  // Zoom into the open chest, gold light builds
  drawKenBurns('cutscene-treasure', 1.08 + p * 0.12, 0, p * -25);
  // Building golden glow
  ctx.save();
  ctx.globalAlpha = p * 0.08;
  ctx.fillStyle = '#FFD040';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

function drawTreasureFamily(t, p, tick) {
  // Pull back to show the family together
  drawKenBurns('cutscene-treasure', 1.20 - p * 0.12, 0, -25 + p * 25);
  ctx.save();
  ctx.globalAlpha = 0.04;
  ctx.fillStyle = '#FFD880';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

// ═══════════════════════════════════════════════════════════
// CUTSCENE: EPILOGUE — The new αλληλασφάλεια
// ═══════════════════════════════════════════════════════════

function drawEpilogueHarbor(t, p, tick) {
  // Wide establishing shot, festive lights twinkle
  drawKenBurns('cutscene-epilogue', 1.12 - p * 0.06, p * 8, 0);
  // Warm night glow
  ctx.save();
  ctx.globalAlpha = 0.06 + Math.sin(tick * 0.03) * 0.02;
  ctx.fillStyle = '#FFB860';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

function drawEpilogueClose(t, p, tick) {
  // Zoom to the signing table and family
  drawKenBurns('cutscene-epilogue', 1.06 + p * 0.14, -p * 10, p * -15);
  ctx.save();
  ctx.globalAlpha = 0.04;
  ctx.fillStyle = '#FFD880';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

// ════════════════════════════════════════════════════════════
// EASING
// ════════════════════════════════════════════════════════════
function easeInOutCubic(t) { return t < .5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3)/2; }

// ════════════════════════════════════════════════════════════
// COORDINATE CONVERSION
// ════════════════════════════════════════════════════════════
function screenToGame(sx, sy) {
  const rect = CVS.getBoundingClientRect();
  const scaleX = GW / rect.width;
  const scaleY = GH / rect.height;
  return { x: (sx - rect.left) * scaleX, y: (sy - rect.top) * scaleY };
}

// ════════════════════════════════════════════════════════════
// DUST PARTICLES (canvas-drawn)
// ════════════════════════════════════════════════════════════
const particles = [];
function initParticles() {
  particles.length = 0;
  const isExterior = (state.scene === 'exterior' || state.scene === 'terrace');
  const count = isExterior ? 30 : 20;
  for (let i = 0; i < count; i++) {
    if (isExterior) {
      // Golden motes drifting in the light shaft (upper-right to lower-left)
      const startX = GW * 0.4 + Math.random() * GW * 0.6;
      particles.push({
        x: startX,
        y: Math.random() * GH * 0.7,
        vx: -0.05 - Math.random() * 0.15,
        vy: 0.03 + Math.random() * 0.08,
        size: 0.6 + Math.random() * 1.5,
        alpha: 0,
        maxAlpha: 0.15 + Math.random() * 0.25,
        life: Math.random() * 700,
        maxLife: 600 + Math.random() * 500,
        glow: Math.random() < 0.3,
      });
    } else {
      particles.push({
        x: Math.random() * GW,
        y: 60 + Math.random() * 240,
        vx: 0.1 + Math.random() * 0.25,
        vy: -0.05 - Math.random() * 0.12,
        size: 0.8 + Math.random() * 1.8,
        alpha: 0,
        maxAlpha: 0.12 + Math.random() * 0.18,
        life: Math.random() * 700,
        maxLife: 500 + Math.random() * 400,
      });
    }
  }
}

function updateParticles() {
  for (const p of particles) {
    p.x += p.vx;
    p.y += p.vy;
    p.life++;
    const prog = p.life / p.maxLife;
    if (prog < 0.3) p.alpha = p.maxAlpha * (prog / 0.3) * (prog / 0.3); // quadratic fade-in
    else if (prog > 0.7) { const f = (prog - 0.7) / 0.3; p.alpha = p.maxAlpha * (1 - f * f); } // quadratic fade-out
    else p.alpha = p.maxAlpha;
    if (p.life >= p.maxLife || p.x > GW + 10 || p.x < -10 || p.y < -10 || p.y > GH + 10) {
      const isExterior = (state.scene === 'exterior' || state.scene === 'terrace');
      if (isExterior) {
        p.x = GW * 0.4 + Math.random() * GW * 0.6;
        p.y = -5 + Math.random() * 30;
      } else {
        p.x = -5 + Math.random() * 20;
        p.y = 80 + Math.random() * 200;
      }
      p.life = 0;
      p.alpha = 0;
    }
  }
}

function drawParticles() {
  const sp = state.seq.env.spectral;
  for (const p of particles) {
    if (p.alpha <= 0) continue;
    ctx.save();
    ctx.globalAlpha = p.alpha;
    if (sp > 0) {
      // Lerp particle colors from gold to blue-white based on spectral
      const gr = Math.round(255 * (1 - sp) + 130 * sp);
      const gg = Math.round(200 * (1 - sp) + 180 * sp);
      const gb = Math.round(60 * (1 - sp) + 255 * sp);
      ctx.shadowColor = `rgba(${gr},${gg},${gb},0.6)`;
      ctx.shadowBlur = 4;
      ctx.fillStyle = `rgb(${gr},${gg},${gb})`;
    } else if (p.glow) {
      ctx.shadowColor = 'rgba(255,200,60,0.6)';
      ctx.shadowBlur = 4;
      ctx.fillStyle = '#FFD860';
    } else {
      ctx.fillStyle = '#D4A03C';
    }
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

// ════════════════════════════════════════════════════════════
// SCENE AMBIENCE — per-scene visual & audio layers
// ════════════════════════════════════════════════════════════


// ── Bobbing Boats (extracted from background, redrawn with bob) ──
let boatCutout = null;
let boatWaterPatch = null;
const boatRegion = { x: 375, y: 135, w: 190, h: 80 };
let boatBobPhase = 0;

function initBoatBob() {
  boatBobPhase = Math.random() * Math.PI * 2;
  boatCutout = null;
  boatWaterPatch = null;
  const bgImg = images['bg-exterior'];
  if (!bgImg || !bgImg.complete) return;
  // Source coords in the 1024x1024 image
  const sx = boatRegion.x / GW * bgImg.naturalWidth;
  const sy = boatRegion.y / GH * bgImg.naturalHeight;
  const sw = boatRegion.w / GW * bgImg.naturalWidth;
  const sh = boatRegion.h / GH * bgImg.naturalHeight;
  // Extract boats
  const cut = document.createElement('canvas');
  cut.width = boatRegion.w;
  cut.height = boatRegion.h;
  const cctx = cut.getContext('2d');
  cctx.imageSmoothingEnabled = true;
  cctx.imageSmoothingQuality = 'high';
  cctx.drawImage(bgImg, sx, sy, sw, sh, 0, 0, boatRegion.w, boatRegion.h);
  boatCutout = cut;
  // Water patch from row just below boats
  const patch = document.createElement('canvas');
  patch.width = boatRegion.w;
  patch.height = boatRegion.h + 8;
  const pctx = patch.getContext('2d');
  pctx.imageSmoothingEnabled = true;
  pctx.imageSmoothingQuality = 'high';
  const waterSrcY = sy + sh;
  for (let row = 0; row < patch.height; row++) {
    pctx.drawImage(bgImg, sx, waterSrcY, sw, 1, 0, row, boatRegion.w, 1);
  }
  boatWaterPatch = patch;
}

function updateBoatBob(dt) {
  boatBobPhase += dt * 0.8;
}

function drawBoatBob() {
  if (!boatCutout || !boatWaterPatch) return;
  const bob = Math.sin(boatBobPhase) * 3;
  // Cover original boats with water
  ctx.drawImage(boatWaterPatch, boatRegion.x, boatRegion.y);
  // Redraw boats shifted by bob
  ctx.drawImage(boatCutout, boatRegion.x, boatRegion.y + bob);
}

// ── Sea Shimmer ──
function drawSeaShimmer(tick) {
  const t = tick * 0.02;
  ctx.save();
  // Water area on exterior scene (right side, harbor)
  for (let ry = 75; ry < 140; ry += 2) {
    const d = (ry - 75) / 65;
    // Golden reflections
    ctx.fillStyle = `rgba(230,180,60,${0.04 + d * 0.03})`;
    for (let rx = 360; rx < 580; rx += 4) {
      const shimmer = Math.sin(rx * 0.05 + ry * 0.08 + t * 1.8) * 0.5 + 0.5;
      if (shimmer > 0.55) {
        ctx.fillRect(rx, ry, 2 + Math.floor(shimmer * 3), 1);
      }
    }
    // Dark wave troughs
    ctx.fillStyle = `rgba(0,20,40,${0.03 + d * 0.02})`;
    for (let rx = 360; rx < 580; rx += 6) {
      if (Math.sin(rx * 0.07 + ry * 0.12 - t * 1.1) > 0.4) {
        ctx.fillRect(rx, ry + 1, 3, 1);
      }
    }
  }
  ctx.restore();
}

// ── Bougainvillea Petals ──
const petals = [];
function initPetals() {
  petals.length = 0;
  for (let i = 0; i < 12; i++) {
    petals.push(newPetal());
  }
}
function newPetal() {
  return {
    x: 175 + Math.random() * 150,
    y: 20 + Math.random() * 40,
    vx: 0.1 + Math.random() * 0.3,
    vy: 0.2 + Math.random() * 0.4,
    rot: Math.random() * Math.PI * 2,
    rotV: (Math.random() - 0.5) * 0.05,
    size: 1.5 + Math.random() * 1.5,
    wobble: Math.random() * Math.PI * 2,
    wobbleSpeed: 0.02 + Math.random() * 0.02,
    alpha: 0.5 + Math.random() * 0.4,
    color: Math.random() < 0.7 ? '#E0489A' : (Math.random() < 0.5 ? '#D03878' : '#C83068'),
  };
}
function updatePetals() {
  for (const p of petals) {
    p.wobble += p.wobbleSpeed;
    p.x += p.vx + Math.sin(p.wobble) * 0.3;
    p.y += p.vy;
    p.rot += p.rotV;
    if (p.y > 380 || p.x > GW + 10) {
      Object.assign(p, newPetal());
    }
  }
}
function drawPetals() {
  for (const p of petals) {
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(p.rot);
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.ellipse(0, 0, p.size, p.size * 0.5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}


// ── Orange Cat ──
const cat = { x: 95, y: 243, phase: 0, blinkTimer: 0, blinking: false, tailPhase: 0 };
function updateCat(dt) {
  cat.phase += dt;
  cat.tailPhase += dt * 2.5;
  cat.blinkTimer += dt;
  if (!cat.blinking && cat.blinkTimer > 3 + Math.random() * 4) {
    cat.blinking = true;
    cat.blinkTimer = 0;
  }
  if (cat.blinking && cat.blinkTimer > 0.15) {
    cat.blinking = false;
    cat.blinkTimer = 0;
  }
}
function drawCat() {
  const cx = cat.x, cy = cat.y;
  ctx.save();
  ctx.imageSmoothingEnabled = false;
  // Body (sitting loaf shape)
  ctx.fillStyle = '#D08030';
  ctx.fillRect(cx, cy, 10, 6);       // body
  ctx.fillRect(cx + 1, cy - 1, 8, 1); // back curve
  // Head
  ctx.fillRect(cx + 8, cy - 4, 6, 5); // head
  ctx.fillStyle = '#E09040';
  ctx.fillRect(cx + 9, cy - 3, 4, 3); // face highlight
  // Ears
  ctx.fillStyle = '#D08030';
  ctx.fillRect(cx + 8, cy - 6, 2, 2);  // left ear
  ctx.fillRect(cx + 12, cy - 6, 2, 2); // right ear
  ctx.fillStyle = '#E8A060';
  ctx.fillRect(cx + 9, cy - 5, 1, 1);  // inner ear
  ctx.fillRect(cx + 12, cy - 5, 1, 1);
  // Eyes
  if (!cat.blinking) {
    ctx.fillStyle = '#40A040';
    ctx.fillRect(cx + 9, cy - 2, 1, 1);
    ctx.fillRect(cx + 12, cy - 2, 1, 1);
  } else {
    ctx.fillStyle = '#D08030';
    ctx.fillRect(cx + 9, cy - 2, 1, 1);
    ctx.fillRect(cx + 12, cy - 2, 1, 1);
  }
  // Nose
  ctx.fillStyle = '#E07890';
  ctx.fillRect(cx + 11, cy - 1, 1, 1);
  // Stripes
  ctx.fillStyle = '#B06820';
  ctx.fillRect(cx + 2, cy, 1, 5);
  ctx.fillRect(cx + 5, cy, 1, 5);
  ctx.fillRect(cx + 10, cy - 4, 1, 2);
  // Tail (swishing)
  const tailSwing = Math.sin(cat.tailPhase) * 4;
  ctx.fillStyle = '#D08030';
  ctx.fillRect(cx - 1, cy + 3, 1, 1);
  ctx.fillRect(cx - 2, cy + 2 + tailSwing * 0.2, 1, 1);
  ctx.fillRect(cx - 3, cy + 1 + tailSwing * 0.4, 1, 1);
  ctx.fillRect(cx - 4, cy + tailSwing * 0.5, 1, 1);
  // Tip darker
  ctx.fillStyle = '#B06820';
  ctx.fillRect(cx - 4, cy + tailSwing * 0.5, 1, 1);
  // Paws
  ctx.fillStyle = '#E0A060';
  ctx.fillRect(cx + 1, cy + 5, 2, 1);
  ctx.fillRect(cx + 7, cy + 5, 2, 1);
  ctx.restore();
}

// ── Golden Hour Light Shaft ──
function drawLightShaft(tick) {
  ctx.save();
  const t = tick * 0.005;
  // Diagonal warm light from upper-right
  const lg = ctx.createLinearGradient(GW, 0, GW * 0.3, GH * 0.6);
  lg.addColorStop(0, `rgba(255,200,80,${0.04 + Math.sin(t) * 0.01})`);
  lg.addColorStop(0.4, `rgba(255,180,60,${0.02 + Math.sin(t + 1) * 0.005})`);
  lg.addColorStop(1, 'rgba(255,180,60,0)');
  ctx.fillStyle = lg;
  ctx.fillRect(0, 0, GW, GH);
  // Light beam rays (subtle streaks)
  ctx.globalAlpha = 0.015 + Math.sin(t * 0.7) * 0.005;
  ctx.fillStyle = '#FFD060';
  ctx.beginPath();
  ctx.moveTo(GW, 0);
  ctx.lineTo(GW * 0.55, GH * 0.7);
  ctx.lineTo(GW * 0.65, GH * 0.7);
  ctx.lineTo(GW, 20);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(GW - 40, 0);
  ctx.lineTo(GW * 0.4, GH * 0.5);
  ctx.lineTo(GW * 0.48, GH * 0.5);
  ctx.lineTo(GW - 10, 0);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

// ── Heat Haze ──
function drawHeatHaze(tick) {
  ctx.save();
  const t = tick * 0.03;
  ctx.globalAlpha = 0.02;
  for (let x = 50; x < GW - 50; x += 8) {
    const shift = Math.sin(x * 0.05 + t) * 1.5;
    ctx.fillStyle = '#FFD090';
    ctx.fillRect(x, 360 + shift, 4, 1);
  }
  ctx.restore();
}

// ── Ambient Sound Manager (Web Audio API — procedural, no files) ──
let audioCtx = null;
const ambientSounds = {
  wavesNode: null, cicadasNode: null, windNode: null, dripsInterval: null,
  bellPlayed: false, gullTimer: 0, gullInterval: 10,
  masterGain: null, active: false, currentScene: null,
};

// Per-scene ambient config: which layers play and at what volume
const sceneAmbientConfig = {
  exterior:  { waves: 0.12, wind: 0.04, gulls: true,  gullFreq: [8,7] },
  terrace:   { waves: 0.10, wind: 0.03, gulls: true,  gullFreq: [10,8] },
  kitchen:   { waves: 0.03, wind: 0.01 },
  port:      { waves: 0.18, wind: 0.06, gulls: true,  gullFreq: [5,4] },
  waterfront:{ waves: 0.14, wind: 0.04, gulls: true,  gullFreq: [8,6] },
  museum:    { waves: 0.02, wind: 0.01 },
  liotrivi:  { waves: 0.04, wind: 0.02 },
  cave:      { drips: true,  wind: 0.02 },
  windmill:  { waves: 0.06, wind: 0.12, gulls: true,  gullFreq: [12,10] },
  graveyard: { waves: 0.04, wind: 0.08 },
  church:    { waves: 0.02, wind: 0.01 },
  boat:      { waves: 0.22, wind: 0.10, gulls: true,  gullFreq: [6,5] },
  treasure:  { waves: 0.08, wind: 0.06 },
};

function getAudioCtx() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    ambientSounds.masterGain = audioCtx.createGain();
    ambientSounds.masterGain.gain.value = 1;
    ambientSounds.masterGain.connect(audioCtx.destination);
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}

function createWavesLoop() {
  const ctx = getAudioCtx();
  const bufferSize = ctx.sampleRate * 4;
  const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
  const data = buffer.getChannelData(0);
  let last = 0;
  for (let i = 0; i < bufferSize; i++) {
    const white = Math.random() * 2 - 1;
    last = (last + (0.02 * white)) / 1.02;
    const waveMod = 0.5 + 0.5 * Math.sin(i / ctx.sampleRate * Math.PI * 0.3);
    data[i] = last * 3.5 * waveMod;
  }
  const src = ctx.createBufferSource();
  src.buffer = buffer;
  src.loop = true;
  const lp = ctx.createBiquadFilter();
  lp.type = 'lowpass';
  lp.frequency.value = 400;
  const gain = ctx.createGain();
  gain.gain.value = 0.12;
  src.connect(lp);
  lp.connect(gain);
  gain.connect(ambientSounds.masterGain);
  src.start();
  return { src, gain };
}

function createCicadasLoop() {
  const ctx = getAudioCtx();
  const merger = ctx.createGain();
  merger.gain.value = 0;
  const oscs = [];
  const freqs = [4200, 4800, 5100, 5600, 6200];
  for (const f of freqs) {
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = f + (Math.random() - 0.5) * 200;
    const am = ctx.createGain();
    const lfo = ctx.createOscillator();
    lfo.frequency.value = 8 + Math.random() * 12;
    const lfoGain = ctx.createGain();
    lfoGain.gain.value = 0.5;
    lfo.connect(lfoGain);
    lfoGain.connect(am.gain);
    am.gain.value = 0.5;
    osc.connect(am);
    am.connect(merger);
    osc.start();
    lfo.start();
    oscs.push({ osc, lfo });
  }
  const bp = ctx.createBiquadFilter();
  bp.type = 'bandpass';
  bp.frequency.value = 5000;
  bp.Q.value = 2;
  const gain = ctx.createGain();
  gain.gain.value = 0.04;
  merger.connect(bp);
  bp.connect(gain);
  gain.connect(ambientSounds.masterGain);
  return { oscs, merger, gain };
}

function playSeagullCry() {
  const ctx = getAudioCtx();
  const now = ctx.currentTime;
  const osc = ctx.createOscillator();
  osc.type = 'sine';
  const baseF = 1800 + Math.random() * 600;
  osc.frequency.setValueAtTime(baseF, now);
  osc.frequency.linearRampToValueAtTime(baseF * 0.6, now + 0.15);
  osc.frequency.linearRampToValueAtTime(baseF * 1.1, now + 0.35);
  osc.frequency.linearRampToValueAtTime(baseF * 0.5, now + 0.6);
  const osc2 = ctx.createOscillator();
  osc2.type = 'sine';
  osc2.frequency.setValueAtTime(baseF * 1.5, now);
  osc2.frequency.linearRampToValueAtTime(baseF * 0.9, now + 0.15);
  osc2.frequency.linearRampToValueAtTime(baseF * 1.6, now + 0.35);
  osc2.frequency.linearRampToValueAtTime(baseF * 0.75, now + 0.6);
  const vib = ctx.createOscillator();
  vib.frequency.value = 20 + Math.random() * 15;
  const vibGain = ctx.createGain();
  vibGain.gain.value = 40;
  vib.connect(vibGain);
  vibGain.connect(osc.frequency);
  vibGain.connect(osc2.frequency);
  const env = ctx.createGain();
  env.gain.setValueAtTime(0, now);
  env.gain.linearRampToValueAtTime(0.06 + Math.random() * 0.04, now + 0.05);
  env.gain.setValueAtTime(0.06, now + 0.35);
  env.gain.linearRampToValueAtTime(0, now + 0.7);
  const noiseLen = ctx.sampleRate;
  const noiseBuf = ctx.createBuffer(1, noiseLen, ctx.sampleRate);
  const nd = noiseBuf.getChannelData(0);
  for (let i = 0; i < noiseLen; i++) nd[i] = Math.random() * 2 - 1;
  const noiseSrc = ctx.createBufferSource();
  noiseSrc.buffer = noiseBuf;
  const noiseBP = ctx.createBiquadFilter();
  noiseBP.type = 'bandpass';
  noiseBP.frequency.value = 2000;
  noiseBP.Q.value = 3;
  const noiseGain = ctx.createGain();
  noiseGain.gain.setValueAtTime(0, now);
  noiseGain.gain.linearRampToValueAtTime(0.015, now + 0.05);
  noiseGain.gain.linearRampToValueAtTime(0, now + 0.7);
  noiseSrc.connect(noiseBP);
  noiseBP.connect(noiseGain);
  noiseGain.connect(ambientSounds.masterGain);
  osc.connect(env);
  osc2.connect(env);
  env.connect(ambientSounds.masterGain);
  osc.start(now);
  osc2.start(now);
  vib.start(now);
  noiseSrc.start(now);
  osc.stop(now + 0.75);
  osc2.stop(now + 0.75);
  vib.stop(now + 0.75);
  noiseSrc.stop(now + 0.75);
}

function playChurchBell() {
  const ctx = getAudioCtx();
  const now = ctx.currentTime;
  const partials = [1, 2.0, 2.98, 4.07, 5.2, 6.5];
  const baseF = 280;
  const mix = ctx.createGain();
  mix.gain.value = 0.12;
  for (let i = 0; i < partials.length; i++) {
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = baseF * partials[i];
    const g = ctx.createGain();
    const amp = 1 / (i + 1);
    const decay = 3 - i * 0.3;
    g.gain.setValueAtTime(amp, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + Math.max(0.5, decay));
    osc.connect(g);
    g.connect(mix);
    osc.start(now);
    osc.stop(now + 4);
  }
  mix.connect(ambientSounds.masterGain);
}

function createWindLoop(volume) {
  const ctx = getAudioCtx();
  const bufferSize = ctx.sampleRate * 6;
  const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
  const data = buffer.getChannelData(0);
  let last = 0;
  for (let i = 0; i < bufferSize; i++) {
    const white = Math.random() * 2 - 1;
    last = (last + (0.01 * white)) / 1.01;
    // Slow modulation for gusting effect
    const gust = 0.4 + 0.6 * Math.sin(i / ctx.sampleRate * Math.PI * 0.15)
                          * Math.sin(i / ctx.sampleRate * Math.PI * 0.07 + 1.3);
    data[i] = last * 4 * Math.max(0, gust);
  }
  const src = ctx.createBufferSource();
  src.buffer = buffer;
  src.loop = true;
  const hp = ctx.createBiquadFilter();
  hp.type = 'highpass';
  hp.frequency.value = 200;
  const lp = ctx.createBiquadFilter();
  lp.type = 'lowpass';
  lp.frequency.value = 1200;
  const gain = ctx.createGain();
  gain.gain.value = volume;
  src.connect(hp);
  hp.connect(lp);
  lp.connect(gain);
  gain.connect(ambientSounds.masterGain);
  src.start();
  return { src, gain };
}

function playCaveDrip() {
  const ctx = getAudioCtx();
  const now = ctx.currentTime;
  const freq = 1200 + Math.random() * 2000;
  const osc = ctx.createOscillator();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(freq, now);
  osc.frequency.exponentialRampToValueAtTime(freq * 0.3, now + 0.15);
  const env = ctx.createGain();
  env.gain.setValueAtTime(0.08 + Math.random() * 0.04, now);
  env.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
  // Simple delay for echo
  const delay = ctx.createDelay();
  delay.delayTime.value = 0.12 + Math.random() * 0.08;
  const delayGain = ctx.createGain();
  delayGain.gain.value = 0.3;
  osc.connect(env);
  env.connect(ambientSounds.masterGain);
  env.connect(delay);
  delay.connect(delayGain);
  delayGain.connect(ambientSounds.masterGain);
  osc.start(now);
  osc.stop(now + 0.4);
}

function initAmbientSound() {
  ambientSounds.gullTimer = 0;
  ambientSounds.gullInterval = 8 + Math.random() * 7;
}

function startSceneAmbience(sceneId) {
  stopSceneAmbience();
  const cfg = sceneAmbientConfig[sceneId];
  if (!cfg) return;
  ambientSounds.currentScene = sceneId;
  try {
    // Waves layer
    if (cfg.waves) {
      ambientSounds.wavesNode = createWavesLoop();
      ambientSounds.wavesNode.gain.gain.value = cfg.waves;
    }
    // Wind layer
    if (cfg.wind) {
      ambientSounds.windNode = createWindLoop(cfg.wind);
    }
    // Seagull timer
    if (cfg.gulls) {
      ambientSounds.gullTimer = 0;
      ambientSounds.gullInterval = cfg.gullFreq[0] + Math.random() * cfg.gullFreq[1];
    }
    // Cave drips — periodic random drips
    if (cfg.drips) {
      const dripFn = () => {
        playCaveDrip();
        ambientSounds.dripsInterval = setTimeout(dripFn, 1500 + Math.random() * 3000);
      };
      ambientSounds.dripsInterval = setTimeout(dripFn, 500 + Math.random() * 1000);
    }
    // One-time church bell on first exterior visit
    if (!ambientSounds.bellPlayed && sceneId === 'exterior') {
      ambientSounds.bellPlayed = true;
      setTimeout(() => playChurchBell(), 2500);
    }
  } catch (e) { /* Web Audio not available */ }
  // Visual ambience
  if (sceneId === 'exterior' || sceneId === 'terrace') {
    initBoatBob();
    initPetals();
  }
  ambientSounds.active = true;
}

function stopSceneAmbience() {
  if (ambientSounds.wavesNode) {
    try { ambientSounds.wavesNode.src.stop(); } catch (e) {}
    ambientSounds.wavesNode = null;
  }
  if (ambientSounds.windNode) {
    try { ambientSounds.windNode.src.stop(); } catch (e) {}
    ambientSounds.windNode = null;
  }
  if (ambientSounds.cicadasNode) {
    try {
      for (const o of ambientSounds.cicadasNode.oscs) { o.osc.stop(); o.lfo.stop(); }
    } catch (e) {}
    ambientSounds.cicadasNode = null;
  }
  if (ambientSounds.dripsInterval) {
    clearTimeout(ambientSounds.dripsInterval);
    ambientSounds.dripsInterval = null;
  }
  boatCutout = null;
  boatWaterPatch = null;
  petals.length = 0;
  ambientSounds.active = false;
  ambientSounds.currentScene = null;
}

function updateAmbientSound(dt) {
  if (!ambientSounds.active) return;
  const cfg = sceneAmbientConfig[state.scene];
  if (!cfg || !cfg.gulls) return;
  ambientSounds.gullTimer += dt;
  if (ambientSounds.gullTimer >= ambientSounds.gullInterval) {
    ambientSounds.gullTimer = 0;
    ambientSounds.gullInterval = cfg.gullFreq[0] + Math.random() * cfg.gullFreq[1];
    playSeagullCry();
  }
}

// ── Master draw/update for scene ambience ──
function updateSceneAmbience(dt) {
  updateAmbientSound(dt);
  if (state.scene === 'exterior') {
    updateBoatBob(dt);
    updatePetals();
    updateCat(dt);
  }
}

function drawSceneAmbience(tick) {
  if (state.scene === 'exterior') {
    drawBoatBob();
    drawSeaShimmer(tick);
    drawLightShaft(tick);
    drawPetals();
    drawCat();
    drawHeatHaze(tick);
  } else if (state.scene === 'terrace') {
    drawSeaShimmer(tick);
    drawLightShaft(tick);
  } else if (state.scene === 'cave') {
    drawCaveAmbience(tick);
  }
}

// Cave ambience: god-rays, torch flicker, water shimmer, dripping water
function drawCaveAmbience(tick) {
  ctx.save();

  // ── GOD-RAYS from entrance (right side) ──
  // Animated diagonal light beams streaming through the arch
  const rayBase = 520; // x center of entrance arch
  for (let r = 0; r < 5; r++) {
    const phase = tick * 0.008 + r * 1.3;
    const alpha = (Math.sin(phase) * 0.5 + 0.5) * 0.06 + 0.02;
    const spread = r * 28 - 56;
    ctx.fillStyle = `rgba(255,210,120,${alpha})`;
    // Angled rays: narrow at top, spread toward floor
    ctx.beginPath();
    ctx.moveTo(rayBase + spread, 60 + r * 15);
    ctx.lineTo(rayBase + spread - 30, 60 + r * 15);
    ctx.lineTo(rayBase + spread - 120, 320);
    ctx.lineTo(rayBase + spread - 80, 320);
    ctx.closePath();
    ctx.fill();
  }
  // Warm ambient glow near entrance
  const entrGlow = Math.sin(tick * 0.012) * 0.01 + 0.04;
  ctx.fillStyle = `rgba(255,200,100,${entrGlow})`;
  ctx.fillRect(440, 40, 200, 280);

  // ── TORCH FLICKER (two torches flanking the stone door) ──
  const torchL = { x: 205, y: 150 }; // left torch
  const torchR = { x: 345, y: 150 }; // right torch
  [torchL, torchR].forEach((t, i) => {
    const flicker = Math.sin(tick * 0.15 + i * 2.1) * 0.02
                  + Math.sin(tick * 0.23 + i * 3.7) * 0.01;
    // Warm glow pool around each torch
    ctx.fillStyle = `rgba(255,160,50,${0.04 + flicker})`;
    ctx.fillRect(t.x - 40, t.y - 35, 80, 70);
    ctx.fillStyle = `rgba(255,180,80,${0.06 + flicker})`;
    ctx.fillRect(t.x - 20, t.y - 18, 40, 36);
    // Tiny bright core
    ctx.fillStyle = `rgba(255,220,140,${0.08 + flicker * 2})`;
    ctx.fillRect(t.x - 3, t.y - 4, 6, 8);
  });

  // ── TIDAL POOL SHIMMER ──
  for (let wx = 140; wx < 370; wx += 6) {
    const wave = Math.sin(tick * 0.035 + wx * 0.06);
    if (wave > 0.1) {
      ctx.fillStyle = `rgba(80,200,200,${0.06 + wave * 0.08})`;
      ctx.fillRect(wx, 272 + wave * 3, 5, 1);
    }
    // Bright reflections from torchlight on water
    if (Math.sin(tick * 0.05 + wx * 0.15) > 0.7) {
      ctx.fillStyle = `rgba(255,210,120,${0.08 + Math.sin(tick * 0.08 + wx) * 0.04})`;
      ctx.fillRect(wx + 2, 278 + Math.sin(wx * 0.3) * 2, 2, 1);
    }
  }

  // ── DRIPPING WATER (from stalactites) ──
  // Drip 1: from center stalactite
  const drip1 = tick % 110;
  if (drip1 < 22) {
    const dy = drip1 * 3.2 + 45;
    if (dy < 268) {
      ctx.fillStyle = 'rgba(100,200,220,0.5)';
      ctx.fillRect(280, dy, 1, 2);
      if (drip1 > 8) ctx.fillRect(280, dy + 2, 1, 1);
    }
  }
  if (drip1 >= 22 && drip1 < 27) {
    const sp = drip1 - 22;
    ctx.fillStyle = `rgba(100,200,220,${0.3 - sp * 0.06})`;
    ctx.fillRect(278 - sp * 2, 270, 1, 1);
    ctx.fillRect(282 + sp * 2, 270, 1, 1);
  }
  // Drip 2: offset timing, different stalactite
  const drip2 = (tick + 55) % 140;
  if (drip2 < 18) {
    const dy2 = drip2 * 2.8 + 38;
    if (dy2 < 265) {
      ctx.fillStyle = 'rgba(80,180,200,0.4)';
      ctx.fillRect(180, dy2, 1, 2);
    }
  }

  // ── DUST MOTES in god-ray beams ──
  for (let d = 0; d < 8; d++) {
    const dx = 430 + Math.sin(tick * 0.012 + d * 1.9) * 80;
    const dy = 80 + Math.sin(tick * 0.009 + d * 2.4) * 110 + d * 20;
    const da = Math.sin(tick * 0.04 + d * 3.1);
    if (da > 0.2 && dx > 380) {
      ctx.fillStyle = `rgba(255,220,150,${da * 0.15})`;
      ctx.fillRect(dx, dy, 1, 1);
    }
  }

  ctx.restore();
}

// ════════════════════════════════════════════════════════════
// CHARACTER RENDERING (ported from Galaxidi Adventure)
// ════════════════════════════════════════════════════════════
const CHAR_HEIGHTS = { ntemis: 118, ajax: 84, clio: 92 };

// Scale factor: sprites are small relative to 640x400 canvas — scale up to MI2 proportions
const CHAR_SCALE = 1.5;

// Per-character anatomy: waist split ratio & max leg stride (pixels, in sprite space)
const WALK_ANATOMY = {
  ntemis:  { waist: 0.62, stride: 10 },
  ajax:    { waist: 0.58, stride: 8 },
  clio:    { waist: 0.60, stride: 8 },
  ghost:   { waist: 0.55, stride: 0 },
  athos:   { waist: 0.60, stride: 7 },
  stathis: { waist: 0.58, stride: 8 },
  akis:    { waist: 0.60, stride: 8 },
  giannis: { waist: 0.58, stride: 7 },
  curator: { waist: 0.62, stride: 6 },
};

function drawSprite(who, gx, gy, dir, walking, frame, tick, frameOffset) {
  const img = CHAR_IMGS[who];
  if (!img || !img.complete || !img.naturalWidth) {
    drawFallbackPerson(gx, gy, who);
    return;
  }
  const sprW = img.naturalWidth;
  const sprH = img.naturalHeight;
  const anat = WALK_ANATOMY[who] || { waist: 0.60, stride: 6 };
  const S = CHAR_SCALE;

  if (walking) {
    // ── WALK PHASE (slower cycle for natural cadence) ──
    const walkPhase = frame * Math.PI * 2.4 + frameOffset * Math.PI / 3;
    const bob = -Math.abs(Math.sin(walkPhase)) * 2;
    const lean = dir * 0.02;
    const strideDir = Math.sin(walkPhase); // -1 to 1

    const waistY = Math.floor(sprH * anat.waist);
    const legH = sprH - waistY;
    const maxStride = anat.stride;

    // Ground shadow (scaled)
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = '#4A3A28';
    const sw = (sprW * 0.6 + Math.abs(strideDir) * 3) * S;
    ctx.beginPath();
    ctx.ellipse(gx, gy + 3, sw, 3.5 * S, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.translate(gx, gy + bob);
    // Apply character scale + horizontal flip
    if (dir < 0) ctx.scale(-S, S);
    else ctx.scale(S, S);
    ctx.rotate(lean);

    // ── UPPER BODY (slight counter-sway) ──
    const counterSway = -strideDir * 1.5;
    ctx.drawImage(img,
      0, 0, sprW, waistY,
      -sprW/2 + counterSway, -sprH, sprW, waistY
    );

    // ── BACK LEG (drawn first, darker, shifted opposite, lifted) ──
    const bandH = 2;
    ctx.save();
    ctx.globalAlpha = 0.7;
    for (let y = 0; y < legH; y += bandH) {
      const progress = y / Math.max(1, legH - 1);
      const backOff = -strideDir * maxStride * 0.7 * (0.3 + 0.7 * progress);
      const lift = Math.abs(strideDir) * 3 * progress;
      const h = Math.min(bandH, legH - y);
      ctx.drawImage(img,
        0, waistY + y, sprW, h,
        -sprW/2 + backOff, -sprH + waistY + y - lift, sprW, h
      );
    }
    ctx.restore();

    // ── FRONT LEG (on top, full brightness, shifted forward) ──
    for (let y = 0; y < legH; y += bandH) {
      const progress = y / Math.max(1, legH - 1);
      const frontOff = strideDir * maxStride * (0.3 + 0.7 * progress);
      const h = Math.min(bandH, legH - y);
      ctx.drawImage(img,
        0, waistY + y, sprW, h,
        -sprW/2 + frontOff, -sprH + waistY + y, sprW, h
      );
    }

    ctx.restore();

  } else {
    // ── IDLE ANIMATION ──
    const bp = tick * 0.03 + frameOffset * 3;
    const breathe = Math.sin(bp) * 1.0 + Math.sin(bp * 0.6 + 0.5) * 0.4;
    const sway = Math.sin(tick * 0.01 + frameOffset * 2.5) * 0.008
               + Math.sin(tick * 0.023 + frameOffset) * 0.003;
    const bc = Math.sin(bp);
    const squashX = 1 + bc * 0.005;
    const squashY = 1 - bc * 0.005;

    // Ground shadow (scaled)
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = '#4A3A28';
    ctx.beginPath();
    ctx.ellipse(gx, gy + 3, sprW * S * 0.6, 4 * S, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.translate(gx, gy + breathe);
    // Apply character scale + horizontal flip
    if (dir < 0) ctx.scale(-S, S);
    else ctx.scale(S, S);
    ctx.rotate(sway);
    ctx.scale(squashX, squashY);
    ctx.drawImage(img, -sprW/2, -sprH);
    ctx.restore();
  }
}

function drawFallbackPerson(x, y, who) {
  const colors = {
    ntemis: { shirt: '#2A4466', pants: '#1a2a3a', skin: '#DDAA88' },
    ajax:   { shirt: '#4A6644', pants: '#2a3a2a', skin: '#DDBB99' },
    clio:   { shirt: '#664466', pants: '#3a2a3a', skin: '#DDC0A0' },
  };
  const c = colors[who] || colors.ntemis;
  const h = who === 'ntemis' ? 40 : 32;
  // Simple rectangle person
  ctx.fillStyle = c.skin;
  ctx.fillRect(x - 4, y - h, 8, 10); // head
  ctx.fillStyle = c.shirt;
  ctx.fillRect(x - 6, y - h + 10, 12, 14); // body
  ctx.fillStyle = c.pants;
  ctx.fillRect(x - 5, y - h + 24, 10, h - 24); // legs
}

function drawCharacter(who, tick) {
  const c = chars[who];
  if (!c.visible) return;
  const offsets = { ntemis: 0, ajax: 1.05, clio: 2.1 };
  // Fade-in alpha with smoothstep
  let alpha = Math.min(1, c.fadeIn);
  if (alpha < 1) {
    alpha = alpha * alpha * (3 - 2 * alpha); // smoothstep
    ctx.save();
    ctx.globalAlpha = alpha;
  }
  drawSprite(who, c.x, c.y, c.dir, c.walking, c.frame, tick, offsets[who]);
  if (alpha < 1) ctx.restore();
}

function drawNPC(who, tick) {
  const npc = npcChars[who];
  if (!npc || npc.scene !== state.scene) return;
  // Allow ghost rendering during materialization even when not yet visible
  const isMaterializing = who === 'ghost' && state.seq.active && state.seq.ghostMat.active;
  if (!npc.visible && !isMaterializing) return;
  const img = CHAR_IMGS[who];
  if (!img || !img.complete || !img.naturalWidth) return;

  const sprW = img.naturalWidth;
  const sprH = img.naturalHeight;
  const gx = npc.x;
  const gy = npc.y;

  // Idle animation (same as family chars)
  const bp = tick * 0.03;
  const breathe = Math.sin(bp) * 1.0 + Math.sin(bp * 0.6 + 0.5) * 0.4;
  const sway = Math.sin(tick * 0.01) * 0.008 + Math.sin(tick * 0.023) * 0.003;
  const bc = Math.sin(bp);
  const squashX = 1 + bc * 0.005;
  const squashY = 1 - bc * 0.005;

  // Ground shadow (scaled)
  const S = CHAR_SCALE;
  ctx.save();
  ctx.globalAlpha = who === 'ghost' ? 0.06 : 0.18;
  ctx.fillStyle = '#4A3A28';
  ctx.beginPath();
  ctx.ellipse(gx, gy + 3, sprW * S * 0.6, 4 * S, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  ctx.save();
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';

  // Ghost special effects
  if (who === 'ghost') {
    if (state.seq.active && state.seq.ghostMat.active) {
      // During sequence: use materialization alpha/glow
      ctx.globalAlpha = state.seq.ghostMat.alpha;
      ctx.shadowColor = 'rgba(100,180,255,0.5)';
      ctx.shadowBlur = state.seq.ghostMat.glowBlur;
    } else {
      ctx.globalAlpha = 0.45 + Math.sin(tick * 0.02) * 0.1;
      ctx.shadowColor = 'rgba(100,180,255,0.5)';
      ctx.shadowBlur = 12;
    }
  }

  // Wave vertical oscillation
  const waveOffset = (npc.wave || 0) > 0 ? Math.sin(tick * 0.1) * npc.wave : 0;

  ctx.translate(gx, gy + breathe + waveOffset);
  if (npc.dir < 0) ctx.scale(-S, S);
  else ctx.scale(S, S);
  ctx.rotate(sway + (npc.tilt || 0));
  ctx.scale(squashX, squashY);
  ctx.drawImage(img, -sprW / 2, -sprH);
  ctx.restore();
}

// ════════════════════════════════════════════════════════════
// WALKABLE AREA SYSTEM
// ════════════════════════════════════════════════════════════
// Each scene defines a walkLine: array of [x, y] points that define
// the ground level across the scene. Characters snap to this line.
function getGroundY(sceneId, x) {
  const sc = scenes[sceneId];
  if (!sc || !sc.walkLine) return 378; // fallback
  const pts = sc.walkLine;
  if (x <= pts[0][0]) return pts[0][1];
  if (x >= pts[pts.length - 1][0]) return pts[pts.length - 1][1];
  for (let i = 0; i < pts.length - 1; i++) {
    if (x >= pts[i][0] && x <= pts[i + 1][0]) {
      const t = (x - pts[i][0]) / (pts[i + 1][0] - pts[i][0]);
      return pts[i][1] + t * (pts[i + 1][1] - pts[i][1]);
    }
  }
  return pts[0][1];
}

// ════════════════════════════════════════════════════════════
// WALKING SYSTEM
// ════════════════════════════════════════════════════════════
function startWalk(who, targetX, cb) {
  const c = chars[who];
  const dist = Math.abs(targetX - c.x);
  if (dist < 5) { if (cb) cb(); return; }
  targetX = Math.max(30, Math.min(GW - 30, targetX));
  c.dir = targetX > c.x ? 1 : -1;
  c.walking = true;
  c.startX = c.x;
  c.startY = c.y;
  c.targetX = targetX;
  c.targetY = getGroundY(state.scene, targetX);
  c.walkT = 0;
  c.walkDur = Math.max(0.6, Math.min(3.5, (dist / GW) * 5.0));
  c.frame = 0;
  walkDoneCallback = cb;
}

function updateWalking(dt) {
  for (const who of ['ntemis','ajax','clio']) {
    const c = chars[who];
    if (!c.walking) continue;
    c.walkT += dt;
    const p = Math.min(1, c.walkT / c.walkDur);
    const ep = easeInOutCubic(p);
    c.x = c.startX + (c.targetX - c.startX) * ep;
    // Interpolate Y along the ground line for proper grounding
    c.y = c.startY + (c.targetY - c.startY) * ep;

    // Store raw walk time for smooth interpolation in drawSprite
    c.frame = c.walkT;

    if (p >= 1) {
      c.x = c.targetX;
      c.y = c.targetY;
      c.walking = false;
      c.targetX = null;
      c.targetY = null;
      c.dir = 1;
      if (who === 'ntemis' && walkDoneCallback) {
        const cb = walkDoneCallback;
        walkDoneCallback = null;
        cb();
      }
    }
  }
}

// Family follow: Ajax and Clio follow Ntemis with offset
function familyFollow(targetX) {
  const nX = targetX;
  // Ajax follows to the right, Clio to the left
  const ajaxTarget = Math.min(GW - 30, nX + 70);
  const clioTarget = Math.max(30, nX - 70);
  setTimeout(() => startWalk('ajax', ajaxTarget), 150);
  setTimeout(() => startWalk('clio', clioTarget), 280);
}

// ════════════════════════════════════════════════════════════
// HOTSPOT HIT TESTING
// ════════════════════════════════════════════════════════════
function hitTestObj(gx, gy) {
  if (!state.scene) return null;
  const sc = scenes[state.scene];
  for (const obj of sc.objects) {
    if (gx >= obj.x && gx <= obj.x + obj.w && gy >= obj.y && gy <= obj.y + obj.h) {
      return obj;
    }
  }
  return null;
}

function hitTestExit(gx, gy) {
  if (!state.scene) return null;
  const sc = scenes[state.scene];
  if (!sc.exits) return null;
  for (const exit of sc.exits) {
    if (exit.side === 'left' && gx < 25) return exit;
    if (exit.side === 'right' && gx > GW - 25) return exit;
  }
  return null;
}

// ════════════════════════════════════════════════════════════
// VOICE SYSTEM
// ════════════════════════════════════════════════════════════
const voiceAudio = new Audio();
voiceAudio.volume = 0.8;

const VOICE_MAP = {
  'Ξύλινη πόρτα βαμμένη μπλε. Το χρώμα του Αιγαίου.': 'voice/narrator/001.mp3',
  'Ροζ μπουκαμβίλιες σκαρφαλώνουν στον τοίχο. Εδώ το καλοκαίρι αρνείται να φύγει.': 'voice/narrator/002.mp3',
  'Πήλινες γλάστρες με βασιλικό. Κάποιος τα περιποιείται ακόμα κι όταν το σπίτι μένει κλειστό.': 'voice/narrator/003.mp3',
  'Ένα παλιό ξύλινο βαρέλι. Μυρίζει κρασί και αλμύρα.': 'voice/narrator/004.mp3',
  'Χρωματιστά ψαροκάικα δεμένα στο λιμάνι. Κουνιούνται αργά στο απογευματινό φως.': 'voice/narrator/005.mp3',
  'Ο Κορινθιακός κόλπος λάμπει χρυσαφί στο ηλιοβασίλεμα. Μαγικό.': 'voice/narrator/006.mp3',
  'Ο ήλιος βάφει χρυσά τα καλντερίμια. Μυρωδιά πεύκου ανακατεμένη με θαλασσινό αλάτι.': 'voice/narrator/007.mp3',
  'Ο Κορινθιακός λάμπει σαν λιωμένο χρυσάφι. Ψαροκάικα κουνιούνται αργά στο λιμάνι.': 'voice/narrator/008.mp3',
  'Τρία δελφίνια κόβουν βόλτες στο λιμάνι.': 'voice/narrator/009.mp3',
  'Τα δελφίνια συνεχίζουν τους κύκλους τους. Σαν να φυλάνε κάτι.': 'voice/narrator/010.mp3',
  'Κεραμίδια, σκεπές, καμινάδες. Κάθε σπίτι κι ένας καπετάνιος κάποτε.': 'voice/narrator/011.mp3',
  'Ο Παρνασσός στο βάθος. Οι Δελφοί κάπου εκεί πάνω.': 'voice/narrator/012.mp3',
  'Πέτρινο κάγκελο με θέα ολόκληρο το Γαλαξίδι. Θα μπορούσες να κάτσεις εδώ ώρες.': 'voice/narrator/013.mp3',
  'Γεράνια σε πήλινη γλάστρα. Τα χρώματα λάμπουν στο ηλιοβασίλεμα.': 'voice/narrator/014.mp3',
  'Η θέα κόβει την ανάσα.': 'voice/narrator/015.mp3',
  'Φρέσκα σύκα σε πήλινο μπολ. Η μυρωδιά γεμίζει το δωμάτιο.': 'voice/narrator/016.mp3',
  'Τρως ένα σύκο. Γλυκό σαν μέλι.': 'voice/narrator/017.mp3',
  'Μια παλιά δερμάτινη τσάντα πάνω στην καρέκλα. Δεν είναι δική σας.': 'voice/narrator/018.mp3',
  'Η τσάντα είναι άδεια τώρα.': 'voice/narrator/019.mp3',
  'Ανοίγεις την τσάντα. Μέσα βρίσκεις ένα σημείωμα.': 'voice/narrator/020.mp3',
  '«Σας περιμέναμε. Ελάτε στο λιμάνι απόψε. Τραπέζι για τρεις. — Γ.»': 'voice/narrator/021.mp3',
  'Η τσάντα είναι πλέον άδεια.': 'voice/narrator/022.mp3',
  'Απογευματινό φως μέσα από γαλάζια πατζούρια. Σκιές χορεύουν στον τοίχο.': 'voice/narrator/023.mp3',
  'Ανοίγεις τα πατζούρια. Μυρωδιά θυμαριού και τζιτζίκια.': 'voice/narrator/024.mp3',
  'Χάλκινα σκεύη κρεμασμένα στον τοίχο. Κάποτε τάιζαν οικογένειες ναυτικών.': 'voice/narrator/025.mp3',
  'Πέτρινο τζάκι. Μέσα υπάρχουν ακόμα στάχτες από τον τελευταίο χειμώνα.': 'voice/narrator/026.mp3',
  'Η κουζίνα μυρίζει θυμάρι και παλιό ξύλο.': 'voice/narrator/027.mp3',
  'Χρωματιστά καΐκια δεμένα στα μπαλόνια. Η μπογιά ξεφλουδίζει — αλμύρα και χρόνια.': 'voice/narrator/028.mp3',
  'Μεταλλικές δέστρες ψηλότερες από την Κλειώ. Φτιαγμένες για τρικάταρτα, όχι για βαρκούλες.': 'voice/narrator/029.mp3',
  'Ένας ψαράς μπαλώνει τα δίχτυα του. Τα χέρια του κινούνται αυτόματα — πενήντα χρόνια πρακτική.': 'voice/narrator/030.mp3',
  'Ο ψαράς σηκώνει το βλέμμα. Τα μάτια του είναι γαλάζια σαν τον κόλπο.': 'voice/narrator/031.mp3',
  '«Ψάρι λίγο. Ιστορίες πολλές. Κάτσε να σου πω.»': 'voice/narrator/032.mp3',
  'Πέτρινες αποθήκες με σιδερένιες πόρτες. Κάποτε γεμάτες σταφίδα και λάδι για εξαγωγή. Τώρα σιωπή.': 'voice/narrator/033.mp3',
  'Γλάροι κράζουν πάνω από το λιμάνι. Αιώνιοι κάτοικοι.': 'voice/narrator/034.mp3',
  'Τρεις γάτες ξαπλωμένες στον ήλιο. Σε κοιτάνε με αδιαφορία.': 'voice/narrator/035.mp3',
  'Ο Στάθης με την κιθάρα του. Φίλος από τα παλιά.': 'voice/narrator/036.mp3',
  'Ο Άκης παίζει φλογέρα στο λιμάνι. Η μελωδία ταξιδεύει στο νερό.': 'voice/narrator/037.mp3',
  'Το λιμάνι του Γαλαξειδίου. Μισοφέγγαρο από πέτρα, κυμαρισμένο φως, μυρωδιά αλμύρας.': 'voice/narrator/038.mp3',
  'Ένα πανέμορφο μοντέλο τρικάταρτου μέσα σε γυάλινη βιτρίνα. Κάθε λεπτομέρεια τέλεια.': 'voice/narrator/039.mp3',
  'Η πινακίδα γράφει: «Σκούνα Χρυσούλα, 1904 — το τελευταίο ιστιοφόρο του Γαλαξειδίου.»': 'voice/narrator/040.mp3',
  'Μια γωνιά αφιερωμένη στα ατμόπλοια. Ένα σιδερένιο μοντέλο, μικρότερο, λιγότερο εντυπωσιακό.': 'voice/narrator/041.mp3',
  'Πορτρέτα σε χρυσές κορνίζες. Σοβαρά πρόσωπα, κομψά μουστάκια, μάτια που έχουν δει θάλασσα.': 'voice/narrator/042.mp3',
  'Πυξίδες, εξάντες, χάρτες. Τα εργαλεία που οδηγούσαν τα πλοία σε κάθε γωνιά της Μεσογείου.': 'voice/narrator/043.mp3',
  'Ναυτικές σημαίες κρέμονται από το ταβάνι. Ελληνική, γαλλική, ρωσική — τα λιμάνια που γνώριζαν.': 'voice/narrator/044.mp3',
  'Ένας παλιός χάρτης του Κορινθιακού ξαπλωμένος σε τραπέζι. Σημειώσεις με μελάνι — δρόμοι ναυσιπλοΐας.': 'voice/narrator/045.mp3',
  'Ο επιμελητής του μουσείου. Τα μάτια του λάμπουν πίσω από τα στρογγυλά γυαλιά.': 'voice/narrator/046.mp3',
  'Το Ναυτικό Μουσείο του Γαλαξειδίου. Μυρωδιά ξύλου και παλιού χαρτιού.': 'voice/narrator/047.mp3',
  'Το παλιό ελαιοτριβείο — πέτρα και ξύλο. Κάποτε έβγαζε λάδι, τώρα βγάζει ιστορίες.': 'voice/narrator/048.mp3',
  'Ξύλινο μπαρ γεμάτο μπουκάλια. Τσίπουρο, ρακή, κρασιά ντόπια. Φανάρια ρίχνουν ζεστό φως.': 'voice/narrator/049.mp3',
  'Γαλάζια πατζούρια ανοιχτά στο φεγγαρόφωτο. Το λιμάνι λάμπει ασημί.': 'voice/narrator/050.mp3',
  'Ασπρόμαυρες φωτογραφίες στον τοίχο. Ψαράδες, καπετάνιοι, γυναίκες που περίμεναν.': 'voice/narrator/051.mp3',
  'Ξύλινα σκαμπό τριγμένα από χρόνια. Πόσες κουβέντες έχουν ακούσει.': 'voice/narrator/052.mp3',
  'Πλακάκια σε σκακιέρα — κίτρινα και καφέ. Λαμπυρίζουν στο φως των φαναριών.': 'voice/narrator/053.mp3',
  'Ο Άθος. Δικηγόρος και ιδιοκτήτης του Λιοτριβιού. Τα μάτια του κρύβουν χίλια μυστικά.': 'voice/narrator/054.mp3',
  'Το Λιοτρίβι. Πέτρα, ξύλο, ζεστό φως. Μυρωδιά τσίπουρου και ελιάς.': 'voice/narrator/055.mp3',
  'Μια τεράστια πέτρινη πόρτα με δώδεκα κυκλικές εσοχές. Σχήμα τιμονιού.': 'voice/narrator/056.mp3',
  'Χαραγμένα σύμβολα στον βράχο. Νεκροκεφαλή, ψάρι, άγκυρα, μάτι.': 'voice/narrator/057.mp3',
  'Τυρκουάζ νερό λάμπει από το φως της εισόδου. Κρυστάλλινο.': 'voice/narrator/058.mp3',
  'Σταλακτίτες κρέμονται σαν δάχτυλα γίγαντα. Χιλιάδες χρόνια σε κάθε σταγόνα.': 'voice/narrator/059.mp3',
  'Ένα σάπιο βαρέλι. Μυρίζει θάλασσα και χρόνο.': 'voice/narrator/060.mp3',
  'Άδειο, εκτός από αλμύρα και σκόνη.': 'voice/narrator/061.mp3',
  'Χρυσό φως χύνεται μέσα από τη φυσική αψίδα. Σκόνη χορεύει στις ακτίνες.': 'voice/narrator/062.mp3',
  'Ο Κάρκαρος. Ο θόλος υψώνεται σαν καθεδρικός. Χρυσό φως χύνεται από την είσοδο.': 'voice/narrator/063.mp3',
  'Πέτρινο σιντριβάνι στην πλατεία. Το νερό τρέχει αθόρυβα.': 'voice/narrator/064.mp3',
  'Ο Άγιος Νικόλαος — προστάτης των ναυτικών. Ο τρούλος λάμπει κόκκινος στον ήλιο.': 'voice/narrator/065.mp3',
  'Φούξια μπουκαμβίλιες σκεπάζουν τον τοίχο. Χρώμα που αψηφά τον χρόνο.': 'voice/narrator/066.mp3',
  'Μια πορτοκαλί γάτα κοιμάται αράχτη στα πλακάκια.': 'voice/narrator/067.mp3',
  'Η γάτα νιαουρίζει απαλά.': 'voice/narrator/068.mp3',
  'Πέτρινα παγκάκια στη σκιά. Γέροι κάθονταν εδώ κάθε απόγευμα, εδώ και δεκαετίες.': 'voice/narrator/069.mp3',
  'Γλάστρες με γεράνια και λουλούδια. Κάποιος φροντίζει αυτή την πλατεία με αγάπη.': 'voice/narrator/070.mp3',
  'Η πλατεία του Αγίου Νικολάου. Ησυχία, λουλούδια, και ήχος νερού.': 'voice/narrator/071.mp3',
  'Ένα παλιό ορειχάλκινο τηλεσκόπιο. Κάποιος το άφησε εδώ;': 'voice/narrator/072.mp3',
  'Η θέα κόβει την ανάσα. Ολόκληρο το Γαλαξίδι, ο κόλπος, τα βουνά. Από εδώ βλέπεις τα πάντα.': 'voice/narrator/073.mp3',
  'Πέτρινα ερείπια — ίσως ο παλιός μύλος. Αψίδα ακόμα όρθια, αψηφώντας τον χρόνο.': 'voice/narrator/074.mp3',
  'Παπαρούνες, μαργαρίτες, θυμάρι. Ο λόφος μυρίζει μέλι και καλοκαίρι.': 'voice/narrator/075.mp3',
  'Πέτρινο καλντερίμι ανεβαίνει τον λόφο. Λειασμένο από πόδια αιώνων.': 'voice/narrator/076.mp3',
  'Ο Γιάννης Βελανής. Ιδιοκτήτης του παλιού μύλου. Ήσυχος, βλέπει τα πάντα από ψηλά.': 'voice/narrator/077.mp3',
  'Ο Γιάννης σου δίνει ένα φανάρι.': 'voice/narrator/078.mp3',
  'Η κορυφή του λόφου. Αέρας, φως, και θέα που δεν τελειώνει.': 'voice/narrator/079.mp3',
  '«ΕΛΠΙΔΑ» — χρυσά γράμματα σε ξεφλουδισμένο μπλε ξύλο.': 'voice/narrator/080.mp3',
  'Ένα μικρό λευκό παρεκκλήσι πάνω στον βράχο. Ελληνική σημαία κυματίζει.': 'voice/narrator/081.mp3',
  'Ο ήλιος βυθίζεται στον Κορινθιακό. Χρυσό, πορτοκαλί, ροζ. Τα βουνά γίνονται σκιές.': 'voice/narrator/082.mp3',
  'Κανείς δεν μιλάει. Δεν χρειάζεται.': 'voice/narrator/083.mp3',
  'Σχοινιά τυλιγμένα στο κατάστρωμα. Μυρίζουν θάλασσα και πεύκο.': 'voice/narrator/084.mp3',
  'Πορτοκαλί σωσίβιο. Λευκά γράμματα: ΕΛΠΙΔΑ — ΓΑΛΑΞΙΔΙ.': 'voice/narrator/085.mp3',
  'Το Γαλαξίδι λάμπει στον ήλιο του δειλινού. Σπίτια, εκκλησίες, το λιμάνι — σαν μακέτα.': 'voice/narrator/086.mp3',
  'Η Ελπίδα πλέει αργά στον Κορινθιακό. Ο κόσμος σταμάτησε.': 'voice/narrator/087.mp3',
  'Μαρμάρινοι σταυροί και πλάκες. Ονόματα καπεταναίων: Τσώνης, Ρήγας, Μαμάς, Χρυσοβαλάντου.': 'voice/narrator/088.mp3',
  'Κυπαρίσσια ψηλά σαν κατάρτια. Φρουροί αιώνιοι.': 'voice/narrator/089.mp3',
  'Κόκκινες παπαρούνες ανάμεσα στους τάφους. Η ζωή εκεί που αναπαύεται ο θάνατος.': 'voice/narrator/090.mp3',
  'Η θάλασσα λάμπει χρυσή από το ηλιοβασίλεμα. Ακόμα και μετά θάνατον, οι καπετάνιοι βλέπουν τη θάλασσα.': 'voice/narrator/091.mp3',
  'Ένα ιστιοφόρο στον ορίζοντα. Σαν φάντασμα του παρελθόντος.': 'voice/narrator/092.mp3',
  'Πλακόστρωτο μονοπάτι ανάμεσα στους τάφους. Λειασμένο από χιλιάδες επισκέψεις.': 'voice/narrator/093.mp3',
  'Μια αχνή, ψηλή σιλουέτα κοντά στα κυπαρίσσια. Τρεμοπαίζει σαν φως σε νερό.': 'voice/narrator/094.mp3',
  'Το φάντασμα δεν μιλάει. Δείχνει προς την εκκλησία.': 'voice/narrator/095.mp3',
  'Το παλιό νεκροταφείο. Θέα στη θάλασσα, μυρωδιά θυμαριού, ησυχία.': 'voice/narrator/096.mp3',
  'Τίποτα ιδιαίτερο.': 'voice/narrator/097.mp3',
  'Το χαρτί μυρίζει θάλασσα. Παλιομοδίτικο γράψιμο.': 'voice/narrator/098.mp3',
  'Ο ήλιος βυθίζεται πίσω από τα βουνά. Το λιμάνι περιμένει.': 'voice/narrator/099.mp3',
  '— Τέλος Σκηνής 1 —': 'voice/narrator/100.mp3',
  'Συνέχεια στη Σκηνή 2: Το Γράμμα...': 'voice/narrator/101.mp3',
  'Λατσούδη! Περίμενα πότε θα φτάσεις.': 'voice/athos/001.mp3',
  'Ξέρω τον παππού σου. Ήξερα. Και ξέρω τι ψάχνεις.': 'voice/athos/002.mp3',
  'Ο Βισβίκης άφησε διαθήκη. Αν θέλεις απαντήσεις, ψάξε στο σπήλαιο του Κάρκαρου.': 'voice/athos/003.mp3',
  'Άδειο. Κρίμα!': 'voice/ajax/001.mp3',
  'Μπαμπά, θα πάμε βόλτα με βάρκα;': 'voice/ajax/002.mp3',
  'Τέλειο! Πάμε κατευθείαν στο λιμάνι;': 'voice/ajax/003.mp3',
  'Δελφίνια μέσα στο λιμάνι; Αυτό δεν είναι συνηθισμένο...': 'voice/ajax/004.mp3',
  'Μπαμπά, μπορώ να φάω ένα;': 'voice/ajax/005.mp3',
  'Ποιος είναι ο «Γ.»;': 'voice/ajax/006.mp3',
  'Και κάτι πάνω στην καρέκλα... μια τσάντα;': 'voice/ajax/007.mp3',
  'Μπαμπά, μπορώ να πηδήξω σε κάποιο;': 'voice/ajax/008.mp3',
  'Αυτό το λιμάνι φαίνεται τεράστιο για τόσο μικρό χωριό.': 'voice/ajax/009.mp3',
  'Γιατί; Ήταν χαζοί;': 'voice/ajax/010.mp3',
  'Ε, λίγο μόνο.': 'voice/ajax/011.mp3',
  'Εγώ θέλω να δω αν έχει κανόνια.': 'voice/ajax/012.mp3',
  'Εγώ μπορώ να πάρω λεμονάδα;': 'voice/ajax/013.mp3',
  'Αυτό μοιάζει σαν πειρατικό καπηλειό!': 'voice/ajax/014.mp3',
  'Ή σαν τιμόνι καραβιού!': 'voice/ajax/015.mp3',
  'Μπορώ να κολυμπήσω;': 'voice/ajax/016.mp3',
  'Μήπως είχε ρούμι;': 'voice/ajax/017.mp3',
  'Σαν εκκλησία!': 'voice/ajax/018.mp3',
  'Η πόρτα! Κοιτάξτε αυτή την τεράστια πόρτα!': 'voice/ajax/019.mp3',
  'Πάλι γάτα;': 'voice/ajax/020.mp3',
  'Τι; Τι βλέπεις;': 'voice/ajax/021.mp3',
  'Μπαμπά, βλέπω μέχρι την Ιτέα!': 'voice/ajax/022.mp3',
  'ΤΕΛΕΙΟ! Βλέπω τα πάντα από εδώ!': 'voice/ajax/023.mp3',
  'Ξέρω κόμπους! Ο παππούς μου έμαθε.': 'voice/ajax/024.mp3',
  'Μπαμπά, μπορούμε να μείνουμε για πάντα εδώ;': 'voice/ajax/025.mp3',
  'Τους έβαλαν εδώ επίτηδες. Να βλέπουν.': 'voice/ajax/026.mp3',
  'Φάντασμα; Σοβαρά τώρα;': 'voice/ajax/027.mp3',
  'Κοίτα — βλέπεις τη θάλασσα από κάθε τάφο. Αυτό ήθελαν.': 'voice/ajax/028.mp3',
  'Πάμε στο λιμάνι!': 'voice/ajax/029.mp3',
  'Ε, Ντέμη! Τα παιδιά μεγάλωσαν!': 'voice/akis/001.mp3',
  'Ένα παλιό τραγούδι ναυτικό. Πήγαινε στο μουσείο — θα καταλάβεις.': 'voice/akis/002.mp3',
  '...': 'voice/giannis/001.mp3',
  'Το ξέρω. Σε βλέπω από εδώ πάνω.': 'voice/giannis/002.mp3',
  'Πάρε αυτό. Θα το χρειαστείς.': 'voice/giannis/003.mp3',
  'Καλώς ήρθατε! Βλέπω ξέρετε να εκτιμάτε την ιστορία.': 'voice/curator/001.mp3',
  'Τριακόσια πλοία! Η Χρυσούλα ήταν το τελευταίο. Τα ατμόπλοια τα σκότωσαν όλα.': 'voice/curator/002.mp3',
  'Ωραία ερώτηση, μικρή. Ήταν τόσο καλοί στα πανιά, που δεν φαντάζονταν κόσμο χωρίς αυτά.': 'voice/curator/003.mp3',
  'Μπαμπά, μην τις κόβεις! Είναι τέλειες έτσι.': 'voice/clio/001.mp3',
  'Πρώτα ας αφήσουμε τις βαλίτσες. Θέλω να δω τη βεράντα.': 'voice/clio/002.mp3',
  'Μπαμπά, κοίτα! Δελφίνια!': 'voice/clio/003.mp3',
  'Οι Αμφικτίονες ξεκινούσαν από τους Δελφούς... Το Γαλαξίδι ήταν λιμάνι τους.': 'voice/clio/004.mp3',
  'Μπαμπά, μην ακουμπάς, φαίνεται παλιό!': 'voice/clio/005.mp3',
  'Αυτό είναι το πιο όμορφο μέρος στον κόσμο.': 'voice/clio/006.mp3',
  'Μπαμπά, κοίτα — υπάρχει κάτι μέσα.': 'voice/clio/007.mp3',
  'Διάβασέ το!': 'voice/clio/008.mp3',
  'Κοιτάξτε — κάποιος μας άφησε σύκα!': 'voice/clio/009.mp3',
  'Γιατί είναι τόσο μεγάλες;': 'voice/clio/010.mp3',
  'Αυτοί ξέρουν τα πάντα. Αν μιλούσαν...': 'voice/clio/011.mp3',
  'Πόσο τέλεια! Αυτή η πορτοκαλί μου αρέσει πολύ.': 'voice/clio/012.mp3',
  'Θείε Άκη, τι παίζεις;': 'voice/clio/013.mp3',
  'Τριακόσια καράβια, μπαμπά. Το διάβασα.': 'voice/clio/014.mp3',
  'Κοιτάξτε τα πανιά! Ένα-ένα ραμμένα.': 'voice/clio/015.mp3',
  'Αυτός μοιάζει λίγο με τον μπαμπά.': 'voice/clio/016.mp3',
  'Χωρίς GPS; Πώς;': 'voice/clio/017.mp3',
  'Μπαμπά, σημείωσε αυτό. Μπορεί να μας χρειαστεί.': 'voice/clio/018.mp3',
  'Γιατί δεν έφτιαξαν κι αυτοί ατμόπλοια;': 'voice/clio/019.mp3',
  'Πόσα μοντέλα! Θέλω να τα δω ΟΛΑ.': 'voice/clio/020.mp3',
  'Φανταστείτε πόσα χέρια το γύρισαν.': 'voice/clio/021.mp3',
  'Μαγικό. Σαν πίνακας ζωγραφικής.': 'voice/clio/022.mp3',
  'Σπήλαιο; Θα πάμε σε σπήλαιο;!': 'voice/clio/023.mp3',
  'Μυρίζει ωραία. Σαν τη γιαγιά.': 'voice/clio/024.mp3',
  'Δώδεκα θέσεις. Σαν ρολόι.': 'voice/clio/025.mp3',
  'Αυτά δεν είναι πειρατικά. Είναι σημάδια καπεταναίων!': 'voice/clio/026.mp3',
  'Ο Κάρκαρος. Λέγανε ότι η φωνή σου γυρίζει πίσω τρεις φορές.': 'voice/clio/027.mp3',
  'Σαν να σε καλεί μέσα.': 'voice/clio/028.mp3',
  'Μπαμπά... αυτό δεν μοιάζει σπήλαιο. Μοιάζει σαν κάποιος να το έφτιαξε.': 'voice/clio/029.mp3',
  'Ρίχνω ένα νόμισμα;': 'voice/clio/030.mp3',
  'Την ξαναβρήκα! Αυτή είναι η ίδια από το λιμάνι.': 'voice/clio/031.mp3',
  'Γεια σου, μικρούλα. Με ακολουθείς;': 'voice/clio/032.mp3',
  'Τι ωραία πλατεία! Και γάτα!': 'voice/clio/033.mp3',
  'Αφήστε με να κοιτάξω!': 'voice/clio/034.mp3',
  'Βλέπω... το λιμάνι! Και κάτι στο νερό...': 'voice/clio/035.mp3',
  'Ένα σημάδι στην προβλήτα. Σαν αστέρι.': 'voice/clio/036.mp3',
  'Και τους Δελφούς! Εκεί πάνω!': 'voice/clio/037.mp3',
  'Θέλω να ζωγραφίσω αυτά.': 'voice/clio/038.mp3',
  'Μπαμπά, κοίτα — ένα τηλεσκόπιο!': 'voice/clio/039.mp3',
  'Ποιος πάει εκεί πάνω για λειτουργία;': 'voice/clio/040.mp3',
  'Από εδώ φαίνεται σαν παραμύθι.': 'voice/clio/041.mp3',
  'Αυτό... αυτό είναι τέλειο.': 'voice/clio/042.mp3',
  'Κάθε πέτρα και ένα ταξίδι.': 'voice/clio/043.mp3',
  'Μπαμπά, δεν είναι τρομακτικό. Είναι... ωραίο.': 'voice/clio/044.mp3',
  'Μπαμπά... βλέπω κάτι εκεί.': 'voice/clio/045.mp3',
  'Θέλει να πάμε στον Άγιο Νικόλαο!': 'voice/clio/046.mp3',
  'Μπαμπά... δεν μου αρέσουν τα νεκροταφεία.': 'voice/clio/047.mp3',
  'Ο «Γ.» ξέρει ότι είμαστε τρεις. Πρέπει να πάμε.': 'voice/clio/048.mp3',
  'Ας μπούμε μέσα.': 'voice/ntemis/001.mp3',
  'Φτάσαμε, παιδιά. Αυτό είναι το σπίτι μας για το Σαββατοκύριακο.': 'voice/ntemis/002.mp3',
  'Καλωσορίσατε στο Γαλαξίδι.': 'voice/ntemis/003.mp3',
  'Φυσικά.': 'voice/ntemis/004.mp3',
  'Και πώς ξέρει ότι είμαστε τρεις;': 'voice/ntemis/005.mp3',
  'Δεν είναι δική μας. Ας κοιτάξω μέσα πρώτα.': 'voice/ntemis/006.mp3',
  'Μπορείς να κοιτάξεις. Από εδώ.': 'voice/ntemis/007.mp3',
  'Γιατί κάποτε εδώ δένανε ιστιοφόρα πενήντα μέτρων.': 'voice/ntemis/008.mp3',
  'Καλησπέρα! Πολύ ψάρι σήμερα;': 'voice/ntemis/009.mp3',
  'Στάθη! Πόσο καιρό!': 'voice/ntemis/010.mp3',
  'Γιατί κάποτε δεν ήταν μικρό χωριό. Ήταν ναυτική δύναμη.': 'voice/ntemis/011.mp3',
  'Αυτό ήταν το μέλλον. Και το Γαλαξίδι δεν το είδε.': 'voice/ntemis/012.mp3',
  'Όχι. Ήταν οι καλύτεροι στα πανιά. Γι\u0027 αυτό ακριβώς δεν άλλαξαν.': 'voice/ntemis/013.mp3',
  'Ευχαριστώ, νομίζω.': 'voice/ntemis/014.mp3',
  'Αστέρια, εμπειρία, και θάρρος.': 'voice/ntemis/015.mp3',
  'Τα παιδιά μου ήθελαν να δουν τα καράβια.': 'voice/ntemis/016.mp3',
  'Σσσ. Μουσείο, παιδιά. Ησυχία.': 'voice/ntemis/017.mp3',
  'Κάθε φωτογραφία και μια ιστορία. Κάθε πρόσωπο και μια ζωή.': 'voice/ntemis/018.mp3',
  'Κάτσε. Ξεκουράσου. Η νύχτα είναι μακριά.': 'voice/ntemis/019.mp3',
  'Με ξέρεις;': 'voice/ntemis/020.mp3',
  'Ελάτε, ας δούμε ποιος είναι εδώ.': 'voice/ntemis/021.mp3',
  'Κάτι πρέπει να μπει σε κάθε εσοχή. Αλλά τι;': 'voice/ntemis/022.mp3',
  'Δεν κουνιέται. Χρειαζόμαστε κάτι για τις εσοχές.': 'voice/ntemis/023.mp3',
  'Δεν έχουμε αρκετά ακόμα. Πρέπει να ψάξουμε περισσότερο.': 'voice/ntemis/024.mp3',
  'Σωστά. Κάθε καπετάνιος είχε το δικό του σήμα. Αυτοί οι τοίχοι θυμούνται.': 'voice/ntemis/025.mp3',
  'Όχι τώρα, Αία. Ποιος ξέρει πόσο βαθιά είναι.': 'voice/ntemis/026.mp3',
  'Πιθανόν, κάποτε.': 'voice/ntemis/027.mp3',
  'Δώδεκα εσοχές. Σαν τιμόνι πλοίου. Κάτι μας λείπει.': 'voice/ntemis/028.mp3',
  'Γιατί όχι; Κάνε μια ευχή.': 'voice/ntemis/029.mp3',
  'Κάθε καπετάνιος προσευχόταν εδώ πριν φύγει. Και η οικογένειά του μετά.': 'voice/ntemis/030.mp3',
  'Ο Άγιος Νικόλαος. Προστάτης των ναυτικών. Κατάλληλος για το Γαλαξίδι.': 'voice/ntemis/031.mp3',
  'Σημείωσέ το, Κλειώ.': 'voice/ntemis/032.mp3',
  'Γεια σου. Ψάχνουμε το σπήλαιο του Κάρκαρου.': 'voice/ntemis/033.mp3',
  'Ένα σημείο παρατήρησης. Κάποιος παρακολουθούσε τα πλοία από εδώ.': 'voice/ntemis/034.mp3',
  'Ελπίδα. Πάντα υπάρχει ελπίδα.': 'voice/ntemis/035.mp3',
  'Οι ψαράδες. Πριν και μετά το ταξίδι.': 'voice/ntemis/036.mp3',
  'Δείξε μας.': 'voice/ntemis/037.mp3',
  'Για λίγο ακόμα. Κοιτάξτε τον ήλιο.': 'voice/ntemis/038.mp3',
  'Κάθε πέτρα και μια οικογένεια που περίμενε.': 'voice/ntemis/039.mp3',
  'Μόλις μας έδωσε οδηγίες ένα φάντασμα.': 'voice/ntemis/040.mp3',
  'Αυτό δεν είναι τρομακτικό. Είναι γεμάτο ιστορίες.': 'voice/ntemis/041.mp3',
  'Δεν μπορώ να μιλήσω σε αυτό.': 'voice/ntemis/042.mp3',
  'Δεν ανοίγει.': 'voice/ntemis/043.mp3',
  'Δεν ξέρω πώς.': 'voice/ntemis/044.mp3',
  '«Σας περιμέναμε»... Ποιος μας περιμένει;': 'voice/ntemis/045.mp3',
  'Ντέμη! Τι κάνεις εδώ; Πάρε μια καρέκλα!': 'voice/stathis/001.mp3',
  'Ψάχνεις κάτι; Ρώτα τον Άθο στο Λιοτρίβι. Ξέρει τα πάντα για τις παλιές οικογένειες.': 'voice/stathis/002.mp3'
};

function playVoice(text) {
  voiceAudio.pause();
  voiceAudio.currentTime = 0;
  const src = VOICE_MAP[text];
  if (src) {
    voiceAudio.src = src;
    voiceAudio.play().catch(() => {});
  }
}

function stopVoice() {
  voiceAudio.pause();
  voiceAudio.currentTime = 0;
}

// ════════════════════════════════════════════════════════════
// DIALOGUE SYSTEM
// ════════════════════════════════════════════════════════════
function showDlg(lines, cb) {
  const filtered = lines.filter(l => l.t);
  if (!filtered.length) { if (cb) cb(); return; }
  state.dlg.queue = [...filtered];
  state.dlg.active = true;
  state.dlg.cb = cb || null;
  nextDlgLine();
}

function nextDlgLine() {
  if (!state.dlg.queue.length) { closeDlg(); return; }
  const l = state.dlg.queue.shift();
  state.dlg.speaker = l.s || '';
  state.dlg.text = l.t;
  state.dlg.displayed = '';
  state.dlg.charIdx = 0;
  state.dlg.timer = 0;
  playVoice(l.t);
}

function updateDlg(dt) {
  if (!state.dlg.active) return;
  if (state.dlg.charIdx < state.dlg.text.length) {
    state.dlg.timer += dt;
    while (state.dlg.timer >= 0.03 && state.dlg.charIdx < state.dlg.text.length) {
      state.dlg.timer -= 0.03;
      state.dlg.charIdx++;
      state.dlg.displayed = state.dlg.text.substring(0, state.dlg.charIdx);
    }
  }
}

function advanceDlg() {
  if (!state.dlg.active) return;
  if (state.dlg.charIdx < state.dlg.text.length) {
    // Skip typewriter
    state.dlg.charIdx = state.dlg.text.length;
    state.dlg.displayed = state.dlg.text;
  } else {
    nextDlgLine();
  }
}

function closeDlg() {
  state.dlg.active = false;
  state.dlg.queue = [];
  stopVoice();
  if (state.dlg.cb) { const cb = state.dlg.cb; state.dlg.cb = null; cb(); }
  checkEnd();
}

// ════════════════════════════════════════════════════════════
// SCRIPTED SEQUENCE ENGINE
// ════════════════════════════════════════════════════════════
function startSequence(steps) {
  state.seq.active = true;
  state.seq.steps = steps;
  state.seq.stepIdx = 0;
  state.seq.stepTimer = 0;
  executeStep();
}

function executeStep() {
  const seq = state.seq;
  if (seq.stepIdx >= seq.steps.length) { endSequence(); return; }
  const step = seq.steps[seq.stepIdx];
  seq.stepTimer = 0;

  switch (step.type) {
    case 'wait':
      break;
    case 'dialog':
      showDlg(step.lines, () => advanceSeqStep());
      break;
    case 'env':
      step._start = { darken: seq.env.darken, vignette: seq.env.vignette, spectral: seq.env.spectral };
      break;
    case 'move': {
      const target = npcChars[step.who] || chars[step.who];
      if (target) {
        step._startX = target.x;
        step._targetX = target.x + step.dx;
      }
      break;
    }
    case 'npc': {
      const npc = npcChars[step.who];
      if (npc) {
        if (step.dir !== undefined) npc.dir = step.dir;
        if (step.tilt !== undefined) npc.tilt = step.tilt;
        if (step.wave !== undefined) npc.wave = step.wave;
        if (step.visible !== undefined) npc.visible = step.visible;
      }
      advanceSeqStep();
      break;
    }
    case 'effect':
      if (step.effect === 'materialize') {
        seq.ghostMat.active = true;
        seq.ghostMat.progress = 0;
        seq.ghostMat.alpha = 0;
        seq.ghostMat.glowBlur = 30;
        initSwirlParticles();
      } else if (step.effect === 'fade_out') {
        seq.ghostMat.active = true;
        step._startAlpha = seq.ghostMat.alpha;
      } else if (step.effect === 'stone_glow') {
        seq.stoneGlow.active = true;
        seq.stoneGlow.progress = 0;
      } else if (step.effect === 'arm_raise') {
        // Arm raise is timer-based, handled in updateGhostEffect
      }
      break;
    case 'callback':
      if (step.fn) step.fn();
      advanceSeqStep();
      break;
  }
}

function advanceSeqStep() {
  state.seq.stepIdx++;
  if (state.seq.stepIdx < state.seq.steps.length) {
    executeStep();
  } else {
    endSequence();
  }
}

function endSequence() {
  state.seq.active = false;
  state.seq.steps = [];
  state.seq.stepIdx = 0;
  state.seq.ghostMat.active = false;
  state.seq.stoneGlow.active = false;
}

function updateSequence(dt) {
  if (!state.seq.active) return;
  const seq = state.seq;
  if (seq.stepIdx >= seq.steps.length) return;
  const step = seq.steps[seq.stepIdx];
  seq.stepTimer += dt;

  switch (step.type) {
    case 'wait':
      if (seq.stepTimer >= step.duration) advanceSeqStep();
      break;
    case 'env': {
      const t = Math.min(1, seq.stepTimer / step.duration);
      const e = easeInOutCubic(t);
      seq.env.darken = step._start.darken + (step.darken - step._start.darken) * e;
      seq.env.vignette = step._start.vignette + (step.vignette - step._start.vignette) * e;
      seq.env.spectral = step._start.spectral + (step.spectral - step._start.spectral) * e;
      if (t >= 1) advanceSeqStep();
      break;
    }
    case 'move': {
      const target = npcChars[step.who] || chars[step.who];
      if (target && step._startX !== undefined) {
        const t = Math.min(1, seq.stepTimer / step.duration);
        target.x = step._startX + (step._targetX - step._startX) * easeInOutCubic(t);
        if (step.dx > 0) target.dir = 1;
        else if (step.dx < 0) target.dir = -1;
        if (t >= 1) advanceSeqStep();
      } else {
        advanceSeqStep();
      }
      break;
    }
    case 'effect':
      updateGhostEffect(dt, step);
      break;
  }

  // Keep swirl particles animating between steps
  if (seq.ghostMat.active && step.type !== 'effect') {
    updateSwirlParticles(dt);
  }
}

// ════════════════════════════════════════════════════════════
// GHOST MATERIALIZATION EFFECTS
// ════════════════════════════════════════════════════════════
function initSwirlParticles() {
  const sp = state.seq.swirlParticles;
  sp.length = 0;
  const ghost = npcChars.ghost;
  for (let i = 0; i < 40; i++) {
    const angle = Math.random() * Math.PI * 2;
    const dist = 80 + Math.random() * 120;
    sp.push({
      angle, dist, startDist: dist,
      x: ghost.x + Math.cos(angle) * dist,
      y: ghost.y - 50 + Math.sin(angle) * dist * 0.5,
      size: 1 + Math.random() * 2.5,
      alpha: 0, maxAlpha: 0.4 + Math.random() * 0.4,
      speed: 0.5 + Math.random() * 1.5,
      phase: Math.random() * Math.PI * 2,
    });
  }
}

function updateSwirlParticles(dt) {
  const sp = state.seq.swirlParticles;
  const ghost = npcChars.ghost;
  for (const p of sp) {
    p.angle += dt * p.speed;
    p.x = ghost.x + Math.cos(p.angle) * p.dist;
    p.y = (ghost.y - 50) + Math.sin(p.angle) * p.dist * 0.5;
  }
}

function updateGhostEffect(dt, step) {
  const seq = state.seq;
  const t = Math.min(1, seq.stepTimer / step.duration);

  if (step.effect === 'materialize') {
    seq.ghostMat.progress = t;
    if (t < 0.6) {
      const ct = t / 0.6;
      for (const p of seq.swirlParticles) {
        p.dist = p.startDist * (1 - easeInOutCubic(ct) * 0.85);
        p.alpha = p.maxAlpha * Math.min(1, ct * 2);
      }
    }
    if (t >= 0.4) {
      const ft = (t - 0.4) / 0.6;
      seq.ghostMat.alpha = easeInOutCubic(ft) * 0.55;
      seq.ghostMat.glowBlur = 30 - easeInOutCubic(ft) * 18;
    }
    if (t >= 0.5) {
      const ft = (t - 0.5) / 0.5;
      for (const p of seq.swirlParticles) {
        p.alpha = p.maxAlpha * (1 - ft);
      }
    }
    updateSwirlParticles(dt);
    if (t >= 1) advanceSeqStep();
  } else if (step.effect === 'fade_out') {
    const startA = step._startAlpha || 0.55;
    seq.ghostMat.alpha = startA * (1 - easeInOutCubic(t));
    seq.ghostMat.glowBlur = 12 + easeInOutCubic(t) * 18;
    for (const p of seq.swirlParticles) {
      const fadeT = t < 0.3 ? t / 0.3 : 1 - (t - 0.3) / 0.7;
      p.alpha = p.maxAlpha * 0.5 * Math.max(0, fadeT);
    }
    updateSwirlParticles(dt);
    if (t >= 1) {
      seq.ghostMat.active = false;
      seq.ghostMat.alpha = 0;
      advanceSeqStep();
    }
  } else if (step.effect === 'stone_glow') {
    seq.stoneGlow.progress = t;
    if (t >= 1) {
      seq.stoneGlow.active = false;
      advanceSeqStep();
    }
  } else if (step.effect === 'arm_raise') {
    // Lerp ghost arm from 0 (down) to 1 (raised and pointing)
    npcChars.ghost.arm = easeInOutCubic(t);
    if (t >= 1) advanceSeqStep();
  }
}

function drawSwirlParticles() {
  const sp = state.seq.swirlParticles;
  for (const p of sp) {
    if (p.alpha <= 0) continue;
    ctx.save();
    ctx.globalAlpha = p.alpha;
    ctx.shadowColor = 'rgba(100,180,255,0.6)';
    ctx.shadowBlur = 4;
    const r = 150 + Math.sin(p.phase) * 50;
    ctx.fillStyle = `rgb(${r},${180 + Math.sin(p.phase + 1) * 40},255)`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

function drawStoneGlow() {
  if (!state.seq.stoneGlow.active) return;
  const t = state.seq.stoneGlow.progress;
  const pulse = Math.sin(t * Math.PI * 3) * 0.3 + 0.7;
  const alpha = Math.sin(t * Math.PI) * 0.5 * pulse;
  if (alpha <= 0) return;
  ctx.save();
  ctx.globalAlpha = alpha;
  const grad = ctx.createRadialGradient(460, 270, 0, 460, 270, 60);
  grad.addColorStop(0, 'rgba(80,220,100,0.6)');
  grad.addColorStop(0.5, 'rgba(50,180,80,0.3)');
  grad.addColorStop(1, 'rgba(30,100,50,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(400, 210, 120, 120);
  ctx.restore();
}

function drawGhostArm() {
  const ghost = npcChars.ghost;
  if (ghost.arm === undefined || ghost.arm < 0) return;
  if (ghost.scene !== state.scene) return;
  const arm = ghost.arm; // 0 = down, 1 = raised pointing
  const gx = ghost.x;
  const gy = ghost.y;

  const shoulderX = gx + ghost.dir * 10;
  const shoulderY = gy - 60;
  // Canvas: PI/2 = down, -PI/3 = up-right ~60°
  const elbowAngle = Math.PI * 0.5 - arm * (Math.PI * 0.5 + Math.PI / 3);
  const elbowX = shoulderX + Math.cos(elbowAngle) * 22 * ghost.dir;
  const elbowY = shoulderY + Math.sin(elbowAngle) * 22;
  const handAngle = elbowAngle - arm * 0.3;
  const handX = elbowX + Math.cos(handAngle) * 24 * ghost.dir;
  const handY = elbowY + Math.sin(handAngle) * 24;

  const alpha = state.seq.ghostMat.alpha || (ghost.visible ? 0.5 : 0);
  if (alpha <= 0) return;

  ctx.save();
  ctx.globalAlpha = alpha * 0.7;
  ctx.strokeStyle = 'rgba(170,210,240,0.8)';
  ctx.shadowColor = 'rgba(100,180,255,0.5)';
  ctx.shadowBlur = 10;
  ctx.lineWidth = 4;
  ctx.lineCap = 'round';
  // Arm as smooth curve
  ctx.beginPath();
  ctx.moveTo(shoulderX, shoulderY);
  ctx.quadraticCurveTo(elbowX, elbowY, handX, handY);
  ctx.stroke();

  // Subtle fingertip glow when mostly raised
  if (arm > 0.7) {
    const glowT = (arm - 0.7) / 0.3;
    ctx.globalAlpha = alpha * glowT * 0.5;
    const fg = ctx.createRadialGradient(handX, handY, 0, handX, handY, 10);
    fg.addColorStop(0, 'rgba(150,200,255,0.7)');
    fg.addColorStop(1, 'rgba(100,160,255,0)');
    ctx.fillStyle = fg;
    ctx.fillRect(handX - 10, handY - 10, 20, 20);
  }
  ctx.restore();
}

// ════════════════════════════════════════════════════════════
// GHOST SUMMONING SEQUENCE
// ════════════════════════════════════════════════════════════
function startGhostSequence() {
  startSequence([
    // Crossfade to eerie ghost music
    { type: 'callback', fn: () => {
      changeSceneMusic('_ghost');
    }},
    { type: 'env', duration: 1.5, darken: 0.35, vignette: 0.6, spectral: 0.8 },
    { type: 'dialog', lines: [{s:'',t:'Ο αέρας αλλάζει. Η θερμοκρασία πέφτει. Τα κυπαρίσσια σταματούν να κουνιούνται.'}] },
    { type: 'move', who: 'clio', dx: 25, duration: 0.8 },
    { type: 'move', who: 'ajax', dx: 20, duration: 0.8 },
    { type: 'dialog', lines: [{s:'ΚΛΕΙΩ',t:'Μπαμπά... η πέτρα λάμπει!'},{s:'ΑΙΑΣ',t:'Τι γίνεται; Γιατί σκοτείνιασε;'}] },
    { type: 'wait', duration: 1.0 },
    { type: 'effect', effect: 'materialize', duration: 3.0 },
    { type: 'npc', who: 'ghost', visible: true },
    { type: 'dialog', lines: [
      {s:'',t:'Μια φιγούρα υψώνεται πάνω από τον τάφο. Ψηλός, αυστηρός, με ναυτική στολή από άλλη εποχή.'},
      {s:'ΚΛΕΙΩ',t:'Ο... ο Καπετάν Βισβίκης;'},
      {s:'ΑΙΑΣ',t:'Μπαμπά, βλέπω μέσα από αυτόν!'},
    ]},
    { type: 'npc', who: 'ghost', dir: -1 },
    { type: 'wait', duration: 0.8 },
    { type: 'npc', who: 'ghost', dir: 1 },
    { type: 'wait', duration: 0.6 },
    // Ghost raises arm and points to church
    { type: 'callback', fn: () => { npcChars.ghost.arm = 0; }},
    { type: 'npc', who: 'ghost', dir: 1, tilt: -0.1 },
    { type: 'effect', effect: 'arm_raise', duration: 1.2 },
    { type: 'dialog', lines: [{s:'',t:'Το φάντασμα σηκώνει αργά το χέρι. Δείχνει... προς τον Άγιο Νικόλαο.'}] },
    { type: 'dialog', lines: [
      {s:'ΚΛΕΙΩ',t:'Ο χάρτης. Θέλει να βρούμε τον χάρτη.'},
      {s:'ΝΤΕΜΗΣ',t:'Στην εκκλησία; Τι κρύβεται εκεί;'},
    ]},
    { type: 'npc', who: 'ghost', tilt: 0, wave: 3 },
    { type: 'wait', duration: 1.0 },
    { type: 'npc', who: 'ghost', wave: 0 },
    { type: 'callback', fn: () => { npcChars.ghost.arm = -1; }},
    { type: 'effect', effect: 'fade_out', duration: 2.5 },
    { type: 'effect', effect: 'stone_glow', duration: 1.5 },
    { type: 'env', duration: 2.0, darken: 0, vignette: 0, spectral: 0 },
    // Crossfade back to graveyard music
    { type: 'callback', fn: () => {
      changeSceneMusic('graveyard');
    }},
    { type: 'dialog', lines: [
      {s:'ΑΙΑΣ',t:'Αυτό... αυτό μόλις έγινε. Δεν ονειρεύομαι.'},
      {s:'ΚΛΕΙΩ',t:'Περίμενε 120 χρόνια. Για κάποιον σαν εμάς.'},
      {s:'ΝΤΕΜΗΣ',t:'Στον Άγιο Νικόλαο. Τώρα.'},
    ]},
    { type: 'callback', fn: () => {
      const sc = scenes.graveyard;
      if (!sc.exits.find(e => e.target === 'church')) {
        sc.exits.push({ side: 'right', target: 'church', label: 'Αγ. Νικόλαος →' });
      }
      npcChars.ghost.visible = true;
    }},
  ]);
}

function drawDialogue() {
  if (!state.dlg.active) return;
  const boxH = 90;
  const boxY = GH - boxH;

  // Background
  ctx.save();
  ctx.globalAlpha = 0.92;
  ctx.fillStyle = '#0a0806';
  ctx.fillRect(0, boxY, GW, boxH);
  ctx.restore();

  // Top border
  ctx.fillStyle = '#D4A03C';
  ctx.fillRect(0, boxY, GW, 2);

  // Portrait — only show for named speakers
  const portSize = 56;
  const portX = 12;
  const portY = boxY + 8;
  const hasSpeaker = !!state.dlg.speaker;

  let textX;
  if (hasSpeaker) {
    ctx.strokeStyle = '#D4A03C';
    ctx.lineWidth = 2;
    ctx.strokeRect(portX, portY, portSize, portSize);
    ctx.fillStyle = '#1a1714';
    ctx.fillRect(portX + 1, portY + 1, portSize - 2, portSize - 2);

    const portImg = PORTRAITS[state.dlg.speaker];
    if (portImg && portImg.complete) {
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(portImg, portX + 2, portY + 2, portSize - 4, portSize - 4);
      ctx.imageSmoothingEnabled = false;
    } else {
      ctx.fillStyle = '#4a4a4a';
      ctx.font = '16px serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('?', portX + portSize/2, portY + portSize/2);
    }

    textX = portX + portSize + 12;

    ctx.fillStyle = '#D4A03C';
    ctx.font = '9px "Press Start 2P", monospace';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText(state.dlg.speaker, textX, portY + 2);
  } else {
    // Narration — no portrait box, full width
    textX = 16;
  }

  // Dialogue text with word wrapping
  ctx.fillStyle = hasSpeaker ? '#e8dcc8' : '#D4A03C';
  ctx.font = '8px "Press Start 2P", monospace';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  const maxW = GW - textX - 16;
  const lineH = 16;
  const startY = portY + (state.dlg.speaker ? 18 : 6);
  wrapText(state.dlg.displayed, textX, startY, maxW, lineH);

  // Continue indicator
  if (state.dlg.charIdx >= state.dlg.text.length) {
    const blink = Math.sin(state.tick * 0.12) > 0;
    if (blink) {
      ctx.fillStyle = '#4a4a4a';
      ctx.font = '8px "Press Start 2P", monospace';
      ctx.textAlign = 'right';
      ctx.fillText('▶', GW - 12, boxY + boxH - 14);
    }
  }
}

function wrapText(text, x, y, maxW, lineH) {
  const words = text.split(' ');
  let line = '';
  let curY = y;
  for (const word of words) {
    const test = line ? line + ' ' + word : word;
    const m = ctx.measureText(test);
    if (m.width > maxW && line) {
      ctx.fillText(line, x, curY);
      line = word;
      curY += lineH;
    } else {
      line = test;
    }
  }
  if (line) ctx.fillText(line, x, curY);
}

// ════════════════════════════════════════════════════════════
// VERB SYSTEM
// ════════════════════════════════════════════════════════════
const verbLabels = { look:'Κοίταξε', talk:'Μίλησε', open:'Άνοιξε', use:'Χρησιμοποίησε' };
// Verb fallbacks: "use" tries pick/push/close; "open" tries use
const verbFallbacks = { use: ['pick','push','close','open'], open: ['use'] };

function setVerb(v) {
  state.verb = v;
  document.querySelectorAll('.vb').forEach(b => b.classList.remove('on'));
  document.querySelector(`[data-v="${v}"]`)?.classList.add('on');
  updateActionLine();
}

function updateActionLine() {
  const al = document.getElementById('action-line');
  const obj = state.hoverObj;
  al.textContent = obj ? `${verbLabels[state.verb]} ${obj.label}` : (verbLabels[state.verb] || '');
}

function objClick(obj) {
  if (state.dlg.active) return;
  const objCenterX = obj.x + obj.w / 2;

  // Walk Ntemis to object, then execute verb
  startWalk('ntemis', objCenterX, () => {
    let d = obj.verbs[state.verb];
    // Verb fallback: "use" tries open/push/close if no direct match
    if (!d && verbFallbacks[state.verb]) {
      for (const fb of verbFallbacks[state.verb]) {
        if (obj.verbs[fb]) { d = obj.verbs[fb]; break; }
      }
    }
    if (!d) {
      const defs = {
        look:[{s:'',t:'Τίποτα ιδιαίτερο.'}],
        talk:[{s:'ΝΤΕΜΗΣ',t:'Δεν μπορώ να μιλήσω σε αυτό.'}],
        open:[{s:'ΝΤΕΜΗΣ',t:'Δεν ανοίγει.'}],
        use:[{s:'ΝΤΕΜΗΣ',t:'Δεν ξέρω πώς.'}],
      };
      if (defs[state.verb]?.length) showDlg(defs[state.verb]);
      return;
    }
    if (typeof d === 'string') { changeScene(d); return; }
    if (typeof d === 'function') d = d();
    if (Array.isArray(d) && d.length) showDlg(d);
  });
  familyFollow(objCenterX);
}

// ════════════════════════════════════════════════════════════
// INVENTORY
// ════════════════════════════════════════════════════════════
function addInv(item) {
  if (state.inv.find(i => i.id === item.id)) return;
  state.inv.push(item);
  renderInvUI();
}

function removeInv(id) {
  state.inv = state.inv.filter(i => i.id !== id);
  renderInvUI();
}

// Inventory item icons — pixel art drawn on mini canvases (52x52)
const INV_ICONS = {
  note: (c) => {
    // Rolled scroll with wax seal
    c.fillStyle='#c4a870'; c.fillRect(12,4,28,40);
    c.fillStyle='#d8c490'; c.fillRect(14,6,24,36);
    // Roll top
    c.fillStyle='#b09058'; c.fillRect(10,4,32,5);
    c.fillStyle='#c4a870';
    c.beginPath(); c.ellipse(10,7,3,4,0,0,Math.PI*2); c.fill();
    c.beginPath(); c.ellipse(42,7,3,4,0,0,Math.PI*2); c.fill();
    // Text lines
    c.fillStyle='#8a7a58';
    for(let y=14;y<38;y+=5) c.fillRect(18,y,18,2);
    // Wax seal
    c.fillStyle='#b03030'; c.beginPath(); c.arc(36,38,5,0,Math.PI*2); c.fill();
    c.fillStyle='#d04040'; c.beginPath(); c.arc(35,37,3,0,Math.PI*2); c.fill();
    // "Γ" on seal
    c.fillStyle='#e8c8c8'; c.font='bold 5px sans-serif'; c.textAlign='center'; c.textBaseline='middle';
    c.fillText('Γ',36,38);
  },
  compass: (c) => {
    // Brass compass body
    c.fillStyle='#8a6a30'; c.beginPath(); c.arc(26,26,18,0,Math.PI*2); c.fill();
    c.fillStyle='#b08838'; c.beginPath(); c.arc(26,26,16,0,Math.PI*2); c.fill();
    c.fillStyle='#1a1810'; c.beginPath(); c.arc(26,26,14,0,Math.PI*2); c.fill();
    // Compass rose
    c.fillStyle='#c03030'; c.beginPath(); c.moveTo(26,12); c.lineTo(28,26); c.lineTo(24,26); c.fill();
    c.fillStyle='#e0d0c0'; c.beginPath(); c.moveTo(26,40); c.lineTo(28,26); c.lineTo(24,26); c.fill();
    c.fillStyle='#607090'; c.beginPath(); c.moveTo(12,26); c.lineTo(26,24); c.lineTo(26,28); c.fill();
    c.fillStyle='#607090'; c.beginPath(); c.moveTo(40,26); c.lineTo(26,24); c.lineTo(26,28); c.fill();
    // Center pin
    c.fillStyle='#d4a03c'; c.beginPath(); c.arc(26,26,2,0,Math.PI*2); c.fill();
    // N marker
    c.fillStyle='#c03030'; c.font='bold 5px sans-serif'; c.textAlign='center'; c.fillText('N',26,11);
  },
  shell: (c) => {
    // Scallop shell
    c.fillStyle='#e8d0b0'; c.beginPath(); c.ellipse(26,28,16,12,0,0,Math.PI*2); c.fill();
    c.fillStyle='#d4b89c'; c.beginPath(); c.ellipse(26,30,14,10,0,0,Math.PI); c.fill();
    // Ridges
    c.strokeStyle='#a08060'; c.lineWidth=1.5;
    for(let i=0;i<7;i++){c.beginPath();c.moveTo(26,16);c.lineTo(12+i*5,40);c.stroke();}
    // Highlight
    c.fillStyle='rgba(255,255,255,0.2)'; c.beginPath(); c.ellipse(22,24,6,4,-.3,0,Math.PI*2); c.fill();
  },
  candle: (c) => {
    // Candlestick with flame
    c.fillStyle='#8a6a30'; c.fillRect(20,36,12,8); // base
    c.fillStyle='#a08038'; c.fillRect(22,34,8,4); // holder
    c.fillStyle='#e8dcc0'; c.fillRect(24,16,4,20); // wax body
    c.fillStyle='#d4c8a0'; c.fillRect(23,16,6,3); // wax top
    // Wick
    c.fillStyle='#2a2a2a'; c.fillRect(25,12,2,5);
    // Flame
    c.fillStyle='#d4a03c'; c.beginPath(); c.ellipse(26,10,5,8,0,0,Math.PI*2); c.fill();
    c.fillStyle='#f0d060'; c.beginPath(); c.ellipse(26,10,3,5,0,0,Math.PI*2); c.fill();
    c.fillStyle='#fff8e0'; c.beginPath(); c.ellipse(26,11,1,3,0,0,Math.PI*2); c.fill();
  },
  green_stone: (c) => {
    // Jade stone — smooth green gem with veins
    c.fillStyle='#1a4a2a'; c.beginPath(); c.moveTo(26,8); c.lineTo(40,20); c.lineTo(38,36);
    c.lineTo(14,36); c.lineTo(12,20); c.closePath(); c.fill();
    c.fillStyle='#2a7a3a'; c.beginPath(); c.moveTo(26,10); c.lineTo(38,21); c.lineTo(36,34);
    c.lineTo(16,34); c.lineTo(14,21); c.closePath(); c.fill();
    // Lighter face
    c.fillStyle='#3a9a4a'; c.beginPath(); c.moveTo(26,14); c.lineTo(34,22); c.lineTo(32,30);
    c.lineTo(20,30); c.lineTo(18,22); c.closePath(); c.fill();
    // Highlight
    c.fillStyle='rgba(180,255,200,0.4)'; c.beginPath(); c.ellipse(24,20,5,3,-0.3,0,Math.PI*2); c.fill();
    // Veins
    c.strokeStyle='rgba(20,80,30,0.3)'; c.lineWidth=0.8;
    c.beginPath(); c.moveTo(20,18); c.quadraticCurveTo(26,24,32,20); c.stroke();
    c.beginPath(); c.moveTo(22,28); c.quadraticCurveTo(28,25,34,28); c.stroke();
    // Inner glow
    c.fillStyle='rgba(100,255,150,0.15)'; c.beginPath(); c.ellipse(26,24,8,6,0,0,Math.PI*2); c.fill();
  },
  key: (c) => {
    // Ornate brass key
    c.fillStyle='#c49030'; c.strokeStyle='#8a6020'; c.lineWidth=1;
    // Bow (head)
    c.beginPath(); c.arc(16,20,8,0,Math.PI*2); c.fill(); c.stroke();
    c.fillStyle='#1a1208'; c.beginPath(); c.arc(16,20,4,0,Math.PI*2); c.fill();
    // Shaft
    c.fillStyle='#c49030'; c.fillRect(23,18,20,4);
    c.strokeStyle='#8a6020'; c.strokeRect(23,18,20,4);
    // Teeth
    c.fillStyle='#c49030';
    c.fillRect(38,22,3,6); c.fillRect(34,22,2,4); c.fillRect(42,18,2,4);
    c.strokeStyle='#8a6020';
    c.strokeRect(38,22,3,6); c.strokeRect(34,22,2,4);
  },
};

function renderInvUI() {
  const grid = document.getElementById('inv-grid');
  grid.innerHTML = '';
  for (const item of state.inv) {
    const slot = document.createElement('div');
    slot.className = 'inv-slot';
    slot.dataset.id = item.id;
    slot.onclick = () => invClick(item.id);
    if (INV_ICONS[item.id]) {
      const cvs = document.createElement('canvas');
      cvs.width = 52; cvs.height = 52;
      cvs.style.cssText = 'width:52px;height:52px;image-rendering:pixelated';
      INV_ICONS[item.id](cvs.getContext('2d'));
      slot.appendChild(cvs);
    } else {
      const txt = document.createElement('span');
      txt.className = 'inv-text';
      txt.textContent = item.label;
      slot.appendChild(txt);
    }
    slot.title = item.label;
    grid.appendChild(slot);
  }
}

function scrollInv(dir) {
  const grid = document.getElementById('inv-grid');
  grid.scrollLeft += dir * 50;
}

function invClick(id) {
  if (id === 'note' && state.verb === 'look') {
    showDlg([{s:'',t:'«Σας περιμέναμε. Ελάτε στο λιμάνι απόψε. Τραπέζι για τρεις. — Γ.»'},{s:'',t:'Το χαρτί μυρίζει θάλασσα. Παλιομοδίτικο γράψιμο.'}]);
  }
  document.querySelectorAll('.inv-slot').forEach(s => s.classList.remove('on'));
  document.querySelector(`[data-id="${id}"]`)?.classList.add('on');
}

// ════════════════════════════════════════════════════════════
// SCENE MANAGEMENT
// ════════════════════════════════════════════════════════════
function startScene(id) {
  const sc = scenes[id];
  state.scene = id;
  state.hoverObj = null;
  bgCachedScene = null; // invalidate background cache

  // Reset sequence environment (prevent bleed between scenes)
  state.seq.env.darken = 0;
  state.seq.env.vignette = 0;
  state.seq.env.spectral = 0;
  state.seq.swirlParticles.length = 0;
  state.seq.stoneGlow.active = false;

  document.getElementById('ui-panel').classList.add('on');
  document.getElementById('action-line').classList.add('on');

  // Position characters — snap to walkLine ground level
  for (const [who, pos] of Object.entries(sc.charPos)) {
    chars[who].x = pos.x;
    // Use walkLine ground Y if available, otherwise fallback to charPos.y
    chars[who].y = sc.walkLine ? getGroundY(id, pos.x) : pos.y;
    chars[who].walking = false;
    chars[who].visible = true;
    chars[who].fadeIn = 0; // start fade-in
    chars[who].dir = 1;
  }

  initParticles();
  initAmbientSound();
  startSceneAmbience(id);
  changeSceneMusic(id);

  // Entry dialogue (first visit only)
  if (!state.visited.has(id) && sc.entry) {
    state.visited.add(id);
    setTimeout(() => showDlg(sc.entry), 600);
  } else {
    state.visited.add(id);
    // Clio auto-comment on revisit (after a short delay)
    scheduleClio(id);
  }
}

// ── Clio Auto-Comments — spontaneous observations on scene entry ──
const clioComments = {
  exterior: [
    'Μπαμπά, η μπουκαμβίλια μεγάλωσε από χθες!',
    'Ακούω τζιτζίκια. Πόσο αγαπώ αυτόν τον ήχο.',
    'Κοίτα πώς λάμπει η θάλασσα.',
    'Μυρίζει πεύκο και αλάτι.',
  ],
  terrace: [
    'Θα μπορούσα να μείνω εδώ για πάντα.',
    'Κοίτα τα βουνά, μπαμπά!',
    'Βλέπω ένα καράβι στο βάθος.',
    'Ο αέρας εδώ πάνω είναι μαγικός.',
  ],
  kitchen: [
    'Η κουζίνα μυρίζει σαν το σπίτι του παππού.',
    'Μπαμπά, πεινάω...',
    'Κοίτα πόσα σκεύη! Κάποτε μαγείρευαν για πολλούς.',
    'Φαντάζομαι τον παππού να κάθεται εδώ.',
  ],
  port: [
    'Τα καΐκια κουνιούνται σαν να χορεύουν.',
    'Μπαμπά, μπορώ να πατήσω πάνω στα σχοινιά;',
    'Μυρίζει ψάρι και θαλασσινό αλάτι.',
    'Φαντάζομαι πώς ήταν γεμάτο καράβια κάποτε.',
  ],
  museum: [
    'Σσσ... πρέπει να είμαστε ήσυχοι εδώ μέσα;',
    'Πόσα μυστικά κρύβουν αυτά τα πλοία...',
    'Κοίτα τη χάρτα! Πόσα ταξίδια!',
  ],
  liotrivi: [
    'Μυρίζει ελιά. Λατρεύω αυτή τη μυρωδιά.',
    'Φαντάσου πόσα χέρια γύρισαν αυτή την πέτρα.',
  ],
  cave: [
    'Είναι σκοτεινά εδώ μέσα...',
    'Μπαμπά, κρατήσε με σφιχτά.',
    'Ακούω σταγόνες. Σαν να χτυπάει ρολόι.',
  ],
  windmill: [
    'Βλέπω ολόκληρο το Γαλαξίδι από εδώ πάνω!',
    'Ο αέρας θέλει να με πάρει!',
  ],
  graveyard: [
    'Κάθε πέτρα κι ένα ταξίδι...',
    'Είναι ήσυχα εδώ. Σαν να ακούω τη θάλασσα να τους νανουρίζει.',
  ],
  church: [
    'Τι ωραία εκκλησία...',
    'Μπαμπά, να ρίξω νόμισμα στο σιντριβάνι;',
  ],
  boat: [
    'Κουνιέται! Κρατήσου καλά, Αίαντα!',
    'Βλέπω το Γαλαξίδι από εδώ. Είναι τόσο μικρό...',
  ],
  treasure: [
    'Νιώθω ότι είμαστε κοντά...',
  ],
};

// Track which comments Clio has already said per scene
const clioSaid = {};
let clioTimer = null;

function scheduleClio(sceneId) {
  if (clioTimer) { clearTimeout(clioTimer); clioTimer = null; }
  const pool = clioComments[sceneId];
  if (!pool || pool.length === 0) return;
  if (!clioSaid[sceneId]) clioSaid[sceneId] = new Set();
  // Find unsaid comments
  const unsaid = pool.filter((_, i) => !clioSaid[sceneId].has(i));
  if (unsaid.length === 0) return; // all said, stay quiet
  // Pick a random unsaid comment
  const idx = pool.indexOf(unsaid[Math.floor(Math.random() * unsaid.length)]);
  clioSaid[sceneId].add(idx);
  // Delay: 3-5 seconds after scene loads, only if no dialog active
  const delay = 3000 + Math.random() * 2000;
  clioTimer = setTimeout(() => {
    clioTimer = null;
    if (state.dlg.active || state.scene !== sceneId) return;
    showDlg([{ s: 'ΚΛΕΙΩ', t: pool[idx] }]);
  }, delay);
}

function changeScene(id) {
  if (clioTimer) { clearTimeout(clioTimer); clioTimer = null; }
  // Iris wipe centered on Ntemis
  state.fade.active = true;
  state.fade.alpha = 0;
  state.fade.dir = 1; // iris close
  state.fade.mode = 'iris';
  state.fade.cx = chars.ntemis.x;
  state.fade.cy = chars.ntemis.y - 30; // chest height
  state.fade.cb = () => {
    startScene(id);
    state.fade.cx = chars.ntemis.x;
    state.fade.cy = chars.ntemis.y - 30;
    state.fade.dir = -1; // iris open
    state.fade.cb = () => { state.fade.active = false; state.fade.mode = null; };
  };
}

function checkEnd() {
  if (state.flags.note && !state.flags.done) {
    state.flags.done = 1;
    setTimeout(() => showDlg([
      {s:'ΝΤΕΜΗΣ',t:'«Σας περιμέναμε»... Ποιος μας περιμένει;'},
      {s:'ΚΛΕΙΩ',t:'Ο «Γ.» ξέρει ότι είμαστε τρεις. Πρέπει να πάμε.'},
      {s:'ΑΙΑΣ',t:'Πάμε στο λιμάνι!'},
      {s:'',t:'Ο ήλιος βυθίζεται πίσω από τα βουνά. Το λιμάνι περιμένει.'},
      {s:'',t:'— Τέλος Σκηνής 1 —'},
      {s:'',t:'Συνέχεια στη Σκηνή 2: Το Γράμμα...'},
    ]), 1500);
  }
}

// ════════════════════════════════════════════════════════════
// RENDER — Main drawing function
// ════════════════════════════════════════════════════════════
function render() {
  ctx.clearRect(0, 0, GW, GH);

  // Canvas-rendered title screen
  if (state.phase === 'title') {
    drawTitleScreen(state.tick);
    return;
  }

  if (state.phase === 'cutscene') {
    renderCutscene();
    return;
  }

  if (state.phase !== 'playing') return;
  if (!state.scene) return;

  const sc = scenes[state.scene];

  // Background + ambient overlay (cached — only redraws on scene change)
  if (bgCachedScene !== state.scene) {
    bgCtx.clearRect(0, 0, GW, GH);
    const bgImg = images[sc.bg];
    if (bgImg) {
      bgCtx.imageSmoothingEnabled = true;
      bgCtx.imageSmoothingQuality = 'high';
      bgCtx.drawImage(bgImg, 0, 0, GW, GH);
      bgCtx.imageSmoothingEnabled = false;
    } else {
      bgCtx.fillStyle = '#1a1510';
      bgCtx.fillRect(0, 0, GW, GH);
    }
    const grad = bgCtx.createLinearGradient(0, 0, 0, GH);
    grad.addColorStop(0, 'rgba(212,160,60,0.03)');
    grad.addColorStop(0.3, 'rgba(0,0,0,0)');
    grad.addColorStop(0.7, 'rgba(0,0,0,0)');
    grad.addColorStop(1, 'rgba(0,0,0,0.15)');
    bgCtx.fillStyle = grad;
    bgCtx.fillRect(0, 0, GW, GH);
    bgCachedScene = state.scene;
  }
  ctx.drawImage(bgBuffer, 0, 0);

  // Scene-specific ambience (behind characters)
  drawSceneAmbience(state.tick);

  // Dust particles
  drawParticles();

  // Hotspot shimmer hints — subtle sparkles on all interactive objects
  if (sc.objects) {
    const t = state.tick;
    for (let i = 0; i < sc.objects.length; i++) {
      const obj = sc.objects[i];
      if (obj === state.hoverObj) continue;
      const seed = (obj.x * 7 + obj.y * 13 + i * 31);
      const sparkleT = (t + seed) * 0.03;
      const alpha = Math.max(0, Math.sin(sparkleT) * 0.6 - 0.2);
      if (alpha > 0) {
        ctx.save();
        ctx.globalAlpha = alpha * 0.5;
        const sx = obj.x + (seed * 17 % obj.w);
        const sy = obj.y + (seed * 23 % obj.h);
        ctx.fillStyle = '#FFE8A0';
        ctx.beginPath();
        ctx.moveTo(sx, sy - 2); ctx.lineTo(sx + 0.7, sy);
        ctx.lineTo(sx, sy + 2); ctx.lineTo(sx - 0.7, sy);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }
  }

  // Hotspot highlight on hover — soft pulsing glow
  if (state.hoverObj && state.hoverObj.w) {
    const obj = state.hoverObj;
    const pulse = 0.35 + Math.sin(state.tick * 0.08) * 0.15;
    ctx.save();
    ctx.shadowColor = 'rgba(255,220,120,0.6)';
    ctx.shadowBlur = 6;
    ctx.strokeStyle = `rgba(212,160,60,${pulse})`;
    ctx.lineWidth = 1.5;
    const r = 3, hx = obj.x - 2, hy = obj.y - 2, hw = obj.w + 4, hh = obj.h + 4;
    ctx.beginPath();
    ctx.moveTo(hx + r, hy);
    ctx.lineTo(hx + hw - r, hy); ctx.arcTo(hx + hw, hy, hx + hw, hy + r, r);
    ctx.lineTo(hx + hw, hy + hh - r); ctx.arcTo(hx + hw, hy + hh, hx + hw - r, hy + hh, r);
    ctx.lineTo(hx + r, hy + hh); ctx.arcTo(hx, hy + hh, hx, hy + hh - r, r);
    ctx.lineTo(hx, hy + r); ctx.arcTo(hx, hy, hx + r, hy, r);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }

  // Exit zone highlights with pulsing arrow
  if (sc.exits) {
    const arrowPulse = 0.6 + Math.sin(state.tick * 0.06) * 0.4;
    const arrowBob = Math.sin(state.tick * 0.08) * 2;
    for (const exit of sc.exits) {
      const isHover = (exit.side === 'left' && state.mouseGX < 25) ||
                      (exit.side === 'right' && state.mouseGX > GW - 25);
      if (isHover) {
        ctx.save();
        const exGrad = exit.side === 'left'
          ? ctx.createLinearGradient(0, 0, 30, 0)
          : ctx.createLinearGradient(GW, 0, GW - 30, 0);
        exGrad.addColorStop(0, `rgba(212,160,60,${0.12 + arrowPulse * 0.08})`);
        exGrad.addColorStop(1, 'rgba(212,160,60,0)');
        ctx.fillStyle = exGrad;
        if (exit.side === 'left') ctx.fillRect(0, 0, 30, GH);
        else ctx.fillRect(GW - 30, 0, 30, GH);
        // Pulsing bobbing arrow
        ctx.globalAlpha = arrowPulse;
        ctx.fillStyle = '#FFE8A0';
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const ax = exit.side === 'left' ? 12 + arrowBob : GW - 12 - arrowBob;
        ctx.fillText(exit.side === 'left' ? '◀' : '▶', ax, GH / 2);
        ctx.restore();
      }
    }
  }

  // NPCs in current scene
  for (const npcId of Object.keys(npcChars)) {
    drawNPC(npcId, state.tick);
  }
  drawGhostArm();

  // Characters — back to front for depth
  drawCharacter('clio', state.tick);
  drawCharacter('ajax', state.tick);
  drawCharacter('ntemis', state.tick);

  // Scene label
  ctx.save();
  ctx.fillStyle = '#D4A03C';
  ctx.font = '8px "Press Start 2P", monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.shadowColor = '#000';
  ctx.shadowBlur = 4;
  ctx.shadowOffsetX = 2;
  ctx.shadowOffsetY = 2;
  ctx.fillText(sc.label, GW / 2, 8);
  ctx.restore();

  // Music toggle icon
  ctx.save();
  ctx.globalAlpha = state.musicOn ? 0.5 : 0.2;
  ctx.fillStyle = '#D4A03C';
  ctx.font = '14px sans-serif';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'top';
  ctx.fillText('♪', GW - 8, 8);
  ctx.restore();

  // ── Sequence overlays (between scene and dialogue) ──
  if (state.seq.env.darken > 0) {
    ctx.save();
    ctx.globalAlpha = state.seq.env.darken;
    ctx.fillStyle = '#0a0820'; // deep blue-black
    ctx.fillRect(0, 0, GW, GH);
    ctx.restore();
  }
  if (state.seq.env.vignette > 0) {
    ctx.save();
    ctx.globalAlpha = state.seq.env.vignette;
    const vig = ctx.createRadialGradient(GW / 2, GH / 2, GW * 0.25, GW / 2, GH / 2, GW * 0.6);
    vig.addColorStop(0, 'rgba(0,0,0,0)');
    vig.addColorStop(1, 'rgba(5,5,20,0.8)');
    ctx.fillStyle = vig;
    ctx.fillRect(0, 0, GW, GH);
    ctx.restore();
  }
  drawSwirlParticles();
  drawStoneGlow();

  // Dialogue overlay
  drawDialogue();

  // Transition overlay — iris wipe or flat fade
  if (state.fade.active && state.fade.alpha > 0) {
    ctx.save();
    if (state.fade.mode === 'iris') {
      // Iris wipe: circle shrinks/grows centered on character
      const maxR = Math.sqrt(GW * GW + GH * GH) * 0.6;
      const radius = maxR * (1 - state.fade.alpha);
      const cx = state.fade.cx || GW / 2;
      const cy = state.fade.cy || GH / 2;
      // Draw black everywhere except the circle
      ctx.beginPath();
      ctx.rect(0, 0, GW, GH);
      ctx.arc(cx, cy, Math.max(0, radius), 0, Math.PI * 2, true); // counter-clockwise = hole
      ctx.fillStyle = '#000';
      ctx.fill('evenodd');
    } else {
      ctx.globalAlpha = state.fade.alpha;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, GW, GH);
    }
    ctx.restore();
  }
}

// ════════════════════════════════════════════════════════════
// UPDATE — Main logic update
// ════════════════════════════════════════════════════════════
function update(dt) {
  state.tick++;

  // Title screen — start music on first interaction (handled by click)
  if (state.phase === 'title') return;
  if (state.phase === 'cutscene') { updateCutscene(dt); return; }
  if (state.phase !== 'playing') return;

  // Walking
  updateWalking(dt);

  // Character fade-in
  for (const who of ['ntemis','ajax','clio']) {
    if (chars[who].fadeIn < 1) {
      const delays = { ntemis: 0.1, ajax: 0.3, clio: 0.5 };
      if (state.tick > delays[who] * 60) {
        chars[who].fadeIn = Math.min(1, chars[who].fadeIn + dt * 1.5);
      }
    }
  }

  // Dialogue typewriter
  updateDlg(dt);

  // Scripted sequences
  updateSequence(dt);

  // Particles
  updateParticles();

  // Scene ambience (seagulls, petals, cat, sounds)
  updateSceneAmbience(dt);

  // Fade/iris transition
  if (state.fade.active) {
    const speed = state.fade.mode === 'iris' ? 1.5 : 2.0;
    state.fade.alpha += state.fade.dir * dt * speed;
    if (state.fade.dir > 0 && state.fade.alpha >= 1) {
      state.fade.alpha = 1;
      if (state.fade.cb) { const cb = state.fade.cb; state.fade.cb = null; cb(); }
    }
    if (state.fade.dir < 0 && state.fade.alpha <= 0) {
      state.fade.alpha = 0;
      if (state.fade.cb) { const cb = state.fade.cb; state.fade.cb = null; cb(); }
    }
  }
}

// ════════════════════════════════════════════════════════════
// GAME LOOP
// ════════════════════════════════════════════════════════════
let lastTime = 0;

function gameLoop(timestamp) {
  const dt = lastTime ? Math.min((timestamp - lastTime) / 1000, 0.05) : 0.016;
  lastTime = timestamp;

  // Resize canvas to fill available space
  const rect = CVS.getBoundingClientRect();
  // Keep internal resolution fixed, CSS handles scaling

  update(dt);
  render();
  requestAnimationFrame(gameLoop);
}

// ════════════════════════════════════════════════════════════
// INPUT HANDLING
// ════════════════════════════════════════════════════════════
CVS.addEventListener('mousemove', (e) => {
  const g = screenToGame(e.clientX, e.clientY);
  state.mouseGX = g.x;
  state.mouseGY = g.y;

  if (state.phase === 'title') {
    CVS.style.cursor = 'pointer';
    return;
  }

  if (state.phase !== 'playing' || state.dlg.active || state.seq.active) {
    CVS.style.cursor = (state.dlg.active || state.seq.active) ? 'pointer' : 'default';
    state.hoverObj = null;
    updateActionLine();
    return;
  }

  // Check hotspots
  const obj = hitTestObj(g.x, g.y);
  state.hoverObj = obj;

  // Check exits for cursor change
  const exit = hitTestExit(g.x, g.y);
  if (exit) {
    CVS.style.cursor = exit.side === 'left' ? 'w-resize' : 'e-resize';
    state.hoverObj = { label: exit.label }; // fake obj for action line
  } else if (obj) {
    // Verb-aware cursor
    const verbCursors = { look: 'zoom-in', talk: 'help', open: 'grab', use: 'pointer' };
    CVS.style.cursor = verbCursors[state.verb] || 'pointer';
  } else {
    CVS.style.cursor = g.y > 200 ? 'crosshair' : 'default';
  }
  updateActionLine();
});

CVS.addEventListener('click', (e) => {
  const g = screenToGame(e.clientX, e.clientY);

  // Cutscene: click speeds up dialogue typewriter
  if (state.phase === 'cutscene' && state.cutscene.active) {
    if (state.cutscene.dlgCharIdx < state.cutscene.dlgText.length) {
      state.cutscene.dlgDisplayed = state.cutscene.dlgText;
      state.cutscene.dlgCharIdx = state.cutscene.dlgText.length;
    }
    return;
  }

  // Title clicks handled by dedicated handler
  if (state.phase !== 'playing') return;

  // Dialogue advance
  if (state.dlg.active) { advanceDlg(); return; }

  // Block all interaction during sequences (dialog already handled above)
  if (state.seq.active) return;

  // Music toggle (top-right corner)
  if (g.x > GW - 30 && g.y < 25) { toggleMusic(); return; }

  // Check exit zones
  const exit = hitTestExit(g.x, g.y);
  if (exit) { changeScene(exit.target); return; }

  // Check hotspots
  const obj = hitTestObj(g.x, g.y);
  if (obj) { objClick(obj); return; }

  // Click ground — walk Ntemis (walkLine defines valid ground area)
  const sc = scenes[state.scene];
  if (sc && sc.walkLine && g.y > 200) {
    startWalk('ntemis', g.x);
    familyFollow(g.x);
  } else if (g.y > 200) {
    startWalk('ntemis', g.x);
    familyFollow(g.x);
  }
});

// Keyboard
document.addEventListener('keydown', e => {
  if (e.key === 'Escape' && state.phase === 'cutscene') { skipCutscene(); return; }
  if (e.key === ' ' || e.key === 'Enter') {
    e.preventDefault();
    if (state.dlg.active) advanceDlg();
  }
  const vk = {'1':'look','2':'talk','3':'open','4':'use'};
  if (vk[e.key] && state.phase === 'playing') setVerb(vk[e.key]);
  // DEBUG: Press G to warp to graveyard with green stone + Use verb active
  if (e.key === 'g' && !state.dlg.active) {
    if (state.phase !== 'playing') {
      state.phase = 'playing';
      document.getElementById('ui-panel').classList.add('on');
      document.getElementById('action-line').classList.add('on');
    }
    addInv({ id: 'green_stone', label: 'Πράσινη Πέτρα' });
    setVerb('use');
    startScene('graveyard');
  }
});

// ════════════════════════════════════════════════════════════
// MUSIC
// ════════════════════════════════════════════════════════════
const bgm = document.getElementById('bgm');
bgm.volume = 0.25;

// Per-scene music map
const sceneMusic = {
  exterior: 'music/arrival-at-galaxidi-scene-1-1.mp3',
  terrace:  'music/arrival-at-galaxidi-scene-1-1.mp3',
  kitchen:  'music/the-grandfather-s-house-1.mp3',
  port:     'music/the-harbor-at-dusk-1.mp3',
  museum:   'music/the-maritime-museum-1.mp3',
  liotrivi: 'music/the-old-olive-press-1.mp3',
  cave:     'music/the-cave-of-karkaros-1.mp3',
  graveyard:'music/the-captain-s-rest-1.mp3',
  church:   'music/the-map-in-the-church-1.mp3',
  boat:     'music/the-crossing-1.mp3',
  cave_final:'music/the-treasure-1.mp3',
  epilogue:  'music/the-sea-remembers-1.mp3',
  _ghost:    'music/the-ghost-of-captain-visvikis-1.mp3',
};

let currentMusicSrc = '';

function changeSceneMusic(sceneId) {
  const newSrc = sceneMusic[sceneId];
  if (!newSrc || newSrc === currentMusicSrc) return;
  // Crossfade: old out, new in
  const oldVol = bgm.volume;
  const fadeDur = 1500;
  const fadeStart = performance.now();
  const fadeOut = () => {
    const t = Math.min(1, (performance.now() - fadeStart) / fadeDur);
    bgm.volume = oldVol * (1 - t);
    if (t < 1) { requestAnimationFrame(fadeOut); return; }
    bgm.pause();
    bgm.src = newSrc;
    currentMusicSrc = newSrc;
    bgm.volume = 0;
    bgm.play().catch(() => {});
    // Fade in
    const fadeInStart = performance.now();
    const fadeIn = () => {
      const t2 = Math.min(1, (performance.now() - fadeInStart) / fadeDur);
      bgm.volume = 0.25 * t2;
      if (t2 < 1) requestAnimationFrame(fadeIn);
    };
    requestAnimationFrame(fadeIn);
  };
  requestAnimationFrame(fadeOut);
}

function toggleMusic() {
  if (state.musicOn) {
    bgm.pause(); state.musicOn = false;
  } else {
    bgm.play().catch(() => {}); state.musicOn = true;
  }
}

// ════════════════════════════════════════════════════════════
// TITLE SCREEN — Bright sunny harbor with animated title
// ════════════════════════════════════════════════════════════
const titleMusic = document.getElementById('title-music');
titleMusic.volume = 0.7;
let titleFadeOut = 0;
let titleStartTick = -1;

// Title text animation config
const titleLine1 = 'ΤΟ ΜΥΣΤΗΡΙΟ';
const titleLine2 = 'του';
const titleLine3 = 'ΓΑΛΑΞΕΙΔΙΟΥ';
const LETTER_DELAY = 4;
const LINE2_DELAY = 55;
const LINE3_DELAY = 25;
const PROMPT_DELAY = 70;

function drawTitleScreen(tick) {
  if (titleStartTick < 0) titleStartTick = tick;
  const elapsed = tick - titleStartTick;
  const t = tick * 0.02;

  // ═══════════════════════════════════════
  // BACKGROUND — cinematic zoom-out + animated water
  // Scanline displacement (Monkey Island / SNES technique)
  // ═══════════════════════════════════════
  const bg = images['title-bg'];
  const waterLine = Math.floor(GH * 0.80);

  // Zoom: starts at 1.12x, eases to 1.0x over ~400 ticks (~7 sec)
  const zoomDuration = 400;
  const zoomT = Math.min(1, elapsed / zoomDuration);
  const easeOut = 1 - Math.pow(1 - zoomT, 3);
  const zoom = 1.12 - 0.12 * easeOut;

  if (bg && bg.complete) {
    // Draw with zoom — sky + land above waterline (static)
    const srcWaterY = bg.naturalHeight * (waterLine / GH);
    ctx.save();
    ctx.translate(GW / 2, GH / 2);
    ctx.scale(zoom, zoom);
    ctx.translate(-GW / 2, -GH / 2);

    // Sky + land (smooth scaling to avoid dithered gradients)
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(bg,
      0, 0, bg.naturalWidth, srcWaterY,
      0, 0, GW, waterLine);
    ctx.imageSmoothingEnabled = false;

    // Water: per-scanline horizontal displacement for wave motion
    for (let y = waterLine; y < GH; y++) {
      const depth = (y - waterLine) / (GH - waterLine);
      const amp = 0.6 + depth * 1.8;
      const dx = Math.sin(y * 0.08 + t * 1.6) * amp
               + Math.sin(y * 0.13 - t * 1.0) * (amp * 0.4);
      const srcY = bg.naturalHeight * (y / GH);
      ctx.drawImage(bg,
        0, srcY, bg.naturalWidth, 1,
        dx, y, GW, 1);
    }
    ctx.restore();

    // Sun sparkles on the water
    for (let i = 0; i < 18; i++) {
      const sx = ((tick * 0.35 + i * 43) % GW);
      const sy = waterLine + 4 + ((i * 29) % (GH - waterLine - 8));
      const glint = Math.sin(tick * 0.09 + i * 2.3);
      if (glint > 0.55) {
        const a = (glint - 0.55) * 2.2;
        ctx.fillStyle = `rgba(255,255,240,${a * 0.45})`;
        ctx.fillRect(sx, sy, 2, 1);
        if (glint > 0.8) {
          ctx.fillRect(sx + 1, sy - 1, 1, 1);
          ctx.fillRect(sx + 1, sy + 1, 1, 1);
        }
      }
    }

    // ── Sun rays / god rays ──
    ctx.save();
    const rt = tick * 0.004;
    const lg = ctx.createLinearGradient(GW * 0.7, 0, GW * 0.2, GH * 0.5);
    lg.addColorStop(0, `rgba(255,220,120,${0.04 + Math.sin(rt) * 0.012})`);
    lg.addColorStop(0.5, `rgba(255,200,80,${0.015 + Math.sin(rt + 1) * 0.006})`);
    lg.addColorStop(1, 'rgba(255,200,80,0)');
    ctx.fillStyle = lg;
    ctx.fillRect(0, 0, GW, GH);
    ctx.fillStyle = '#FFD880';
    ctx.globalAlpha = 0.016 + Math.sin(rt * 0.8) * 0.005;
    ctx.beginPath();
    ctx.moveTo(GW * 0.65, 0); ctx.lineTo(GW * 0.25, GH * 0.6);
    ctx.lineTo(GW * 0.32, GH * 0.6); ctx.lineTo(GW * 0.72, 0);
    ctx.closePath(); ctx.fill();
    ctx.globalAlpha = 0.012 + Math.sin(rt * 0.6 + 1.5) * 0.004;
    ctx.beginPath();
    ctx.moveTo(GW * 0.78, 0); ctx.lineTo(GW * 0.45, GH * 0.5);
    ctx.lineTo(GW * 0.50, GH * 0.5); ctx.lineTo(GW * 0.83, 0);
    ctx.closePath(); ctx.fill();
    ctx.globalAlpha = 0.009 + Math.sin(rt * 0.5 + 3.0) * 0.003;
    ctx.beginPath();
    ctx.moveTo(GW * 0.55, 0); ctx.lineTo(GW * 0.10, GH * 0.7);
    ctx.lineTo(GW * 0.18, GH * 0.7); ctx.lineTo(GW * 0.60, 0);
    ctx.closePath(); ctx.fill();
    ctx.restore();

    // ── Seagulls — pixel birds flying across the sky ──
    const gulls = [
      { speed: 0.35, y0: 30, amp: 5, phase: 0 },
      { speed: 0.25, y0: 50, amp: 8, phase: 150 },
      { speed: 0.45, y0: 18, amp: 4, phase: 300 },
      { speed: 0.30, y0: 65, amp: 6, phase: 220 },
      { speed: 0.20, y0: 40, amp: 10, phase: 400 },
    ];
    for (const gull of gulls) {
      const cycle = GW + 100;
      const gx = ((tick * gull.speed + gull.phase * 2) % cycle) - 50;
      const gy = gull.y0 + Math.sin(t * 1.2 + gull.phase) * gull.amp;
      const wingFlap = Math.sin(tick * 0.15 + gull.phase) * 5;
      const gSize = 0.8 + gull.speed * 0.5;
      ctx.save();
      ctx.translate(gx, gy);
      ctx.scale(gSize, gSize);
      ctx.fillStyle = '#FFF';
      ctx.fillRect(-1, 0, 3, 2);
      ctx.strokeStyle = '#2A2A30';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-8, wingFlap); ctx.lineTo(-3, -1);
      ctx.lineTo(0, 1); ctx.lineTo(3, -1); ctx.lineTo(8, wingFlap);
      ctx.stroke();
      ctx.strokeStyle = 'rgba(255,255,255,0.7)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-7, wingFlap - 1); ctx.lineTo(-3, -2);
      ctx.moveTo(3, -2); ctx.lineTo(7, wingFlap - 1);
      ctx.stroke();
      ctx.restore();
    }

    // ── Tiny people strolling along the dock ──
    const walkers = [
      // Right dock / stone walkway
      { x0: 400, range: 45, speed: 0.06, y: 350, phase: 0,   shirt: '#9A3030', pants: '#4A4A56' },
      { x0: 480, range: 40, speed: -0.05, y: 353, phase: 80,  shirt: '#2858A0', pants: '#3A3A48' },
      { x0: 540, range: 30, speed: 0.07, y: 347, phase: 200, shirt: '#D09040', pants: '#484854' },
      // Harbor edge near boats (left side)
      { x0: 120, range: 30, speed: 0.04, y: 285, phase: 50,  shirt: '#7A4020', pants: '#3A3A48' },
      { x0: 220, range: 25, speed: -0.03, y: 288, phase: 160, shirt: '#308050', pants: '#484854' },
    ];
    ctx.globalAlpha = 0.8;
    for (const p of walkers) {
      const pcycle = p.range * 2;
      const raw = ((tick * Math.abs(p.speed) + p.phase) % pcycle);
      const wx = p.x0 + (raw < p.range ? raw : pcycle - raw);
      const dir = p.speed > 0 ? (raw < p.range ? 1 : -1) : (raw < p.range ? -1 : 1);
      const step = Math.floor(tick * Math.abs(p.speed) * 0.4 + p.phase) % 2;
      ctx.save();
      ctx.translate(Math.floor(wx), p.y);
      if (dir < 0) ctx.scale(-1, 1);
      // Head (3x2)
      ctx.fillStyle = '#D4AC80';
      ctx.fillRect(0, 0, 3, 2);
      // Hair
      ctx.fillStyle = '#5A3A20';
      ctx.fillRect(0, 0, 3, 1);
      // Torso (3x3)
      ctx.fillStyle = p.shirt;
      ctx.fillRect(0, 2, 3, 3);
      // Arms swinging
      const armSwing = step === 0 ? 1 : -1;
      ctx.fillRect(-1, 2 + armSwing, 1, 2);
      ctx.fillRect(3, 2 - armSwing, 1, 2);
      // Legs (2-frame walk)
      ctx.fillStyle = p.pants;
      if (step === 0) {
        ctx.fillRect(0, 5, 1, 3);
        ctx.fillRect(2, 5, 1, 2);
      } else {
        ctx.fillRect(0, 5, 1, 2);
        ctx.fillRect(2, 5, 1, 3);
      }
      // Shoes
      ctx.fillStyle = '#2A1A10';
      ctx.fillRect(0, step === 0 ? 8 : 7, 1, 1);
      ctx.fillRect(2, step === 0 ? 7 : 8, 1, 1);
      ctx.restore();
    }
    ctx.globalAlpha = 1;

    // ── Wind dust motes ──
    ctx.save();
    for (let i = 0; i < 15; i++) {
      const dx = ((tick * (0.15 + i * 0.03) + i * 47) % (GW + 20)) - 10;
      const baseY = 40 + (i * 53) % 280;
      const dy = baseY + Math.sin(tick * 0.012 + i * 1.7) * 8;
      const gustAlpha = 0.12 + Math.sin(tick * 0.008 + i * 2.1) * 0.08;
      if (gustAlpha > 0) {
        ctx.globalAlpha = gustAlpha;
        ctx.fillStyle = '#FFE8A0';
        ctx.fillRect(Math.floor(dx), Math.floor(dy), 1, 1);
      }
    }
    ctx.restore();

  } else {
    ctx.fillStyle = '#4A9FD8';
    ctx.fillRect(0, 0, GW, GH);
  }

  // Subtle vignette
  const vig = ctx.createRadialGradient(GW/2, GH/2, GW*0.3, GW/2, GH/2, GW*0.75);
  vig.addColorStop(0, 'rgba(0,0,0,0)');
  vig.addColorStop(1, 'rgba(0,0,0,0.12)');
  ctx.fillStyle = vig;
  ctx.fillRect(0, 0, GW, GH);

  // ═══════════════════════════════════════
  // ANIMATED TITLE — letters unfold cinematically
  // ═══════════════════════════════════════
  const l1N = titleLine1.length;
  const l1End = l1N * LETTER_DELAY;
  const l2Start = l1End + LINE2_DELAY;
  const l2End = l2Start + 15;
  const l3Start = l2End + LINE3_DELAY;
  const l3N = titleLine3.length;
  const l3End = l3Start + l3N * LETTER_DELAY;
  const promptAt = l3End + PROMPT_DELAY;

  ctx.save();
  ctx.textBaseline = 'middle';

  function drawLetter(ch, cx, cy, size, progress) {
    if (progress <= 0) return;
    const p = Math.min(1, progress);
    const scale = p < 0.5 ? 1.5 - p : 1.0 + Math.sin((p-0.5)*Math.PI)*0.05;
    const alpha = Math.min(1, p * 2);
    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(scale, scale);
    ctx.globalAlpha = alpha;
    ctx.font = `bold ${size}px "Press Start 2P", monospace`;
    ctx.textAlign = 'center';
    const shd = [['#060200',5],['#1A0804',4],['#2E1508',3],['#4A2010',2],['#7A5018',1]];
    for (const [c,d] of shd) { ctx.fillStyle = c; ctx.fillText(ch, d, d); }
    const g = 0.3 + Math.sin(t*1.2 + cx*0.01)*0.15;
    ctx.shadowColor = `rgba(255,180,40,${g*alpha})`;
    ctx.shadowBlur = 20;
    ctx.fillStyle = '#D4A03C';
    ctx.fillText(ch, 0, 0);
    ctx.shadowBlur = 0;
    ctx.fillStyle = `rgba(255,235,170,${0.35*alpha})`;
    ctx.fillText(ch, 0, -1);
    ctx.restore();
  }

  // Line 1: "ΤΟ ΜΥΣΤΗΡΙΟ"
  const l1Size = 36, l1Y = 100;
  ctx.font = `bold ${l1Size}px "Press Start 2P", monospace`;
  ctx.textAlign = 'left';
  const l1W = ctx.measureText(titleLine1).width;
  let l1X = (GW - l1W) / 2;
  for (let i = 0; i < l1N; i++) {
    const ch = titleLine1[i];
    const chW = ctx.measureText(ch).width;
    drawLetter(ch, l1X + chW/2, l1Y, l1Size, (elapsed - i*LETTER_DELAY)/20);
    l1X += chW;
  }

  // Line 2: "του"
  if (elapsed > l2Start) {
    const p2 = Math.min(1, (elapsed - l2Start) / 25);
    ctx.save();
    ctx.globalAlpha = p2;
    ctx.translate(GW/2, l1Y + 50);
    ctx.scale(1.3 - p2*0.3, 1.3 - p2*0.3);
    ctx.font = 'bold 14px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#1A0804'; ctx.fillText(titleLine2, 2, 2);
    ctx.fillStyle = '#B8842C'; ctx.fillText(titleLine2, 0, 0);
    ctx.restore();
  }

  // Line 3: "ΓΑΛΑΞΕΙΔΙΟΥ"
  const l3Size = 38, l3Y = l1Y + 102;
  ctx.font = `bold ${l3Size}px "Press Start 2P", monospace`;
  const l3W = ctx.measureText(titleLine3).width;
  let l3X = (GW - l3W) / 2;
  for (let i = 0; i < l3N; i++) {
    const ch = titleLine3[i];
    const chW = ctx.measureText(ch).width;
    drawLetter(ch, l3X + chW/2, l3Y, l3Size, (elapsed - l3Start - i*LETTER_DELAY)/20);
    l3X += chW;
  }
  ctx.restore();


  // Blinking start prompt
  if (elapsed > promptAt) {
    const blink = 0.2 + Math.sin(tick*0.06)*0.45;
    ctx.save();
    ctx.font = '8px "Press Start 2P", monospace';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.globalAlpha = Math.max(0, blink);
    ctx.fillStyle = '#D4A03C';
    ctx.shadowColor = 'rgba(212,160,60,0.5)'; ctx.shadowBlur = 10;
    ctx.fillText('► ΚΛΙΚ ΓΙΑ ΕΝΑΡΞΗ ◄', GW/2, GH - 35);
    ctx.restore();
  }

  // Fade overlay
  if (titleFadeOut > 0) {
    ctx.save();
    ctx.globalAlpha = titleFadeOut;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, GW, GH);
    ctx.restore();
  }
}



// ════════════════════════════════════════════════════════════
// TITLE & INTRO FLOW
// ════════════════════════════════════════════════════════════
let titleClicked = false;
let titleMusicStarted = false;

// Start title music on any user gesture (needed for autoplay policy)
function ensureTitleMusic() {
  if (!titleMusicStarted && state.phase === 'title') {
    titleMusic.currentTime = 0;
    const p = titleMusic.play();
    if (p) p.then(() => { titleMusicStarted = true; console.log('Title music playing'); }).catch(e => console.warn('Title music blocked:', e));
  }
}
// Try immediately + on any interaction
ensureTitleMusic();
document.addEventListener('click', ensureTitleMusic);
document.addEventListener('keydown', ensureTitleMusic);
document.addEventListener('touchstart', ensureTitleMusic);

CVS.addEventListener('click', function titleClickHandler(e) {
  if (state.phase !== 'title' || titleClicked) return;
  // First click just starts music — need a second click to proceed
  if (!titleMusicStarted) {
    ensureTitleMusic();
    return;
  }
  titleClicked = true;

  // Keep title music playing through intro — don't fade it here

  // Animate fade to black
  const fadeStep = () => {
    titleFadeOut += 0.02;
    if (titleFadeOut < 1) {
      requestAnimationFrame(fadeStep);
    } else {
      titleFadeOut = 1;
      // Switch to intro — title music keeps playing
      state.phase = 'intro';
      state.musicOn = true;
      const intro = document.getElementById('intro-screen');
      intro.classList.add('show');
      showIntroPage();
    }
  };
  requestAnimationFrame(fadeStep);
}, { once: false });

function showIntroPage() {
  const t = document.getElementById('intro-text');
  const h = document.getElementById('intro-hint');
  t.style.opacity = '0';
  h.classList.remove('on');
  setTimeout(() => {
    t.innerHTML = introPages[state.introPage].replace(/\n/g, '<br>');
    t.style.opacity = '1';
    setTimeout(() => h.classList.add('on'), 1200);
  }, 300);
}

document.getElementById('intro-screen').onclick = () => {
  state.introPage++;
  if (state.introPage >= introPages.length) {
    const is = document.getElementById('intro-screen');
    is.style.opacity = '0';

    // Keep title music playing through cutscene — dim slightly for cinematic feel
    const dimDur = 1500;
    const dimStart = performance.now();
    const dimStep = () => {
      const t = Math.min(1, (performance.now() - dimStart) / dimDur);
      const ease = t < 0.5 ? 4*t*t*t : 1-Math.pow(-2*t+2,3)/2;
      titleMusic.volume = 0.7 - ease * 0.3; // dim from 0.7 to 0.4
      if (t < 1) requestAnimationFrame(dimStep);
    };
    requestAnimationFrame(dimStep);

    setTimeout(() => {
      is.style.display = 'none';
      state.musicOn = true;
      startCutscene('arrival');
    }, 1500);
  } else {
    showIntroPage();
  }
};

// ════════════════════════════════════════════════════════════
// BOOT
// ════════════════════════════════════════════════════════════
loadAllAssets().then(() => {
  requestAnimationFrame(gameLoop);
});
</script>
</body>
</html>
