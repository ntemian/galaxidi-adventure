<!DOCTYPE html>
<html lang="el">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Η Θάλασσα Θυμάται — Canvas Engine</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
  body { background: #000; overflow: hidden; font-family: 'Press Start 2P', monospace; display: flex; flex-direction: column; height: 100vh; }

  /* ── CANVAS ── */
  #game-canvas {
    display: block; background: #0a0812;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    cursor: crosshair;
    flex: 1;
    width: 100%;
    min-height: 0;
  }

  /* ── ACTION LINE ── */
  #action-line {
    height: 22px; background: #12100e; display: none; align-items: center; justify-content: center;
    font-size: .55rem; color: #D4A03C; border-top: 2px solid #2a2218;
  }
  #action-line.on { display: flex; }

  /* ── UI PANEL — Classic SCUMM layout ── */
  #ui-panel {
    background: #0a0806;
    border-top: 2px solid #2a2218;
    display: none; flex-direction: column;
  }
  #ui-panel.on { display: flex; }

  /* Bottom row: verbs LEFT, inventory RIGHT */
  #ui-bottom {
    display: flex; height: 100px;
  }

  /* ── VERB GRID (left side, 2x2) ── */
  #verb-panel {
    display: grid; grid-template-columns: repeat(2, 1fr); grid-template-rows: repeat(2, 1fr);
    gap: 2px; padding: 4px; width: 240px; flex-shrink: 0;
  }
  .vb {
    font-family: 'Press Start 2P', monospace; font-size: .5rem; color: #8a7a60;
    background: #1a1610; border: 1px solid #2a2418;
    cursor: pointer; transition: all .1s;
    display: flex; align-items: center; justify-content: center;
    padding: 2px 4px; text-align: center;
  }
  .vb:hover { color: #D4A03C; border-color: #D4A03C; }
  .vb:active { transform: scale(.95); }
  .vb.on { color: #D4A03C; background: #221e18; border-color: #D4A03C; }

  /* ── INVENTORY GRID (right side) ── */
  #inv-panel {
    flex: 1; display: flex; align-items: center; padding: 4px;
    border-left: 2px solid #2a2218; gap: 0;
  }
  #inv-label { display: none; }
  #inv-arrows {
    display: flex; flex-direction: column; gap: 2px; padding: 0 2px; flex-shrink: 0;
  }
  #inv-arrows button {
    font-size: .7rem; color: #6a5a40; background: #1a1610; border: 1px solid #2a2418;
    cursor: pointer; padding: 4px 6px; line-height: 1;
  }
  #inv-arrows button:hover { color: #D4A03C; border-color: #D4A03C; }
  #inv-grid {
    flex: 1; display: grid;
    grid-template-columns: repeat(auto-fill, 46px);
    grid-template-rows: repeat(2, 46px);
    grid-auto-flow: column;
    gap: 2px; padding: 0 4px;
    overflow: hidden;
  }
  .inv-slot {
    width: 46px; height: 46px;
    background: #1a1610; border: 1px solid #2a2418;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; transition: all .1s;
  }
  .inv-slot:hover { border-color: #D4A03C; }
  .inv-slot.on { border-color: #D4A03C; background: #221e18; }
  .inv-slot .inv-text {
    font-family: 'Press Start 2P', monospace; font-size: .3rem; color: #8a7a60;
    text-align: center; line-height: 1.2;
  }

  /* ── TITLE (canvas-rendered, no HTML overlay) ── */
  @keyframes blink { 0%,100%{opacity:.3} 50%{opacity:.9} }

  /* ── INTRO OVERLAY ── */
  #intro-screen {
    position: fixed; inset: 0; background: #0a0812;
    display: none; flex-direction: column; align-items: center; justify-content: center;
    z-index: 1500; padding: 2rem; cursor: pointer; transition: opacity 1.5s;
  }
  #intro-screen.show { display: flex; }
  #intro-text { max-width:600px; font-size:clamp(.6rem,1.2vw,.8rem); color:#D4A03C; line-height:2.5; text-align:center; opacity:0; transition: opacity 1.5s; }
  #intro-hint { font-size:.5rem; color:#4a4a4a; margin-top:2rem; opacity:0; transition: opacity .5s; }
  #intro-hint.on { opacity:1; animation: blink 2s infinite; }

  /* ── FADE ── */
  #fade { position: fixed; inset: 0; background: #000; z-index: 3000; opacity: 0; pointer-events: none; transition: opacity .5s; }
  #fade.on { opacity: 1; }
</style>
</head>
<body>

<div id="fade"></div>

<!-- Title screen is canvas-rendered -->

<div id="intro-screen">
  <div id="intro-text"></div>
  <div id="intro-hint">▶ ΚΛΙΚ</div>
</div>

<canvas id="game-canvas" width="640" height="400"></canvas>

<div id="action-line"></div>

<div id="ui-panel">
  <div id="ui-bottom">
    <div id="verb-panel">
      <button class="vb on" data-v="look" onclick="setVerb('look')">Κοίταξε</button>
      <button class="vb" data-v="talk" onclick="setVerb('talk')">Μίλησε</button>
      <button class="vb" data-v="open" onclick="setVerb('open')">Άνοιξε</button>
      <button class="vb" data-v="use" onclick="setVerb('use')">Χρησιμοποίησε</button>
    </div>
    <div id="inv-panel">
      <div id="inv-arrows">
        <button onclick="scrollInv(-1)">▲</button>
        <button onclick="scrollInv(1)">▼</button>
      </div>
      <div id="inv-grid"></div>
    </div>
  </div>
</div>

<audio id="title-music" loop preload="auto"><source src="music/the-sea-remembers-title-theme-1.mp3" type="audio/mpeg"></audio>
<audio id="bgm" loop preload="auto"><source src="music/scene1-music.mp3" type="audio/mpeg"></audio>

<script>
// ════════════════════════════════════════════════════════════
// CANVAS ENGINE — Pure requestAnimationFrame game loop
// ════════════════════════════════════════════════════════════
const CVS = document.getElementById('game-canvas');
const ctx = CVS.getContext('2d');
const GW = 640, GH = 400; // internal game resolution
CVS.width = GW; CVS.height = GH;

// ════════════════════════════════════════════════════════════
// STATE
// ════════════════════════════════════════════════════════════
const state = {
  phase: 'title', // title, intro, playing
  scene: null,
  verb: 'look',
  inv: [],
  flags: {},
  visited: new Set(),
  tick: 0,
  mouseGX: 0, mouseGY: 0,
  hoverObj: null,
  musicOn: false,
  dlg: { active: false, queue: [], text: '', displayed: '', charIdx: 0, timer: 0, speaker: '', cb: null },
  fade: { active: false, alpha: 0, dir: 0, cb: null },
  introPage: 0,
};

// Characters
const chars = {
  ntemis: { x: 0, y: 0, dir: 1, walking: false, frame: 0, targetX: null, startX: 0, walkT: 0, walkDur: 0, visible: true, fadeIn: 0 },
  ajax:   { x: 0, y: 0, dir: 1, walking: false, frame: 0, targetX: null, startX: 0, walkT: 0, walkDur: 0, visible: true, fadeIn: 0 },
  clio:   { x: 0, y: 0, dir: 1, walking: false, frame: 0, targetX: null, startX: 0, walkT: 0, walkDur: 0, visible: true, fadeIn: 0 },
};
let walkDoneCallback = null;

// ════════════════════════════════════════════════════════════
// IMAGE LOADING
// ════════════════════════════════════════════════════════════
const images = {};
function loadImg(key, src) {
  return new Promise(resolve => {
    const img = new Image();
    img.onload = () => { images[key] = img; resolve(img); };
    img.onerror = () => { console.warn('Failed to load:', src); resolve(null); };
    img.src = src;
  });
}

// Character idle sprites
const CHAR_IMGS = {};
const WALK_FRAMES = { ntemis: [], ajax: [], clio: [] };
const PORTRAITS = {};

async function loadAllAssets() {
  // Backgrounds
  await Promise.all([
    loadImg('bg-exterior', 'assets/pixel-exterior.png'),
    loadImg('bg-terrace', 'assets/pixel-terrace.png'),
    loadImg('bg-kitchen', 'assets/pixel-kitchen.png'),
  ]);

  // Character idle sprites
  const charPromises = ['ntemis','ajax','clio'].map(id =>
    loadImg(`char-${id}`, `assets/char-${id}-final.png`).then(img => { CHAR_IMGS[id] = img; })
  );

  // Portraits
  const portPromises = [
    loadImg('port-ntemis', 'assets/portrait-ntemis.png').then(img => { PORTRAITS['ΝΤΕΜΗΣ'] = img; }),
    loadImg('port-ajax', 'assets/portrait-ajax.png').then(img => { PORTRAITS['ΑΙΑΣ'] = img; }),
    loadImg('port-clio', 'assets/portrait-clio.png').then(img => { PORTRAITS['ΚΛΕΙΩ'] = img; }),
  ];

  await Promise.all([...charPromises, ...portPromises]);

  // Walk frames from JSON
  try {
    const resp = await fetch('assets/walk-frames-b64.json');
    const data = await resp.json();
    for (const who of ['ntemis','ajax','clio']) {
      if (data[who]) {
        for (let i = 0; i < data[who].length; i++) {
          const img = new Image();
          img.src = 'data:image/png;base64,' + data[who][i];
          WALK_FRAMES[who].push(img);
        }
      }
    }
  } catch(e) { console.warn('Walk frames load failed:', e); }
}

// ════════════════════════════════════════════════════════════
// SCENES DATA
// ════════════════════════════════════════════════════════════
const scenes = {
  exterior: {
    label: 'ΤΟ ΣΠΙΤΙ — ΓΑΛΑΞΙΔΙ', bg: 'bg-exterior',
    charPos: {
      ntemis: { x: 290, y: 340 },
      ajax:   { x: 370, y: 348 },
      clio:   { x: 210, y: 348 },
    },
    objects: [
      { id:'door', x:115, y:100, w:70, h:120, label:'Πόρτα',
        verbs: { look:[{s:'',t:'Ξύλινη πόρτα βαμμένη μπλε. Το χρώμα του Αιγαίου.'}],
                 open:[{s:'ΝΤΕΜΗΣ',t:'Ας μπούμε μέσα.'}], walk:'kitchen', use:'kitchen' }},
      { id:'bougainvillea', x:175, y:20, w:150, h:120, label:'Μπουκαμβίλιες',
        verbs: { look:[{s:'',t:'Ροζ μπουκαμβίλιες σκαρφαλώνουν στον τοίχο. Εδώ το καλοκαίρι αρνείται να φύγει.'}],
                 pick:[{s:'ΚΛΕΙΩ',t:'Μπαμπά, μην τις κόβεις! Είναι τέλειες έτσι.'}] }},
      { id:'flowerpots', x:75, y:195, w:65, h:55, label:'Γλάστρες',
        verbs: { look:[{s:'',t:'Πήλινες γλάστρες με βασιλικό. Κάποιος τα περιποιείται ακόμα κι όταν το σπίτι μένει κλειστό.'}] }},
      { id:'barrel', x:245, y:180, w:55, h:60, label:'Βαρέλι',
        verbs: { look:[{s:'',t:'Ένα παλιό ξύλινο βαρέλι. Μυρίζει κρασί και αλμύρα.'}],
                 open:[{s:'ΑΙΑΣ',t:'Άδειο. Κρίμα!'}] }},
      { id:'boats', x:380, y:120, w:140, h:80, label:'Ψαροκάικα',
        verbs: { look:[{s:'',t:'Χρωματιστά ψαροκάικα δεμένα στο λιμάνι. Κουνιούνται αργά στο απογευματινό φως.'},{s:'ΑΙΑΣ',t:'Μπαμπά, θα πάμε βόλτα με βάρκα;'}] }},
      { id:'sea', x:350, y:60, w:230, h:60, label:'Η θάλασσα',
        verbs: { look:[{s:'',t:'Ο Κορινθιακός κόλπος λάμπει χρυσαφί στο ηλιοβασίλεμα. Μαγικό.'}] }},
    ],
    exits: [{ side:'right', target:'terrace', label:'Βεράντα →' }],
    entry: [
      {s:'',t:'Ο ήλιος βάφει χρυσά τα καλντερίμια. Μυρωδιά πεύκου ανακατεμένη με θαλασσινό αλάτι.'},
      {s:'ΝΤΕΜΗΣ',t:'Φτάσαμε, παιδιά. Αυτό είναι το σπίτι μας για το Σαββατοκύριακο.'},
      {s:'ΑΙΑΣ',t:'Τέλειο! Πάμε κατευθείαν στο λιμάνι;'},
      {s:'ΚΛΕΙΩ',t:'Πρώτα ας αφήσουμε τις βαλίτσες. Θέλω να δω τη βεράντα.'},
    ],
  },
  terrace: {
    label: 'Η ΒΕΡΑΝΤΑ', bg: 'bg-terrace',
    charPos: {
      ntemis: { x: 320, y: 345 },
      ajax:   { x: 420, y: 350 },
      clio:   { x: 225, y: 350 },
    },
    objects: [
      { id:'harbor', x:140, y:120, w:280, h:100, label:'Το λιμάνι',
        verbs: { look:()=>{
          if(!state.flags.dolphins){state.flags.dolphins=1;return[
            {s:'',t:'Ο Κορινθιακός λάμπει σαν λιωμένο χρυσάφι. Ψαροκάικα κουνιούνται αργά στο λιμάνι.'},
            {s:'ΚΛΕΙΩ',t:'Μπαμπά, κοίτα! Δελφίνια!'},
            {s:'',t:'Τρία δελφίνια κόβουν βόλτες στο λιμάνι.'},
            {s:'ΑΙΑΣ',t:'Δελφίνια μέσα στο λιμάνι; Αυτό δεν είναι συνηθισμένο...'}];}
          return[{s:'',t:'Τα δελφίνια συνεχίζουν τους κύκλους τους. Σαν να φυλάνε κάτι.'}];}}},
      { id:'rooftops', x:30, y:80, w:130, h:100, label:'Σκεπές',
        verbs: { look:[{s:'',t:'Κεραμίδια, σκεπές, καμινάδες. Κάθε σπίτι κι ένας καπετάνιος κάποτε.'}] }},
      { id:'mountains', x:250, y:12, w:300, h:80, label:'Παρνασσός',
        verbs: { look:[{s:'',t:'Ο Παρνασσός στο βάθος. Οι Δελφοί κάπου εκεί πάνω.'},{s:'ΚΛΕΙΩ',t:'Οι Αμφικτίονες ξεκινούσαν από τους Δελφούς... Το Γαλαξίδι ήταν λιμάνι τους.'}] }},
      { id:'balustrade', x:90, y:240, w:370, h:40, label:'Κάγκελο',
        verbs: { look:[{s:'',t:'Πέτρινο κάγκελο με θέα ολόκληρο το Γαλαξίδι. Θα μπορούσες να κάτσεις εδώ ώρες.'}],
                 push:[{s:'ΚΛΕΙΩ',t:'Μπαμπά, μην ακουμπάς, φαίνεται παλιό!'}] }},
      { id:'flowerpot', x:10, y:220, w:65, h:60, label:'Γλάστρα',
        verbs: { look:[{s:'',t:'Γεράνια σε πήλινη γλάστρα. Τα χρώματα λάμπουν στο ηλιοβασίλεμα.'}] }},
    ],
    exits: [{ side:'left', target:'exterior', label:'← Σπίτι' }],
    entry: [
      {s:'',t:'Η θέα κόβει την ανάσα.'},
      {s:'ΚΛΕΙΩ',t:'Αυτό είναι το πιο όμορφο μέρος στον κόσμο.'},
      {s:'ΝΤΕΜΗΣ',t:'Καλωσορίσατε στο Γαλαξίδι.'},
    ],
  },
  kitchen: {
    label: 'Η ΚΟΥΖΙΝΑ', bg: 'bg-kitchen',
    charPos: {
      ntemis: { x: 350, y: 340 },
      ajax:   { x: 450, y: 345 },
      clio:   { x: 100, y: 345 },
    },
    objects: [
      { id:'figs', x:180, y:175, w:100, h:55, label:'Σύκα',
        verbs: { look:[{s:'',t:'Φρέσκα σύκα σε πήλινο μπολ. Η μυρωδιά γεμίζει το δωμάτιο.'}],
                 pick:[{s:'ΑΙΑΣ',t:'Μπαμπά, μπορώ να φάω ένα;'},{s:'ΝΤΕΜΗΣ',t:'Φυσικά.'}],
                 use:[{s:'',t:'Τρως ένα σύκο. Γλυκό σαν μέλι.'}] }},
      { id:'satchel', x:340, y:168, w:80, h:85, label:'Δερμάτινη τσάντα',
        verbs: {
          look:()=>{if(!state.flags.note)return[{s:'',t:'Μια παλιά δερμάτινη τσάντα πάνω στην καρέκλα. Δεν είναι δική σας.'},{s:'ΚΛΕΙΩ',t:'Μπαμπά, κοίτα — υπάρχει κάτι μέσα.'}];return[{s:'',t:'Η τσάντα είναι άδεια τώρα.'}];},
          open:()=>{if(!state.flags.note){state.flags.note=1;addInv({id:'note',label:'Σημείωμα'});return[{s:'',t:'Ανοίγεις την τσάντα. Μέσα βρίσκεις ένα σημείωμα.'},{s:'ΚΛΕΙΩ',t:'Διάβασέ το!'},{s:'',t:'«Σας περιμέναμε. Ελάτε στο λιμάνι απόψε. Τραπέζι για τρεις. — Γ.»'},{s:'ΑΙΑΣ',t:'Ποιος είναι ο «Γ.»;'},{s:'ΝΤΕΜΗΣ',t:'Και πώς ξέρει ότι είμαστε τρεις;'}];}return[{s:'',t:'Η τσάντα είναι πλέον άδεια.'}];},
          pick:[{s:'ΝΤΕΜΗΣ',t:'Δεν είναι δική μας. Ας κοιτάξω μέσα πρώτα.'}] }},
      { id:'window', x:455, y:50, w:95, h:115, label:'Παράθυρο',
        verbs: { look:[{s:'',t:'Απογευματινό φως μέσα από γαλάζια πατζούρια. Σκιές χορεύουν στον τοίχο.'}],
                 open:[{s:'',t:'Ανοίγεις τα πατζούρια. Μυρωδιά θυμαριού και τζιτζίκια.'}] }},
      { id:'pots', x:150, y:35, w:240, h:65, label:'Χάλκινα σκεύη',
        verbs: { look:[{s:'',t:'Χάλκινα σκεύη κρεμασμένα στον τοίχο. Κάποτε τάιζαν οικογένειες ναυτικών.'}] }},
      { id:'fireplace', x:0, y:75, w:95, h:145, label:'Τζάκι',
        verbs: { look:[{s:'',t:'Πέτρινο τζάκι. Μέσα υπάρχουν ακόμα στάχτες από τον τελευταίο χειμώνα.'}] }},
    ],
    exits: [{ side:'left', target:'exterior', label:'← Έξω' }],
    entry: [
      {s:'',t:'Η κουζίνα μυρίζει θυμάρι και παλιό ξύλο.'},
      {s:'ΚΛΕΙΩ',t:'Κοιτάξτε — κάποιος μας άφησε σύκα!'},
      {s:'ΑΙΑΣ',t:'Και κάτι πάνω στην καρέκλα... μια τσάντα;'},
    ],
  },
};

// ════════════════════════════════════════════════════════════
// INTRO PAGES
// ════════════════════════════════════════════════════════════
const introPages = [
  'Γαλαξίδι.\nΤέλη Σεπτεμβρίου, 2026.',
  'Ένα μικρό λιμάνι\nστον Κορινθιακό κόλπο.\n\nΕκεί που κάποτε ξεκινούσαν\nτα πιο τολμηρά καράβια\nτης Ελλάδας.',
  'Ο Ντέμης έφτασε\nμε τα δυο του παιδιά\nγια ένα ήσυχο\nΣαββατοκύριακο.\n\nΤουλάχιστον,\nαυτό νόμιζε.',
];

// ════════════════════════════════════════════════════════════
// EASING
// ════════════════════════════════════════════════════════════
function easeInOutCubic(t) { return t < .5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3)/2; }

// ════════════════════════════════════════════════════════════
// COORDINATE CONVERSION
// ════════════════════════════════════════════════════════════
function screenToGame(sx, sy) {
  const rect = CVS.getBoundingClientRect();
  const scaleX = GW / rect.width;
  const scaleY = GH / rect.height;
  return { x: (sx - rect.left) * scaleX, y: (sy - rect.top) * scaleY };
}

// ════════════════════════════════════════════════════════════
// DUST PARTICLES (canvas-drawn)
// ════════════════════════════════════════════════════════════
const particles = [];
function initParticles() {
  particles.length = 0;
  for (let i = 0; i < 20; i++) {
    particles.push({
      x: Math.random() * GW,
      y: 60 + Math.random() * 240,
      vx: 0.1 + Math.random() * 0.25,
      vy: -0.05 - Math.random() * 0.12,
      size: 0.8 + Math.random() * 1.8,
      alpha: 0,
      maxAlpha: 0.12 + Math.random() * 0.18,
      life: Math.random() * 700,
      maxLife: 500 + Math.random() * 400,
    });
  }
}

function updateParticles() {
  for (const p of particles) {
    p.x += p.vx;
    p.y += p.vy;
    p.life++;
    const prog = p.life / p.maxLife;
    if (prog < 0.3) p.alpha = p.maxAlpha * (prog / 0.3) * (prog / 0.3); // quadratic fade-in
    else if (prog > 0.7) { const f = (prog - 0.7) / 0.3; p.alpha = p.maxAlpha * (1 - f * f); } // quadratic fade-out
    else p.alpha = p.maxAlpha;
    if (p.life >= p.maxLife || p.x > GW + 10 || p.y < -10) {
      p.x = -5 + Math.random() * 20;
      p.y = 80 + Math.random() * 200;
      p.life = 0;
      p.alpha = 0;
    }
  }
}

function drawParticles() {
  for (const p of particles) {
    if (p.alpha <= 0) continue;
    ctx.save();
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = '#D4A03C';
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

// ════════════════════════════════════════════════════════════
// CHARACTER RENDERING (ported from Galaxidi Adventure)
// ════════════════════════════════════════════════════════════
const CHAR_HEIGHTS = { ntemis: 118, ajax: 84, clio: 92 };

// Per-character anatomy: waist split ratio & max leg stride (pixels)
const WALK_ANATOMY = {
  ntemis: { waist: 0.62, stride: 7 },
  ajax:   { waist: 0.58, stride: 6 },
  clio:   { waist: 0.60, stride: 6 },
};

function drawSprite(who, gx, gy, dir, walking, frame, tick, frameOffset) {
  const img = CHAR_IMGS[who];
  if (!img || !img.complete || !img.naturalWidth) {
    drawFallbackPerson(gx, gy, who);
    return;
  }
  const sprW = img.naturalWidth;
  const sprH = img.naturalHeight;
  const anat = WALK_ANATOMY[who] || { waist: 0.60, stride: 6 };

  if (walking) {
    // ── WALK PHASE ──
    const walkPhase = frame * Math.PI * 3 + frameOffset * Math.PI / 3;
    const bob = -Math.abs(Math.sin(walkPhase)) * 3;
    const lean = dir * 0.025;
    const strideDir = Math.sin(walkPhase); // -1 to 1

    const waistY = Math.floor(sprH * anat.waist);
    const legH = sprH - waistY;
    const maxStride = anat.stride;

    // Ground shadow (stretches with stride)
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = '#4A3A28';
    const sw = sprW * 0.6 + Math.abs(strideDir) * 3;
    ctx.beginPath();
    ctx.ellipse(gx, gy + 3, sw, 3.5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.translate(gx, gy + bob);
    if (dir < 0) ctx.scale(-1, 1);
    ctx.rotate(lean);

    // ── UPPER BODY (slight counter-sway) ──
    const counterSway = -strideDir * 1.5;
    ctx.drawImage(img,
      0, 0, sprW, waistY,
      -sprW/2 + counterSway, -sprH, sprW, waistY
    );

    // ── BACK LEG (drawn first, darker, shifted opposite, lifted) ──
    const bandH = 2;
    ctx.save();
    ctx.globalAlpha = 0.7;
    for (let y = 0; y < legH; y += bandH) {
      const progress = y / Math.max(1, legH - 1);
      const backOff = -strideDir * maxStride * 0.7 * (0.3 + 0.7 * progress);
      const lift = Math.abs(strideDir) * 3 * progress;
      const h = Math.min(bandH, legH - y);
      ctx.drawImage(img,
        0, waistY + y, sprW, h,
        -sprW/2 + backOff, -sprH + waistY + y - lift, sprW, h
      );
    }
    ctx.restore();

    // ── FRONT LEG (on top, full brightness, shifted forward) ──
    for (let y = 0; y < legH; y += bandH) {
      const progress = y / Math.max(1, legH - 1);
      const frontOff = strideDir * maxStride * (0.3 + 0.7 * progress);
      const h = Math.min(bandH, legH - y);
      ctx.drawImage(img,
        0, waistY + y, sprW, h,
        -sprW/2 + frontOff, -sprH + waistY + y, sprW, h
      );
    }

    ctx.restore();

  } else {
    // ── IDLE ANIMATION ──
    const bp = tick * 0.03 + frameOffset * 3;
    const breathe = Math.sin(bp) * 1.0 + Math.sin(bp * 0.6 + 0.5) * 0.4;
    const sway = Math.sin(tick * 0.01 + frameOffset * 2.5) * 0.008
               + Math.sin(tick * 0.023 + frameOffset) * 0.003;
    const bc = Math.sin(bp);
    const squashX = 1 + bc * 0.005;
    const squashY = 1 - bc * 0.005;

    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = '#4A3A28';
    ctx.beginPath();
    ctx.ellipse(gx, gy + 3, sprW * 0.6, 4, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.translate(gx, gy + breathe);
    if (dir < 0) ctx.scale(-1, 1);
    ctx.rotate(sway);
    ctx.scale(squashX, squashY);
    ctx.drawImage(img, -sprW/2, -sprH);
    ctx.restore();
  }
}

function drawFallbackPerson(x, y, who) {
  const colors = {
    ntemis: { shirt: '#2A4466', pants: '#1a2a3a', skin: '#DDAA88' },
    ajax:   { shirt: '#4A6644', pants: '#2a3a2a', skin: '#DDBB99' },
    clio:   { shirt: '#664466', pants: '#3a2a3a', skin: '#DDC0A0' },
  };
  const c = colors[who] || colors.ntemis;
  const h = who === 'ntemis' ? 40 : 32;
  // Simple rectangle person
  ctx.fillStyle = c.skin;
  ctx.fillRect(x - 4, y - h, 8, 10); // head
  ctx.fillStyle = c.shirt;
  ctx.fillRect(x - 6, y - h + 10, 12, 14); // body
  ctx.fillStyle = c.pants;
  ctx.fillRect(x - 5, y - h + 24, 10, h - 24); // legs
}

function drawCharacter(who, tick) {
  const c = chars[who];
  if (!c.visible) return;
  const offsets = { ntemis: 0, ajax: 1.05, clio: 2.1 };
  // Fade-in alpha with smoothstep
  let alpha = Math.min(1, c.fadeIn);
  if (alpha < 1) {
    alpha = alpha * alpha * (3 - 2 * alpha); // smoothstep
    ctx.save();
    ctx.globalAlpha = alpha;
  }
  drawSprite(who, c.x, c.y, c.dir, c.walking, c.frame, tick, offsets[who]);
  if (alpha < 1) ctx.restore();
}

// ════════════════════════════════════════════════════════════
// WALKING SYSTEM
// ════════════════════════════════════════════════════════════
function startWalk(who, targetX, cb) {
  const c = chars[who];
  const dist = Math.abs(targetX - c.x);
  if (dist < 5) { if (cb) cb(); return; }
  targetX = Math.max(30, Math.min(GW - 30, targetX));
  c.dir = targetX > c.x ? 1 : -1;
  c.walking = true;
  c.startX = c.x;
  c.targetX = targetX;
  c.walkT = 0;
  c.walkDur = Math.max(0.4, Math.min(2.0, (dist / GW) * 2.5));
  c.frame = 0;
  walkDoneCallback = cb;
}

function updateWalking(dt) {
  for (const who of ['ntemis','ajax','clio']) {
    const c = chars[who];
    if (!c.walking) continue;
    c.walkT += dt;
    const p = Math.min(1, c.walkT / c.walkDur);
    const ep = easeInOutCubic(p);
    c.x = c.startX + (c.targetX - c.startX) * ep;

    // Store raw walk time for smooth interpolation in drawSprite
    c.frame = c.walkT;

    if (p >= 1) {
      c.x = c.targetX;
      c.walking = false;
      c.targetX = null;
      c.dir = 1;
      if (who === 'ntemis' && walkDoneCallback) {
        const cb = walkDoneCallback;
        walkDoneCallback = null;
        cb();
      }
    }
  }
}

// Family follow: Ajax and Clio follow Ntemis with offset
function familyFollow(targetX) {
  const nX = targetX;
  // Ajax follows to the right, Clio to the left
  const ajaxTarget = Math.min(GW - 30, nX + 70);
  const clioTarget = Math.max(30, nX - 70);
  setTimeout(() => startWalk('ajax', ajaxTarget), 150);
  setTimeout(() => startWalk('clio', clioTarget), 280);
}

// ════════════════════════════════════════════════════════════
// HOTSPOT HIT TESTING
// ════════════════════════════════════════════════════════════
function hitTestObj(gx, gy) {
  if (!state.scene) return null;
  const sc = scenes[state.scene];
  for (const obj of sc.objects) {
    if (gx >= obj.x && gx <= obj.x + obj.w && gy >= obj.y && gy <= obj.y + obj.h) {
      return obj;
    }
  }
  return null;
}

function hitTestExit(gx, gy) {
  if (!state.scene) return null;
  const sc = scenes[state.scene];
  if (!sc.exits) return null;
  for (const exit of sc.exits) {
    if (exit.side === 'left' && gx < 25) return exit;
    if (exit.side === 'right' && gx > GW - 25) return exit;
  }
  return null;
}

// ════════════════════════════════════════════════════════════
// DIALOGUE SYSTEM
// ════════════════════════════════════════════════════════════
function showDlg(lines, cb) {
  const filtered = lines.filter(l => l.t);
  if (!filtered.length) { if (cb) cb(); return; }
  state.dlg.queue = [...filtered];
  state.dlg.active = true;
  state.dlg.cb = cb || null;
  nextDlgLine();
}

function nextDlgLine() {
  if (!state.dlg.queue.length) { closeDlg(); return; }
  const l = state.dlg.queue.shift();
  state.dlg.speaker = l.s || '';
  state.dlg.text = l.t;
  state.dlg.displayed = '';
  state.dlg.charIdx = 0;
  state.dlg.timer = 0;
}

function updateDlg(dt) {
  if (!state.dlg.active) return;
  if (state.dlg.charIdx < state.dlg.text.length) {
    state.dlg.timer += dt;
    while (state.dlg.timer >= 0.03 && state.dlg.charIdx < state.dlg.text.length) {
      state.dlg.timer -= 0.03;
      state.dlg.charIdx++;
      state.dlg.displayed = state.dlg.text.substring(0, state.dlg.charIdx);
    }
  }
}

function advanceDlg() {
  if (!state.dlg.active) return;
  if (state.dlg.charIdx < state.dlg.text.length) {
    // Skip typewriter
    state.dlg.charIdx = state.dlg.text.length;
    state.dlg.displayed = state.dlg.text;
  } else {
    nextDlgLine();
  }
}

function closeDlg() {
  state.dlg.active = false;
  state.dlg.queue = [];
  if (state.dlg.cb) { const cb = state.dlg.cb; state.dlg.cb = null; cb(); }
  checkEnd();
}

function drawDialogue() {
  if (!state.dlg.active) return;
  const boxH = 90;
  const boxY = GH - boxH;

  // Background
  ctx.save();
  ctx.globalAlpha = 0.92;
  ctx.fillStyle = '#0a0806';
  ctx.fillRect(0, boxY, GW, boxH);
  ctx.restore();

  // Top border
  ctx.fillStyle = '#D4A03C';
  ctx.fillRect(0, boxY, GW, 2);

  // Portrait — only show for named speakers
  const portSize = 56;
  const portX = 12;
  const portY = boxY + 8;
  const hasSpeaker = !!state.dlg.speaker;

  let textX;
  if (hasSpeaker) {
    ctx.strokeStyle = '#D4A03C';
    ctx.lineWidth = 2;
    ctx.strokeRect(portX, portY, portSize, portSize);
    ctx.fillStyle = '#1a1714';
    ctx.fillRect(portX + 1, portY + 1, portSize - 2, portSize - 2);

    const portImg = PORTRAITS[state.dlg.speaker];
    if (portImg && portImg.complete) {
      ctx.drawImage(portImg, portX + 2, portY + 2, portSize - 4, portSize - 4);
    } else {
      ctx.fillStyle = '#4a4a4a';
      ctx.font = '16px serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('?', portX + portSize/2, portY + portSize/2);
    }

    textX = portX + portSize + 12;

    ctx.fillStyle = '#D4A03C';
    ctx.font = '9px "Press Start 2P", monospace';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText(state.dlg.speaker, textX, portY + 2);
  } else {
    // Narration — no portrait box, full width
    textX = 16;
  }

  // Dialogue text with word wrapping
  ctx.fillStyle = hasSpeaker ? '#e8dcc8' : '#D4A03C';
  ctx.font = '8px "Press Start 2P", monospace';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  const maxW = GW - textX - 16;
  const lineH = 16;
  const startY = portY + (state.dlg.speaker ? 18 : 6);
  wrapText(state.dlg.displayed, textX, startY, maxW, lineH);

  // Continue indicator
  if (state.dlg.charIdx >= state.dlg.text.length) {
    const blink = Math.sin(state.tick * 0.12) > 0;
    if (blink) {
      ctx.fillStyle = '#4a4a4a';
      ctx.font = '8px "Press Start 2P", monospace';
      ctx.textAlign = 'right';
      ctx.fillText('▶', GW - 12, boxY + boxH - 14);
    }
  }
}

function wrapText(text, x, y, maxW, lineH) {
  const words = text.split(' ');
  let line = '';
  let curY = y;
  for (const word of words) {
    const test = line ? line + ' ' + word : word;
    const m = ctx.measureText(test);
    if (m.width > maxW && line) {
      ctx.fillText(line, x, curY);
      line = word;
      curY += lineH;
    } else {
      line = test;
    }
  }
  if (line) ctx.fillText(line, x, curY);
}

// ════════════════════════════════════════════════════════════
// VERB SYSTEM
// ════════════════════════════════════════════════════════════
const verbLabels = { look:'Κοίταξε', talk:'Μίλησε', open:'Άνοιξε', use:'Χρησιμοποίησε' };
// Verb fallbacks: "use" tries pick/push/close; "open" tries use
const verbFallbacks = { use: ['pick','push','close','open'], open: ['use'] };

function setVerb(v) {
  state.verb = v;
  document.querySelectorAll('.vb').forEach(b => b.classList.remove('on'));
  document.querySelector(`[data-v="${v}"]`)?.classList.add('on');
  updateActionLine();
}

function updateActionLine() {
  const al = document.getElementById('action-line');
  const obj = state.hoverObj;
  al.textContent = obj ? `${verbLabels[state.verb]} ${obj.label}` : (verbLabels[state.verb] || '');
}

function objClick(obj) {
  if (state.dlg.active) return;
  const objCenterX = obj.x + obj.w / 2;

  // Walk Ntemis to object, then execute verb
  startWalk('ntemis', objCenterX, () => {
    let d = obj.verbs[state.verb];
    // Verb fallback: "use" tries open/push/close if no direct match
    if (!d && verbFallbacks[state.verb]) {
      for (const fb of verbFallbacks[state.verb]) {
        if (obj.verbs[fb]) { d = obj.verbs[fb]; break; }
      }
    }
    if (!d) {
      const defs = {
        look:[{s:'',t:'Τίποτα ιδιαίτερο.'}],
        talk:[{s:'ΝΤΕΜΗΣ',t:'Δεν μπορώ να μιλήσω σε αυτό.'}],
        open:[{s:'ΝΤΕΜΗΣ',t:'Δεν ανοίγει.'}],
        use:[{s:'ΝΤΕΜΗΣ',t:'Δεν ξέρω πώς.'}],
      };
      if (defs[state.verb]?.length) showDlg(defs[state.verb]);
      return;
    }
    if (typeof d === 'string') { changeScene(d); return; }
    if (typeof d === 'function') d = d();
    if (Array.isArray(d) && d.length) showDlg(d);
  });
  familyFollow(objCenterX);
}

// ════════════════════════════════════════════════════════════
// INVENTORY
// ════════════════════════════════════════════════════════════
function addInv(item) {
  if (state.inv.find(i => i.id === item.id)) return;
  state.inv.push(item);
  renderInvUI();
}

// Inventory item icons — pixel art drawn on mini canvases (52x52)
const INV_ICONS = {
  note: (c) => {
    // Rolled scroll with wax seal
    c.fillStyle='#c4a870'; c.fillRect(12,4,28,40);
    c.fillStyle='#d8c490'; c.fillRect(14,6,24,36);
    // Roll top
    c.fillStyle='#b09058'; c.fillRect(10,4,32,5);
    c.fillStyle='#c4a870';
    c.beginPath(); c.ellipse(10,7,3,4,0,0,Math.PI*2); c.fill();
    c.beginPath(); c.ellipse(42,7,3,4,0,0,Math.PI*2); c.fill();
    // Text lines
    c.fillStyle='#8a7a58';
    for(let y=14;y<38;y+=5) c.fillRect(18,y,18,2);
    // Wax seal
    c.fillStyle='#b03030'; c.beginPath(); c.arc(36,38,5,0,Math.PI*2); c.fill();
    c.fillStyle='#d04040'; c.beginPath(); c.arc(35,37,3,0,Math.PI*2); c.fill();
    // "Γ" on seal
    c.fillStyle='#e8c8c8'; c.font='bold 5px sans-serif'; c.textAlign='center'; c.textBaseline='middle';
    c.fillText('Γ',36,38);
  },
  compass: (c) => {
    // Brass compass body
    c.fillStyle='#8a6a30'; c.beginPath(); c.arc(26,26,18,0,Math.PI*2); c.fill();
    c.fillStyle='#b08838'; c.beginPath(); c.arc(26,26,16,0,Math.PI*2); c.fill();
    c.fillStyle='#1a1810'; c.beginPath(); c.arc(26,26,14,0,Math.PI*2); c.fill();
    // Compass rose
    c.fillStyle='#c03030'; c.beginPath(); c.moveTo(26,12); c.lineTo(28,26); c.lineTo(24,26); c.fill();
    c.fillStyle='#e0d0c0'; c.beginPath(); c.moveTo(26,40); c.lineTo(28,26); c.lineTo(24,26); c.fill();
    c.fillStyle='#607090'; c.beginPath(); c.moveTo(12,26); c.lineTo(26,24); c.lineTo(26,28); c.fill();
    c.fillStyle='#607090'; c.beginPath(); c.moveTo(40,26); c.lineTo(26,24); c.lineTo(26,28); c.fill();
    // Center pin
    c.fillStyle='#d4a03c'; c.beginPath(); c.arc(26,26,2,0,Math.PI*2); c.fill();
    // N marker
    c.fillStyle='#c03030'; c.font='bold 5px sans-serif'; c.textAlign='center'; c.fillText('N',26,11);
  },
  shell: (c) => {
    // Scallop shell
    c.fillStyle='#e8d0b0'; c.beginPath(); c.ellipse(26,28,16,12,0,0,Math.PI*2); c.fill();
    c.fillStyle='#d4b89c'; c.beginPath(); c.ellipse(26,30,14,10,0,0,Math.PI); c.fill();
    // Ridges
    c.strokeStyle='#a08060'; c.lineWidth=1.5;
    for(let i=0;i<7;i++){c.beginPath();c.moveTo(26,16);c.lineTo(12+i*5,40);c.stroke();}
    // Highlight
    c.fillStyle='rgba(255,255,255,0.2)'; c.beginPath(); c.ellipse(22,24,6,4,-.3,0,Math.PI*2); c.fill();
  },
  candle: (c) => {
    // Candlestick with flame
    c.fillStyle='#8a6a30'; c.fillRect(20,36,12,8); // base
    c.fillStyle='#a08038'; c.fillRect(22,34,8,4); // holder
    c.fillStyle='#e8dcc0'; c.fillRect(24,16,4,20); // wax body
    c.fillStyle='#d4c8a0'; c.fillRect(23,16,6,3); // wax top
    // Wick
    c.fillStyle='#2a2a2a'; c.fillRect(25,12,2,5);
    // Flame
    c.fillStyle='#d4a03c'; c.beginPath(); c.ellipse(26,10,5,8,0,0,Math.PI*2); c.fill();
    c.fillStyle='#f0d060'; c.beginPath(); c.ellipse(26,10,3,5,0,0,Math.PI*2); c.fill();
    c.fillStyle='#fff8e0'; c.beginPath(); c.ellipse(26,11,1,3,0,0,Math.PI*2); c.fill();
  },
  key: (c) => {
    // Ornate brass key
    c.fillStyle='#c49030'; c.strokeStyle='#8a6020'; c.lineWidth=1;
    // Bow (head)
    c.beginPath(); c.arc(16,20,8,0,Math.PI*2); c.fill(); c.stroke();
    c.fillStyle='#1a1208'; c.beginPath(); c.arc(16,20,4,0,Math.PI*2); c.fill();
    // Shaft
    c.fillStyle='#c49030'; c.fillRect(23,18,20,4);
    c.strokeStyle='#8a6020'; c.strokeRect(23,18,20,4);
    // Teeth
    c.fillStyle='#c49030';
    c.fillRect(38,22,3,6); c.fillRect(34,22,2,4); c.fillRect(42,18,2,4);
    c.strokeStyle='#8a6020';
    c.strokeRect(38,22,3,6); c.strokeRect(34,22,2,4);
  },
};

function renderInvUI() {
  const grid = document.getElementById('inv-grid');
  grid.innerHTML = '';
  for (const item of state.inv) {
    const slot = document.createElement('div');
    slot.className = 'inv-slot';
    slot.dataset.id = item.id;
    slot.onclick = () => invClick(item.id);
    if (INV_ICONS[item.id]) {
      const cvs = document.createElement('canvas');
      cvs.width = 42; cvs.height = 42;
      cvs.style.cssText = 'width:42px;height:42px;image-rendering:pixelated';
      INV_ICONS[item.id](cvs.getContext('2d'));
      slot.appendChild(cvs);
    } else {
      const txt = document.createElement('span');
      txt.className = 'inv-text';
      txt.textContent = item.label;
      slot.appendChild(txt);
    }
    slot.title = item.label;
    grid.appendChild(slot);
  }
}

function scrollInv(dir) {
  const grid = document.getElementById('inv-grid');
  grid.scrollLeft += dir * 50;
}

function invClick(id) {
  if (id === 'note' && state.verb === 'look') {
    showDlg([{s:'',t:'«Σας περιμέναμε. Ελάτε στο λιμάνι απόψε. Τραπέζι για τρεις. — Γ.»'},{s:'',t:'Το χαρτί μυρίζει θάλασσα. Παλιομοδίτικο γράψιμο.'}]);
  }
  document.querySelectorAll('.inv-slot').forEach(s => s.classList.remove('on'));
  document.querySelector(`[data-id="${id}"]`)?.classList.add('on');
}

// ════════════════════════════════════════════════════════════
// SCENE MANAGEMENT
// ════════════════════════════════════════════════════════════
function startScene(id) {
  const sc = scenes[id];
  state.scene = id;
  state.hoverObj = null;

  document.getElementById('ui-panel').classList.add('on');
  document.getElementById('action-line').classList.add('on');

  // Position characters
  for (const [who, pos] of Object.entries(sc.charPos)) {
    chars[who].x = pos.x;
    chars[who].y = pos.y;
    chars[who].walking = false;
    chars[who].visible = true;
    chars[who].fadeIn = 0; // start fade-in
    chars[who].dir = 1;
  }

  initParticles();

  // Entry dialogue
  if (!state.visited.has(id) && sc.entry) {
    state.visited.add(id);
    setTimeout(() => showDlg(sc.entry), 600);
  } else {
    state.visited.add(id);
  }
}

function changeScene(id) {
  state.fade.active = true;
  state.fade.alpha = 0;
  state.fade.dir = 1; // fade out
  state.fade.cb = () => {
    startScene(id);
    state.fade.dir = -1; // fade in
    state.fade.cb = () => { state.fade.active = false; };
  };
}

function checkEnd() {
  if (state.flags.note && !state.flags.done) {
    state.flags.done = 1;
    setTimeout(() => showDlg([
      {s:'ΝΤΕΜΗΣ',t:'«Σας περιμέναμε»... Ποιος μας περιμένει;'},
      {s:'ΚΛΕΙΩ',t:'Ο «Γ.» ξέρει ότι είμαστε τρεις. Πρέπει να πάμε.'},
      {s:'ΑΙΑΣ',t:'Πάμε στο λιμάνι!'},
      {s:'',t:'Ο ήλιος βυθίζεται πίσω από τα βουνά. Το λιμάνι περιμένει.'},
      {s:'',t:'— Τέλος Σκηνής 1 —'},
      {s:'',t:'Συνέχεια στη Σκηνή 2: Το Γράμμα...'},
    ]), 1500);
  }
}

// ════════════════════════════════════════════════════════════
// RENDER — Main drawing function
// ════════════════════════════════════════════════════════════
function render() {
  ctx.clearRect(0, 0, GW, GH);

  // Canvas-rendered title screen
  if (state.phase === 'title') {
    drawTitleScreen(state.tick);
    return;
  }

  if (state.phase !== 'playing') return;
  if (!state.scene) return;

  const sc = scenes[state.scene];

  // Background
  const bgImg = images[sc.bg];
  if (bgImg) {
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(bgImg, 0, 0, GW, GH);
  } else {
    ctx.fillStyle = '#1a1510';
    ctx.fillRect(0, 0, GW, GH);
  }

  // Ambient overlay
  const grad = ctx.createLinearGradient(0, 0, 0, GH);
  grad.addColorStop(0, 'rgba(212,160,60,0.03)');
  grad.addColorStop(0.3, 'rgba(0,0,0,0)');
  grad.addColorStop(0.7, 'rgba(0,0,0,0)');
  grad.addColorStop(1, 'rgba(0,0,0,0.15)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, GW, GH);

  // Dust particles
  drawParticles();

  // Hotspot highlight on hover
  if (state.hoverObj) {
    const obj = state.hoverObj;
    ctx.save();
    ctx.strokeStyle = 'rgba(212,160,60,0.4)';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
    ctx.setLineDash([]);
    ctx.restore();
  }

  // Exit zone highlights
  if (sc.exits) {
    for (const exit of sc.exits) {
      const isHover = (exit.side === 'left' && state.mouseGX < 25) ||
                      (exit.side === 'right' && state.mouseGX > GW - 25);
      if (isHover) {
        ctx.save();
        const exGrad = exit.side === 'left'
          ? ctx.createLinearGradient(0, 0, 25, 0)
          : ctx.createLinearGradient(GW, 0, GW - 25, 0);
        exGrad.addColorStop(0, 'rgba(212,160,60,0.15)');
        exGrad.addColorStop(1, 'rgba(212,160,60,0)');
        ctx.fillStyle = exGrad;
        if (exit.side === 'left') ctx.fillRect(0, 0, 25, GH);
        else ctx.fillRect(GW - 25, 0, 25, GH);
        // Arrow
        ctx.fillStyle = '#D4A03C';
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        if (exit.side === 'left') ctx.fillText('◀', 12, GH / 2);
        else ctx.fillText('▶', GW - 12, GH / 2);
        ctx.restore();
      }
    }
  }

  // Characters — back to front for depth
  drawCharacter('clio', state.tick);
  drawCharacter('ajax', state.tick);
  drawCharacter('ntemis', state.tick);

  // Scene label
  ctx.save();
  ctx.fillStyle = '#D4A03C';
  ctx.font = '8px "Press Start 2P", monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.shadowColor = '#000';
  ctx.shadowBlur = 4;
  ctx.shadowOffsetX = 2;
  ctx.shadowOffsetY = 2;
  ctx.fillText(sc.label, GW / 2, 8);
  ctx.restore();

  // Music toggle icon
  ctx.save();
  ctx.globalAlpha = state.musicOn ? 0.5 : 0.2;
  ctx.fillStyle = '#D4A03C';
  ctx.font = '14px sans-serif';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'top';
  ctx.fillText('♪', GW - 8, 8);
  ctx.restore();

  // Dialogue overlay
  drawDialogue();

  // Fade overlay
  if (state.fade.active && state.fade.alpha > 0) {
    ctx.save();
    ctx.globalAlpha = state.fade.alpha;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, GW, GH);
    ctx.restore();
  }
}

// ════════════════════════════════════════════════════════════
// UPDATE — Main logic update
// ════════════════════════════════════════════════════════════
function update(dt) {
  state.tick++;

  // Title screen — start music on first interaction (handled by click)
  if (state.phase === 'title') return;

  if (state.phase !== 'playing') return;

  // Walking
  updateWalking(dt);

  // Character fade-in
  for (const who of ['ntemis','ajax','clio']) {
    if (chars[who].fadeIn < 1) {
      const delays = { ntemis: 0.1, ajax: 0.3, clio: 0.5 };
      if (state.tick > delays[who] * 60) {
        chars[who].fadeIn = Math.min(1, chars[who].fadeIn + dt * 1.5);
      }
    }
  }

  // Dialogue typewriter
  updateDlg(dt);

  // Particles
  updateParticles();

  // Fade transition
  if (state.fade.active) {
    const speed = 2.0; // fade speed (slower = smoother)
    state.fade.alpha += state.fade.dir * dt * speed;
    if (state.fade.dir > 0 && state.fade.alpha >= 1) {
      state.fade.alpha = 1;
      if (state.fade.cb) { const cb = state.fade.cb; state.fade.cb = null; cb(); }
    }
    if (state.fade.dir < 0 && state.fade.alpha <= 0) {
      state.fade.alpha = 0;
      if (state.fade.cb) { const cb = state.fade.cb; state.fade.cb = null; cb(); }
    }
  }
}

// ════════════════════════════════════════════════════════════
// GAME LOOP
// ════════════════════════════════════════════════════════════
let lastTime = 0;

function gameLoop(timestamp) {
  const dt = lastTime ? Math.min((timestamp - lastTime) / 1000, 0.05) : 0.016;
  lastTime = timestamp;

  // Resize canvas to fill available space
  const rect = CVS.getBoundingClientRect();
  // Keep internal resolution fixed, CSS handles scaling

  update(dt);
  render();
  requestAnimationFrame(gameLoop);
}

// ════════════════════════════════════════════════════════════
// INPUT HANDLING
// ════════════════════════════════════════════════════════════
CVS.addEventListener('mousemove', (e) => {
  const g = screenToGame(e.clientX, e.clientY);
  state.mouseGX = g.x;
  state.mouseGY = g.y;

  if (state.phase === 'title') {
    CVS.style.cursor = 'pointer';
    return;
  }

  if (state.phase !== 'playing' || state.dlg.active) {
    state.hoverObj = null;
    updateActionLine();
    return;
  }

  // Check hotspots
  const obj = hitTestObj(g.x, g.y);
  state.hoverObj = obj;

  // Check exits for cursor change
  const exit = hitTestExit(g.x, g.y);
  if (exit) {
    CVS.style.cursor = exit.side === 'left' ? 'w-resize' : 'e-resize';
    state.hoverObj = { label: exit.label }; // fake obj for action line
  } else if (obj) {
    CVS.style.cursor = 'pointer';
  } else {
    CVS.style.cursor = 'crosshair';
  }
  updateActionLine();
});

CVS.addEventListener('click', (e) => {
  const g = screenToGame(e.clientX, e.clientY);

  // Title clicks handled by dedicated handler
  if (state.phase !== 'playing') return;

  // Dialogue advance
  if (state.dlg.active) { advanceDlg(); return; }

  // Music toggle (top-right corner)
  if (g.x > GW - 30 && g.y < 25) { toggleMusic(); return; }

  // Check exit zones
  const exit = hitTestExit(g.x, g.y);
  if (exit) { changeScene(exit.target); return; }

  // Check hotspots
  const obj = hitTestObj(g.x, g.y);
  if (obj) { objClick(obj); return; }

  // Click ground — walk Ntemis
  if (g.y > 200) { // Only walk on ground area
    startWalk('ntemis', g.x);
    familyFollow(g.x);
  }
});

// Keyboard
document.addEventListener('keydown', e => {
  if (e.key === ' ' || e.key === 'Enter') {
    e.preventDefault();
    if (state.dlg.active) advanceDlg();
  }
  const vk = {'1':'look','2':'talk','3':'open','4':'use'};
  if (vk[e.key] && state.phase === 'playing') setVerb(vk[e.key]);
});

// ════════════════════════════════════════════════════════════
// MUSIC
// ════════════════════════════════════════════════════════════
const bgm = document.getElementById('bgm');
bgm.volume = 0.25;

function toggleMusic() {
  if (state.musicOn) {
    bgm.pause(); state.musicOn = false;
  } else {
    bgm.play().catch(() => {}); state.musicOn = true;
  }
}

// ════════════════════════════════════════════════════════════
// TITLE SCREEN — LucasArts-style cinematic canvas title
// ════════════════════════════════════════════════════════════
const titleMusic = document.getElementById('title-music');
titleMusic.volume = 0.35;
let titleFadeOut = 0;

// Pre-generate starfield (fixed positions)
const stars = [];
for (let i = 0; i < 40; i++) {
  stars.push({ x: Math.random() * GW, y: Math.random() * 55, s: 0.5 + Math.random() * 1.5, b: Math.random() });
}

function drawTitleScreen(tick) {
  const t = tick * 0.02;

  // ── SUNSET SKY — dramatic gradient like a movie poster ──
  const skyGrad = ctx.createLinearGradient(0, 0, 0, 100);
  skyGrad.addColorStop(0, '#0B0E2A');
  skyGrad.addColorStop(0.25, '#1B2854');
  skyGrad.addColorStop(0.5, '#2A4A7A');
  skyGrad.addColorStop(0.7, '#4A6A90');
  skyGrad.addColorStop(0.85, '#7A6848');
  skyGrad.addColorStop(1, '#C47020');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, GW, 100);

  // Stars twinkling in the deep blue portion
  ctx.save();
  for (const star of stars) {
    const twinkle = 0.3 + Math.sin(t * 2 + star.b * 10) * 0.7;
    ctx.globalAlpha = twinkle * 0.6;
    ctx.fillStyle = '#C0D0FF';
    ctx.fillRect(Math.floor(star.x), Math.floor(star.y), star.s > 1 ? 2 : 1, star.s > 1 ? 2 : 1);
  }
  ctx.restore();

  // Sunset glow on horizon
  ctx.save();
  const glowGrad = ctx.createRadialGradient(GW/2, 95, 10, GW/2, 95, 280);
  glowGrad.addColorStop(0, 'rgba(220,140,40,0.4)');
  glowGrad.addColorStop(0.4, 'rgba(180,80,20,0.15)');
  glowGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = glowGrad;
  ctx.fillRect(0, 20, GW, 80);
  ctx.restore();

  // ── SHIP HULL — fills the screen like the Indy boxcar ──
  const hullTop = 62;
  const hullBot = 345;
  const hullL = -5;  // bleeds off edges for more impact
  const hullR = GW + 5;

  // Hull path
  function hullPath() {
    ctx.beginPath();
    ctx.moveTo(hullL + 25, hullTop);
    ctx.lineTo(hullR - 15, hullTop);
    ctx.lineTo(hullR, hullTop + 25);
    ctx.lineTo(hullR + 8, hullBot - 25);
    ctx.quadraticCurveTo(hullR - 30, hullBot + 15, GW * 0.6, hullBot + 8);
    ctx.quadraticCurveTo(GW * 0.3, hullBot + 5, hullL - 8, hullBot - 45);
    ctx.lineTo(hullL, hullTop + 35);
    ctx.closePath();
  }

  // Hull base fill with rich wood tones
  ctx.save();
  hullPath();
  const woodGrad = ctx.createLinearGradient(0, hullTop, 0, hullBot);
  woodGrad.addColorStop(0, '#7A4422');
  woodGrad.addColorStop(0.08, '#8B5530');
  woodGrad.addColorStop(0.2, '#7A4825');
  woodGrad.addColorStop(0.4, '#6B3B1C');
  woodGrad.addColorStop(0.55, '#7A4422');
  woodGrad.addColorStop(0.7, '#5E3018');
  woodGrad.addColorStop(0.85, '#4A2410');
  woodGrad.addColorStop(1, '#3A1A0C');
  ctx.fillStyle = woodGrad;
  ctx.fill();

  // Clip to hull for all details
  ctx.clip();

  // Horizontal plank lines
  ctx.lineWidth = 1;
  for (let y = hullTop + 8; y < hullBot; y += 14) {
    // Dark groove
    ctx.strokeStyle = `rgba(30,14,5,${0.35 + Math.sin(y*0.3)*0.1})`;
    ctx.beginPath();
    ctx.moveTo(hullL - 10, y);
    ctx.lineTo(hullR + 10, y);
    ctx.stroke();
    // Subtle highlight below groove
    ctx.strokeStyle = 'rgba(160,110,60,0.07)';
    ctx.beginPath();
    ctx.moveTo(hullL - 10, y + 1);
    ctx.lineTo(hullR + 10, y + 1);
    ctx.stroke();
  }

  // Vertical plank joints (staggered)
  ctx.strokeStyle = 'rgba(30,14,5,0.2)';
  for (let y = hullTop; y < hullBot; y += 14) {
    const off = ((Math.floor(y / 14)) % 3) * 55;
    for (let x = hullL + off; x < hullR; x += 160) {
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x, y + 14);
      ctx.stroke();
    }
  }

  // ── Heavy iron bands (like the Indy train rails) ──
  // Top band
  const band1Y = hullTop + 18;
  ctx.fillStyle = '#2A1408';
  ctx.fillRect(hullL, band1Y, hullR - hullL, 10);
  ctx.fillStyle = 'rgba(120,80,40,0.15)';
  ctx.fillRect(hullL, band1Y, hullR - hullL, 2);
  // Rivets on top band
  for (let x = 30; x < GW; x += 45) {
    ctx.beginPath();
    ctx.arc(x, band1Y + 5, 3, 0, Math.PI * 2);
    ctx.fillStyle = '#3A2010';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x - 0.5, band1Y + 4, 1.5, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(140,100,50,0.3)';
    ctx.fill();
  }

  // Middle band (thinner)
  const band2Y = hullTop + 32;
  ctx.fillStyle = '#221008';
  ctx.fillRect(hullL, band2Y, hullR - hullL, 4);

  // Lower band
  const band3Y = hullBot - 55;
  ctx.fillStyle = '#2A1408';
  ctx.fillRect(hullL, band3Y, hullR - hullL, 8);
  ctx.fillStyle = 'rgba(120,80,40,0.12)';
  ctx.fillRect(hullL, band3Y, hullR - hullL, 2);
  // Rivets on lower band
  for (let x = 15; x < GW; x += 45) {
    ctx.beginPath();
    ctx.arc(x, band3Y + 4, 3, 0, Math.PI * 2);
    ctx.fillStyle = '#3A2010';
    ctx.fill();
  }

  // ── Portholes with glass reflection ──
  for (let i = 0; i < 7; i++) {
    const px = 55 + i * 82;
    const py = hullBot - 32;
    // Shadow
    ctx.beginPath();
    ctx.arc(px + 1, py + 1, 10, 0, Math.PI * 2);
    ctx.fillStyle = '#1A0A04';
    ctx.fill();
    // Outer brass ring
    ctx.beginPath();
    ctx.arc(px, py, 10, 0, Math.PI * 2);
    ctx.fillStyle = '#4A2810';
    ctx.fill();
    // Inner ring
    ctx.beginPath();
    ctx.arc(px, py, 7, 0, Math.PI * 2);
    ctx.fillStyle = '#1a0e05';
    ctx.fill();
    // Glass with subtle sea reflection
    ctx.beginPath();
    ctx.arc(px, py, 5, 0, Math.PI * 2);
    const glassGrad = ctx.createRadialGradient(px - 2, py - 2, 0, px, py, 5);
    glassGrad.addColorStop(0, 'rgba(80,120,160,0.3)');
    glassGrad.addColorStop(1, 'rgba(10,20,40,0.5)');
    ctx.fillStyle = glassGrad;
    ctx.fill();
    // Specular highlight
    ctx.beginPath();
    ctx.arc(px - 2, py - 2, 2, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(200,220,255,0.15)';
    ctx.fill();
  }

  // Warm light patch (like sunset hitting the hull)
  const lightGrad = ctx.createRadialGradient(GW * 0.4, hullTop + 80, 20, GW * 0.4, hullTop + 80, 250);
  lightGrad.addColorStop(0, 'rgba(220,160,60,0.08)');
  lightGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = lightGrad;
  ctx.fillRect(hullL, hullTop, hullR - hullL, hullBot - hullTop);

  ctx.restore(); // un-clip

  // Hull outline — thick dark edge
  ctx.save();
  hullPath();
  ctx.strokeStyle = '#1A0C04';
  ctx.lineWidth = 4;
  ctx.stroke();
  ctx.restore();

  // ── Deck railing with detail ──
  ctx.save();
  ctx.strokeStyle = '#5A3018';
  ctx.lineWidth = 3;
  // Bottom rail
  ctx.beginPath();
  ctx.moveTo(30, hullTop - 1);
  ctx.lineTo(GW - 20, hullTop - 1);
  ctx.stroke();
  // Posts
  ctx.lineWidth = 2;
  for (let x = 45; x < GW - 10; x += 32) {
    ctx.beginPath();
    ctx.moveTo(x, hullTop - 1);
    ctx.lineTo(x, hullTop - 16);
    ctx.stroke();
    // Post cap
    ctx.fillStyle = '#6A3820';
    ctx.fillRect(x - 2, hullTop - 17, 4, 3);
  }
  // Top rail
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(40, hullTop - 15);
  ctx.lineTo(GW - 15, hullTop - 15);
  ctx.stroke();
  ctx.restore();

  // ── MASTS — two for a proper brig ──
  ctx.save();
  // Foremast (left)
  const m1x = GW * 0.3;
  ctx.fillStyle = '#4A2812';
  ctx.fillRect(m1x - 3, hullTop - 52, 6, 55);
  ctx.fillStyle = '#3A1E0E';
  ctx.fillRect(m1x - 35, hullTop - 40, 70, 4);
  // Mainmast (right)
  const m2x = GW * 0.7;
  ctx.fillStyle = '#4A2812';
  ctx.fillRect(m2x - 3, hullTop - 58, 6, 60);
  ctx.fillStyle = '#3A1E0E';
  ctx.fillRect(m2x - 40, hullTop - 45, 80, 4);
  // Rigging
  ctx.strokeStyle = 'rgba(90,60,25,0.4)';
  ctx.lineWidth = 1;
  const rigging = [
    [m1x, hullTop-50, 35, hullTop], [m1x, hullTop-50, m1x+120, hullTop],
    [m2x, hullTop-56, m2x-130, hullTop], [m2x, hullTop-56, GW-20, hullTop],
    [m1x, hullTop-50, m2x, hullTop-56], // connects masts
  ];
  for (const [x1,y1,x2,y2] of rigging) {
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  }
  // Crow's nests
  ctx.fillStyle = '#3A1E0E';
  ctx.fillRect(m1x - 8, hullTop - 54, 16, 4);
  ctx.fillRect(m2x - 9, hullTop - 60, 18, 4);
  // Greek flag on mainmast
  const flagY = hullTop - 56;
  const fw = 18, fh = 11;
  ctx.fillStyle = '#1A4A8A';
  ctx.fillRect(m2x + 4, flagY - fh, fw, fh);
  ctx.fillStyle = '#FFFFFF';
  ctx.fillRect(m2x + 4, flagY - fh + 2, fw, 2);
  ctx.fillRect(m2x + 4, flagY - fh + 6, fw, 2);
  ctx.fillRect(m2x + 4, flagY - fh, 6, fh);
  ctx.fillRect(m2x + 6, flagY - fh, 2, 6);
  ctx.restore();

  // ══════════════════════════════════════════
  // TITLE TEXT — massive, embossed on the hull
  // ══════════════════════════════════════════
  ctx.save();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  const glowPulse = 0.35 + Math.sin(t * 1.2) * 0.15;

  // Helper: draw embossed text with multi-layer shadows
  function embossedText(text, cx, cy, size) {
    ctx.font = `bold ${size}px "Press Start 2P", monospace`;
    // Layer 1: deep black shadow (furthest)
    ctx.fillStyle = '#0A0402';
    ctx.fillText(text, cx + 5, cy + 5);
    // Layer 2: dark brown
    ctx.fillStyle = '#1A0A04';
    ctx.fillText(text, cx + 4, cy + 4);
    // Layer 3: medium shadow
    ctx.fillStyle = '#2E1508';
    ctx.fillText(text, cx + 3, cy + 3);
    // Layer 4: warm shadow
    ctx.fillStyle = '#4A2010';
    ctx.fillText(text, cx + 2, cy + 2);
    // Layer 5: edge highlight (dark gold)
    ctx.fillStyle = '#8B6020';
    ctx.fillText(text, cx + 1, cy + 1);
    // Main text — bright gold with glow
    ctx.shadowColor = `rgba(255,180,40,${glowPulse})`;
    ctx.shadowBlur = 20;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.fillStyle = '#D4A03C';
    ctx.fillText(text, cx, cy);
    // Top-edge specular highlight
    ctx.shadowBlur = 0;
    ctx.fillStyle = 'rgba(255,230,160,0.3)';
    ctx.fillText(text, cx, cy - 1);
    ctx.fillStyle = 'rgba(255,240,200,0.12)';
    ctx.fillText(text, cx - 1, cy - 1);
  }

  // "Η ΘΑΛΑΣΣΑ" — HUGE top line
  embossedText('Η ΘΑΛΑΣΣΑ', GW / 2, hullTop + 95, 48);

  // "ΘΥΜΑΤΑΙ" — HUGE second line
  embossedText('ΘΥΜΑΤΑΙ', GW / 2, hullTop + 160, 48);

  // Decorative line between title and subtitle
  ctx.shadowBlur = 0;
  const lineW = 200;
  const lineY = hullTop + 200;
  ctx.strokeStyle = '#8B6020';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(GW/2 - lineW, lineY);
  ctx.lineTo(GW/2 - 20, lineY);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(GW/2 + 20, lineY);
  ctx.lineTo(GW/2 + lineW, lineY);
  ctx.stroke();
  // Center diamond ornament
  ctx.fillStyle = '#D4A03C';
  ctx.save();
  ctx.translate(GW/2, lineY);
  ctx.rotate(Math.PI / 4);
  ctx.fillRect(-4, -4, 8, 8);
  ctx.restore();

  // "ΤΟ ΜΥΣΤΗΡΙΟ ΤΟΥ ΓΑΛΑΞΕΙΔΙΟΥ" — subtitle
  ctx.font = '11px "Press Start 2P", monospace';
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#1A0A04';
  ctx.fillText('ΤΟ ΜΥΣΤΗΡΙΟ ΤΟΥ ΓΑΛΑΞΕΙΔΙΟΥ', GW / 2 + 2, hullTop + 225 + 2);
  ctx.fillStyle = '#B8842C';
  ctx.fillText('ΤΟ ΜΥΣΤΗΡΙΟ ΤΟΥ ΓΑΛΑΞΕΙΔΙΟΥ', GW / 2, hullTop + 225);

  ctx.restore();

  // ── SEA — rich animated waves ──
  const seaTop = 340;
  const seaGrad = ctx.createLinearGradient(0, seaTop, 0, GH);
  seaGrad.addColorStop(0, '#1B3A5C');
  seaGrad.addColorStop(0.2, '#15304D');
  seaGrad.addColorStop(0.5, '#102540');
  seaGrad.addColorStop(1, '#081828');
  ctx.fillStyle = seaGrad;
  ctx.fillRect(0, seaTop - 5, GW, GH - seaTop + 5);

  // Multi-layer animated waves
  ctx.save();
  for (let layer = 0; layer < 4; layer++) {
    const waveY = seaTop + layer * 12;
    const speed = 0.6 + layer * 0.25;
    const amp = 3 + layer * 1.5;
    const alpha = 0.35 - layer * 0.07;
    ctx.beginPath();
    for (let x = 0; x <= GW; x += 3) {
      const y = waveY + Math.sin(x * 0.012 + t * speed) * amp
                       + Math.sin(x * 0.006 - t * speed * 0.6) * (amp * 0.6)
                       + Math.sin(x * 0.025 + t * speed * 1.4) * (amp * 0.2);
      if (x === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.lineTo(GW, GH);
    ctx.lineTo(0, GH);
    ctx.closePath();
    ctx.fillStyle = `rgba(20,55,90,${alpha})`;
    ctx.fill();
  }
  // Foam crests
  ctx.strokeStyle = 'rgba(180,210,240,0.12)';
  ctx.lineWidth = 1;
  for (let layer = 0; layer < 3; layer++) {
    ctx.beginPath();
    for (let x = 0; x <= GW; x += 3) {
      const y = seaTop + layer * 12 + Math.sin(x * 0.012 + t * (0.6 + layer * 0.25)) * (3 + layer * 1.5);
      if (x === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
  }
  // Moonlight reflection on water
  const moonGrad = ctx.createRadialGradient(GW*0.5, seaTop + 10, 5, GW*0.5, seaTop + 20, 120);
  moonGrad.addColorStop(0, 'rgba(180,160,100,0.08)');
  moonGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = moonGrad;
  ctx.fillRect(0, seaTop, GW, GH - seaTop);
  ctx.restore();

  // ── Bottom bar — dark ground/dock ──
  ctx.fillStyle = '#1A100A';
  ctx.fillRect(0, GH - 28, GW, 28);
  ctx.fillStyle = '#2A1A0E';
  ctx.fillRect(0, GH - 28, GW, 2);

  // ── Credits line ──
  ctx.save();
  ctx.font = '7px "Press Start 2P", monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  ctx.fillStyle = '#4A3A28';
  ctx.fillText('ΜΙΑ ΠΕΡΙΠΕΤΕΙΑ ΤΗΣ ΟΙΚΟΓΕΝΕΙΑΣ ΛΑΤΣΟΥΔΗ', GW / 2, GH - 6);
  ctx.restore();

  // ── "CLICK TO START" ──
  const blinkAlpha = 0.25 + Math.sin(tick * 0.06) * 0.4;
  ctx.save();
  ctx.font = '8px "Press Start 2P", monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  ctx.globalAlpha = Math.max(0, blinkAlpha);
  ctx.fillStyle = '#D4A03C';
  ctx.shadowColor = 'rgba(212,160,60,0.4)';
  ctx.shadowBlur = 8;
  ctx.fillText('► ΚΛΙΚ ΓΙΑ ΕΝΑΡΞΗ ◄', GW / 2, GH - 32);
  ctx.restore();

  // ── Fade out overlay ──
  if (titleFadeOut > 0) {
    ctx.save();
    ctx.globalAlpha = titleFadeOut;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, GW, GH);
    ctx.restore();
  }
}

// ════════════════════════════════════════════════════════════
// TITLE & INTRO FLOW
// ════════════════════════════════════════════════════════════
let titleClicked = false;
let titleMusicStarted = false;

// Start title music on any user gesture (needed for autoplay policy)
function ensureTitleMusic() {
  if (!titleMusicStarted && state.phase === 'title') {
    titleMusic.play().catch(() => {});
    titleMusicStarted = true;
  }
}
document.addEventListener('click', ensureTitleMusic, { once: true });
document.addEventListener('keydown', ensureTitleMusic, { once: true });

CVS.addEventListener('click', function titleClickHandler(e) {
  if (state.phase !== 'title' || titleClicked) return;
  titleClicked = true;

  // Crossfade title music out
  const fadeInterval = setInterval(() => {
    if (titleMusic.volume > 0.02) {
      titleMusic.volume = Math.max(0, titleMusic.volume - 0.01);
    } else {
      titleMusic.pause();
      titleMusic.volume = 0.3;
      clearInterval(fadeInterval);
    }
  }, 50);

  // Animate fade to black
  const fadeStep = () => {
    titleFadeOut += 0.02;
    if (titleFadeOut < 1) {
      requestAnimationFrame(fadeStep);
    } else {
      titleFadeOut = 1;
      // Switch to intro
      state.phase = 'intro';
      bgm.play().catch(() => {}); state.musicOn = true;
      const intro = document.getElementById('intro-screen');
      intro.classList.add('show');
      showIntroPage();
    }
  };
  requestAnimationFrame(fadeStep);
}, { once: false });

function showIntroPage() {
  const t = document.getElementById('intro-text');
  const h = document.getElementById('intro-hint');
  t.style.opacity = '0';
  h.classList.remove('on');
  setTimeout(() => {
    t.innerHTML = introPages[state.introPage].replace(/\n/g, '<br>');
    t.style.opacity = '1';
    setTimeout(() => h.classList.add('on'), 1200);
  }, 300);
}

document.getElementById('intro-screen').onclick = () => {
  state.introPage++;
  if (state.introPage >= introPages.length) {
    const is = document.getElementById('intro-screen');
    is.style.opacity = '0';
    setTimeout(() => {
      is.style.display = 'none';
      state.phase = 'playing';
      startScene('exterior');
    }, 1500);
  } else {
    showIntroPage();
  }
};

// ════════════════════════════════════════════════════════════
// BOOT
// ════════════════════════════════════════════════════════════
loadAllAssets().then(() => {
  requestAnimationFrame(gameLoop);
});
</script>
</body>
</html>
