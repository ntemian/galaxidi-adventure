<!DOCTYPE html>
<html lang="el">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Η Θάλασσα Θυμάται — Canvas Engine</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
  body { background: #000; overflow: hidden; font-family: 'Press Start 2P', monospace; display: flex; flex-direction: column; height: 100vh; }

  /* ── CANVAS ── */
  #game-canvas {
    display: block; background: #0a0812;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    cursor: crosshair;
    flex: 1;
    width: 100%;
    min-height: 0;
  }

  /* ── ACTION LINE ── */
  #action-line {
    height: 32px; display: none; align-items: center; justify-content: center;
    font-family: 'Press Start 2P', monospace;
    font-size: .65rem; color: #F0C860; letter-spacing: 1px;
    background: linear-gradient(180deg, #1a1610 0%, #0e0c08 100%);
    border-top: 3px solid #3a3020;
    border-bottom: 1px solid #1a1408;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.8), 0 0 8px rgba(212,160,60,0.15);
  }
  #action-line.on { display: flex; }

  /* ── UI PANEL — Classic SCUMM layout ── */
  #ui-panel {
    background: linear-gradient(180deg, #14120e 0%, #0c0a06 40%, #080604 100%);
    border-top: 3px solid #3a3020;
    display: none; flex-direction: column;
    box-shadow: inset 0 2px 6px rgba(0,0,0,0.5);
  }
  #ui-panel.on { display: flex; }

  /* Bottom row: verbs LEFT, inventory RIGHT */
  #ui-bottom {
    display: flex; height: 150px; padding: 6px 8px;
  }

  /* ── VERB GRID (left side, 2x2) ── */
  #verb-panel {
    display: grid; grid-template-columns: repeat(2, 1fr); grid-template-rows: repeat(2, 1fr);
    gap: 4px; width: 300px; flex-shrink: 0;
  }
  .vb {
    font-family: 'Press Start 2P', monospace; font-size: .6rem; color: #9a8a68;
    background: linear-gradient(180deg, #201c14 0%, #181410 50%, #141008 100%);
    border: 2px solid #2e2618;
    border-top-color: #3a3228; border-left-color: #3a3228;
    border-bottom-color: #1a1408; border-right-color: #1a1408;
    cursor: pointer; transition: all .15s;
    display: flex; align-items: center; justify-content: center;
    padding: 4px 8px; text-align: center;
    text-shadow: 1px 1px 1px rgba(0,0,0,0.6);
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.04), 0 1px 2px rgba(0,0,0,0.3);
  }
  .vb:hover {
    color: #F0C860; border-color: #D4A03C;
    background: linear-gradient(180deg, #2a2418 0%, #221e14 50%, #1a1610 100%);
    text-shadow: 0 0 6px rgba(240,200,96,0.3);
  }
  .vb:active { transform: scale(.97); }
  .vb.on {
    color: #F0C860;
    background: linear-gradient(180deg, #2e2818 0%, #261e10 50%, #201a0c 100%);
    border: 2px solid #D4A03C;
    border-top-color: #e0b050; border-left-color: #e0b050;
    border-bottom-color: #a08030; border-right-color: #a08030;
    text-shadow: 0 0 8px rgba(240,200,96,0.4);
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.06), 0 0 6px rgba(212,160,60,0.15);
  }

  /* ── INVENTORY GRID (right side) ── */
  #inv-panel {
    flex: 1; display: flex; align-items: stretch;
    margin-left: 8px;
    border: 2px solid #2e2618;
    border-top-color: #1a1408; border-left-color: #1a1408;
    border-bottom-color: #3a3228; border-right-color: #3a3228;
    background: linear-gradient(180deg, #0e0c08 0%, #121010 50%, #0e0c08 100%);
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.4);
    border-radius: 2px;
    padding: 0;
  }
  #inv-label { display: none; }
  #inv-arrows {
    display: flex; flex-direction: column; justify-content: center;
    gap: 6px; padding: 4px 6px; flex-shrink: 0;
    border-right: 1px solid #2a2218;
  }
  #inv-arrows button {
    font-size: .8rem; color: #7a6a48; background: linear-gradient(180deg, #1e1a12 0%, #161208 100%);
    border: 2px solid #2e2618;
    border-top-color: #3a3228; border-left-color: #3a3228;
    border-bottom-color: #1a1408; border-right-color: #1a1408;
    cursor: pointer; padding: 8px 10px; line-height: 1;
    transition: all .15s;
  }
  #inv-arrows button:hover {
    color: #F0C860; border-color: #D4A03C;
    text-shadow: 0 0 6px rgba(240,200,96,0.3);
  }
  #inv-grid {
    flex: 1; display: grid;
    grid-template-columns: repeat(auto-fill, 60px);
    grid-template-rows: repeat(2, 60px);
    grid-auto-flow: column;
    gap: 4px; padding: 6px;
    overflow: hidden;
    align-content: center;
  }
  .inv-slot {
    width: 60px; height: 60px;
    background: linear-gradient(180deg, #181410 0%, #121008 100%);
    border: 2px solid #2a2218;
    border-top-color: #1a1408; border-left-color: #1a1408;
    border-bottom-color: #322a1c; border-right-color: #322a1c;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; transition: all .15s;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
  }
  .inv-slot:hover {
    border-color: #D4A03C;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.3), 0 0 4px rgba(212,160,60,0.15);
  }
  .inv-slot.on {
    border: 2px solid #D4A03C;
    border-top-color: #e0b050; border-left-color: #e0b050;
    border-bottom-color: #a08030; border-right-color: #a08030;
    background: linear-gradient(180deg, #221e14 0%, #1a1610 100%);
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.2), 0 0 8px rgba(212,160,60,0.2);
  }
  .inv-slot .inv-text {
    font-family: 'Press Start 2P', monospace; font-size: .35rem; color: #9a8a68;
    text-align: center; line-height: 1.3;
    text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
  }

  /* ── TITLE (canvas-rendered, no HTML overlay) ── */
  @keyframes blink { 0%,100%{opacity:.3} 50%{opacity:.9} }

  /* ── INTRO OVERLAY ── */
  #intro-screen {
    position: fixed; inset: 0; background: #0a0812;
    display: none; flex-direction: column; align-items: center; justify-content: center;
    z-index: 1500; padding: 2rem; cursor: pointer; transition: opacity 1.5s;
  }
  #intro-screen.show { display: flex; }
  #intro-text { max-width:600px; font-size:clamp(.6rem,1.2vw,.8rem); color:#D4A03C; line-height:2.5; text-align:center; opacity:0; transition: opacity 1.5s; }
  #intro-hint { font-size:.5rem; color:#4a4a4a; margin-top:2rem; opacity:0; transition: opacity .5s; }
  #intro-hint.on { opacity:1; animation: blink 2s infinite; }

  /* ── FADE ── */
  #fade { position: fixed; inset: 0; background: #000; z-index: 3000; opacity: 0; pointer-events: none; transition: opacity .5s; }
  #fade.on { opacity: 1; }
</style>
</head>
<body>

<div id="fade"></div>

<!-- Title screen is canvas-rendered -->

<div id="intro-screen">
  <div id="intro-text"></div>
  <div id="intro-hint">▶ ΚΛΙΚ</div>
</div>

<canvas id="game-canvas" width="640" height="400"></canvas>

<div id="action-line"></div>

<div id="ui-panel">
  <div id="ui-bottom">
    <div id="verb-panel">
      <button class="vb on" data-v="look" onclick="setVerb('look')">Κοίταξε</button>
      <button class="vb" data-v="talk" onclick="setVerb('talk')">Μίλησε</button>
      <button class="vb" data-v="open" onclick="setVerb('open')">Άνοιξε</button>
      <button class="vb" data-v="use" onclick="setVerb('use')">Χρησιμοποίησε</button>
    </div>
    <div id="inv-panel">
      <div id="inv-arrows">
        <button onclick="scrollInv(-1)">▲</button>
        <button onclick="scrollInv(1)">▼</button>
      </div>
      <div id="inv-grid"></div>
    </div>
  </div>
</div>

<audio id="title-music" loop preload="auto"><source src="music/sun-arrives-in-chora-1.mp3" type="audio/mpeg"></audio>
<audio id="bgm" loop preload="auto"><source src="music/scene1-music.mp3" type="audio/mpeg"></audio>

<script>
// ════════════════════════════════════════════════════════════
// CANVAS ENGINE — Pure requestAnimationFrame game loop
// ════════════════════════════════════════════════════════════
const CVS = document.getElementById('game-canvas');
const ctx = CVS.getContext('2d');
const GW = 640, GH = 400; // internal game resolution
CVS.width = GW; CVS.height = GH;

// ════════════════════════════════════════════════════════════
// STATE
// ════════════════════════════════════════════════════════════
const state = {
  phase: 'title', // title, intro, playing
  scene: null,
  verb: 'look',
  inv: [],
  flags: {},
  visited: new Set(),
  tick: 0,
  mouseGX: 0, mouseGY: 0,
  hoverObj: null,
  musicOn: false,
  dlg: { active: false, queue: [], text: '', displayed: '', charIdx: 0, timer: 0, speaker: '', cb: null },
  fade: { active: false, alpha: 0, dir: 0, cb: null },
  introPage: 0,
};

// Characters
const chars = {
  ntemis: { x: 0, y: 0, dir: 1, walking: false, frame: 0, targetX: null, startX: 0, walkT: 0, walkDur: 0, visible: true, fadeIn: 0 },
  ajax:   { x: 0, y: 0, dir: 1, walking: false, frame: 0, targetX: null, startX: 0, walkT: 0, walkDur: 0, visible: true, fadeIn: 0 },
  clio:   { x: 0, y: 0, dir: 1, walking: false, frame: 0, targetX: null, startX: 0, walkT: 0, walkDur: 0, visible: true, fadeIn: 0 },
};
let walkDoneCallback = null;

// ════════════════════════════════════════════════════════════
// IMAGE LOADING
// ════════════════════════════════════════════════════════════
const images = {};
function loadImg(key, src) {
  return new Promise(resolve => {
    const img = new Image();
    img.onload = () => { images[key] = img; resolve(img); };
    img.onerror = () => { console.warn('Failed to load:', src); resolve(null); };
    img.src = src;
  });
}

// Character idle sprites
const CHAR_IMGS = {};
const WALK_FRAMES = { ntemis: [], ajax: [], clio: [] };
const PORTRAITS = {};

async function loadAllAssets() {
  // Backgrounds
  await Promise.all([
    loadImg('bg-exterior', 'assets/pixel-exterior.png'),
    loadImg('bg-terrace', 'assets/pixel-terrace.png'),
    loadImg('bg-kitchen', 'assets/pixel-kitchen.png'),
  ]);

  // Character idle sprites
  const charPromises = ['ntemis','ajax','clio'].map(id =>
    loadImg(`char-${id}`, `assets/char-${id}-final.png`).then(img => { CHAR_IMGS[id] = img; })
  );

  // Portraits
  const portPromises = [
    loadImg('port-ntemis', 'assets/portrait-ntemis.png').then(img => { PORTRAITS['ΝΤΕΜΗΣ'] = img; }),
    loadImg('port-ajax', 'assets/portrait-ajax.png').then(img => { PORTRAITS['ΑΙΑΣ'] = img; }),
    loadImg('port-clio', 'assets/portrait-clio.png').then(img => { PORTRAITS['ΚΛΕΙΩ'] = img; }),
  ];

  await Promise.all([...charPromises, ...portPromises]);

  // Walk frames from JSON
  try {
    const resp = await fetch('assets/walk-frames-b64.json');
    const data = await resp.json();
    for (const who of ['ntemis','ajax','clio']) {
      if (data[who]) {
        for (let i = 0; i < data[who].length; i++) {
          const img = new Image();
          img.src = 'data:image/png;base64,' + data[who][i];
          WALK_FRAMES[who].push(img);
        }
      }
    }
  } catch(e) { console.warn('Walk frames load failed:', e); }
}

// ════════════════════════════════════════════════════════════
// SCENES DATA
// ════════════════════════════════════════════════════════════
const scenes = {
  exterior: {
    label: 'ΤΟ ΣΠΙΤΙ — ΓΑΛΑΞΙΔΙ', bg: 'bg-exterior',
    charPos: {
      ntemis: { x: 290, y: 340 },
      ajax:   { x: 370, y: 348 },
      clio:   { x: 210, y: 348 },
    },
    objects: [
      { id:'door', x:115, y:100, w:70, h:120, label:'Πόρτα',
        verbs: { look:[{s:'',t:'Ξύλινη πόρτα βαμμένη μπλε. Το χρώμα του Αιγαίου.'}],
                 open:[{s:'ΝΤΕΜΗΣ',t:'Ας μπούμε μέσα.'}], walk:'kitchen', use:'kitchen' }},
      { id:'bougainvillea', x:175, y:20, w:150, h:120, label:'Μπουκαμβίλιες',
        verbs: { look:[{s:'',t:'Ροζ μπουκαμβίλιες σκαρφαλώνουν στον τοίχο. Εδώ το καλοκαίρι αρνείται να φύγει.'}],
                 pick:[{s:'ΚΛΕΙΩ',t:'Μπαμπά, μην τις κόβεις! Είναι τέλειες έτσι.'}] }},
      { id:'flowerpots', x:75, y:195, w:65, h:55, label:'Γλάστρες',
        verbs: { look:[{s:'',t:'Πήλινες γλάστρες με βασιλικό. Κάποιος τα περιποιείται ακόμα κι όταν το σπίτι μένει κλειστό.'}] }},
      { id:'barrel', x:245, y:180, w:55, h:60, label:'Βαρέλι',
        verbs: { look:[{s:'',t:'Ένα παλιό ξύλινο βαρέλι. Μυρίζει κρασί και αλμύρα.'}],
                 open:[{s:'ΑΙΑΣ',t:'Άδειο. Κρίμα!'}] }},
      { id:'boats', x:380, y:120, w:140, h:80, label:'Ψαροκάικα',
        verbs: { look:[{s:'',t:'Χρωματιστά ψαροκάικα δεμένα στο λιμάνι. Κουνιούνται αργά στο απογευματινό φως.'},{s:'ΑΙΑΣ',t:'Μπαμπά, θα πάμε βόλτα με βάρκα;'}] }},
      { id:'sea', x:350, y:60, w:230, h:60, label:'Η θάλασσα',
        verbs: { look:[{s:'',t:'Ο Κορινθιακός κόλπος λάμπει χρυσαφί στο ηλιοβασίλεμα. Μαγικό.'}] }},
    ],
    exits: [{ side:'right', target:'terrace', label:'Βεράντα →' }],
    entry: [
      {s:'',t:'Ο ήλιος βάφει χρυσά τα καλντερίμια. Μυρωδιά πεύκου ανακατεμένη με θαλασσινό αλάτι.'},
      {s:'ΝΤΕΜΗΣ',t:'Φτάσαμε, παιδιά. Αυτό είναι το σπίτι μας για το Σαββατοκύριακο.'},
      {s:'ΑΙΑΣ',t:'Τέλειο! Πάμε κατευθείαν στο λιμάνι;'},
      {s:'ΚΛΕΙΩ',t:'Πρώτα ας αφήσουμε τις βαλίτσες. Θέλω να δω τη βεράντα.'},
    ],
  },
  terrace: {
    label: 'Η ΒΕΡΑΝΤΑ', bg: 'bg-terrace',
    charPos: {
      ntemis: { x: 320, y: 345 },
      ajax:   { x: 420, y: 350 },
      clio:   { x: 225, y: 350 },
    },
    objects: [
      { id:'harbor', x:140, y:120, w:280, h:100, label:'Το λιμάνι',
        verbs: { look:()=>{
          if(!state.flags.dolphins){state.flags.dolphins=1;return[
            {s:'',t:'Ο Κορινθιακός λάμπει σαν λιωμένο χρυσάφι. Ψαροκάικα κουνιούνται αργά στο λιμάνι.'},
            {s:'ΚΛΕΙΩ',t:'Μπαμπά, κοίτα! Δελφίνια!'},
            {s:'',t:'Τρία δελφίνια κόβουν βόλτες στο λιμάνι.'},
            {s:'ΑΙΑΣ',t:'Δελφίνια μέσα στο λιμάνι; Αυτό δεν είναι συνηθισμένο...'}];}
          return[{s:'',t:'Τα δελφίνια συνεχίζουν τους κύκλους τους. Σαν να φυλάνε κάτι.'}];}}},
      { id:'rooftops', x:30, y:80, w:130, h:100, label:'Σκεπές',
        verbs: { look:[{s:'',t:'Κεραμίδια, σκεπές, καμινάδες. Κάθε σπίτι κι ένας καπετάνιος κάποτε.'}] }},
      { id:'mountains', x:250, y:12, w:300, h:80, label:'Παρνασσός',
        verbs: { look:[{s:'',t:'Ο Παρνασσός στο βάθος. Οι Δελφοί κάπου εκεί πάνω.'},{s:'ΚΛΕΙΩ',t:'Οι Αμφικτίονες ξεκινούσαν από τους Δελφούς... Το Γαλαξίδι ήταν λιμάνι τους.'}] }},
      { id:'balustrade', x:90, y:240, w:370, h:40, label:'Κάγκελο',
        verbs: { look:[{s:'',t:'Πέτρινο κάγκελο με θέα ολόκληρο το Γαλαξίδι. Θα μπορούσες να κάτσεις εδώ ώρες.'}],
                 push:[{s:'ΚΛΕΙΩ',t:'Μπαμπά, μην ακουμπάς, φαίνεται παλιό!'}] }},
      { id:'flowerpot', x:10, y:220, w:65, h:60, label:'Γλάστρα',
        verbs: { look:[{s:'',t:'Γεράνια σε πήλινη γλάστρα. Τα χρώματα λάμπουν στο ηλιοβασίλεμα.'}] }},
    ],
    exits: [{ side:'left', target:'exterior', label:'← Σπίτι' }],
    entry: [
      {s:'',t:'Η θέα κόβει την ανάσα.'},
      {s:'ΚΛΕΙΩ',t:'Αυτό είναι το πιο όμορφο μέρος στον κόσμο.'},
      {s:'ΝΤΕΜΗΣ',t:'Καλωσορίσατε στο Γαλαξίδι.'},
    ],
  },
  kitchen: {
    label: 'Η ΚΟΥΖΙΝΑ', bg: 'bg-kitchen',
    charPos: {
      ntemis: { x: 350, y: 340 },
      ajax:   { x: 450, y: 345 },
      clio:   { x: 100, y: 345 },
    },
    objects: [
      { id:'figs', x:180, y:175, w:100, h:55, label:'Σύκα',
        verbs: { look:[{s:'',t:'Φρέσκα σύκα σε πήλινο μπολ. Η μυρωδιά γεμίζει το δωμάτιο.'}],
                 pick:[{s:'ΑΙΑΣ',t:'Μπαμπά, μπορώ να φάω ένα;'},{s:'ΝΤΕΜΗΣ',t:'Φυσικά.'}],
                 use:[{s:'',t:'Τρως ένα σύκο. Γλυκό σαν μέλι.'}] }},
      { id:'satchel', x:340, y:168, w:80, h:85, label:'Δερμάτινη τσάντα',
        verbs: {
          look:()=>{if(!state.flags.note)return[{s:'',t:'Μια παλιά δερμάτινη τσάντα πάνω στην καρέκλα. Δεν είναι δική σας.'},{s:'ΚΛΕΙΩ',t:'Μπαμπά, κοίτα — υπάρχει κάτι μέσα.'}];return[{s:'',t:'Η τσάντα είναι άδεια τώρα.'}];},
          open:()=>{if(!state.flags.note){state.flags.note=1;addInv({id:'note',label:'Σημείωμα'});return[{s:'',t:'Ανοίγεις την τσάντα. Μέσα βρίσκεις ένα σημείωμα.'},{s:'ΚΛΕΙΩ',t:'Διάβασέ το!'},{s:'',t:'«Σας περιμέναμε. Ελάτε στο λιμάνι απόψε. Τραπέζι για τρεις. — Γ.»'},{s:'ΑΙΑΣ',t:'Ποιος είναι ο «Γ.»;'},{s:'ΝΤΕΜΗΣ',t:'Και πώς ξέρει ότι είμαστε τρεις;'}];}return[{s:'',t:'Η τσάντα είναι πλέον άδεια.'}];},
          pick:[{s:'ΝΤΕΜΗΣ',t:'Δεν είναι δική μας. Ας κοιτάξω μέσα πρώτα.'}] }},
      { id:'window', x:455, y:50, w:95, h:115, label:'Παράθυρο',
        verbs: { look:[{s:'',t:'Απογευματινό φως μέσα από γαλάζια πατζούρια. Σκιές χορεύουν στον τοίχο.'}],
                 open:[{s:'',t:'Ανοίγεις τα πατζούρια. Μυρωδιά θυμαριού και τζιτζίκια.'}] }},
      { id:'pots', x:150, y:35, w:240, h:65, label:'Χάλκινα σκεύη',
        verbs: { look:[{s:'',t:'Χάλκινα σκεύη κρεμασμένα στον τοίχο. Κάποτε τάιζαν οικογένειες ναυτικών.'}] }},
      { id:'fireplace', x:0, y:75, w:95, h:145, label:'Τζάκι',
        verbs: { look:[{s:'',t:'Πέτρινο τζάκι. Μέσα υπάρχουν ακόμα στάχτες από τον τελευταίο χειμώνα.'}] }},
    ],
    exits: [{ side:'left', target:'exterior', label:'← Έξω' }],
    entry: [
      {s:'',t:'Η κουζίνα μυρίζει θυμάρι και παλιό ξύλο.'},
      {s:'ΚΛΕΙΩ',t:'Κοιτάξτε — κάποιος μας άφησε σύκα!'},
      {s:'ΑΙΑΣ',t:'Και κάτι πάνω στην καρέκλα... μια τσάντα;'},
    ],
  },
};

// ════════════════════════════════════════════════════════════
// INTRO PAGES
// ════════════════════════════════════════════════════════════
const introPages = [
  'Γαλαξίδι.\nΤέλη Σεπτεμβρίου, 2026.',
  'Ένα μικρό λιμάνι\nστον Κορινθιακό κόλπο.\n\nΕκεί που κάποτε ξεκινούσαν\nτα πιο τολμηρά καράβια\nτης Ελλάδας.',
  'Ο Ντέμης έφτασε\nμε τα δυο του παιδιά\nγια ένα ήσυχο\nΣαββατοκύριακο.\n\nΤουλάχιστον,\nαυτό νόμιζε.',
];

// ════════════════════════════════════════════════════════════
// EASING
// ════════════════════════════════════════════════════════════
function easeInOutCubic(t) { return t < .5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3)/2; }

// ════════════════════════════════════════════════════════════
// COORDINATE CONVERSION
// ════════════════════════════════════════════════════════════
function screenToGame(sx, sy) {
  const rect = CVS.getBoundingClientRect();
  const scaleX = GW / rect.width;
  const scaleY = GH / rect.height;
  return { x: (sx - rect.left) * scaleX, y: (sy - rect.top) * scaleY };
}

// ════════════════════════════════════════════════════════════
// DUST PARTICLES (canvas-drawn)
// ════════════════════════════════════════════════════════════
const particles = [];
function initParticles() {
  particles.length = 0;
  for (let i = 0; i < 20; i++) {
    particles.push({
      x: Math.random() * GW,
      y: 60 + Math.random() * 240,
      vx: 0.1 + Math.random() * 0.25,
      vy: -0.05 - Math.random() * 0.12,
      size: 0.8 + Math.random() * 1.8,
      alpha: 0,
      maxAlpha: 0.12 + Math.random() * 0.18,
      life: Math.random() * 700,
      maxLife: 500 + Math.random() * 400,
    });
  }
}

function updateParticles() {
  for (const p of particles) {
    p.x += p.vx;
    p.y += p.vy;
    p.life++;
    const prog = p.life / p.maxLife;
    if (prog < 0.3) p.alpha = p.maxAlpha * (prog / 0.3) * (prog / 0.3); // quadratic fade-in
    else if (prog > 0.7) { const f = (prog - 0.7) / 0.3; p.alpha = p.maxAlpha * (1 - f * f); } // quadratic fade-out
    else p.alpha = p.maxAlpha;
    if (p.life >= p.maxLife || p.x > GW + 10 || p.y < -10) {
      p.x = -5 + Math.random() * 20;
      p.y = 80 + Math.random() * 200;
      p.life = 0;
      p.alpha = 0;
    }
  }
}

function drawParticles() {
  for (const p of particles) {
    if (p.alpha <= 0) continue;
    ctx.save();
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = '#D4A03C';
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

// ════════════════════════════════════════════════════════════
// CHARACTER RENDERING (ported from Galaxidi Adventure)
// ════════════════════════════════════════════════════════════
const CHAR_HEIGHTS = { ntemis: 118, ajax: 84, clio: 92 };

// Per-character anatomy: waist split ratio & max leg stride (pixels)
const WALK_ANATOMY = {
  ntemis: { waist: 0.62, stride: 7 },
  ajax:   { waist: 0.58, stride: 6 },
  clio:   { waist: 0.60, stride: 6 },
};

function drawSprite(who, gx, gy, dir, walking, frame, tick, frameOffset) {
  const img = CHAR_IMGS[who];
  if (!img || !img.complete || !img.naturalWidth) {
    drawFallbackPerson(gx, gy, who);
    return;
  }
  const sprW = img.naturalWidth;
  const sprH = img.naturalHeight;
  const anat = WALK_ANATOMY[who] || { waist: 0.60, stride: 6 };

  if (walking) {
    // ── WALK PHASE ──
    const walkPhase = frame * Math.PI * 3 + frameOffset * Math.PI / 3;
    const bob = -Math.abs(Math.sin(walkPhase)) * 3;
    const lean = dir * 0.025;
    const strideDir = Math.sin(walkPhase); // -1 to 1

    const waistY = Math.floor(sprH * anat.waist);
    const legH = sprH - waistY;
    const maxStride = anat.stride;

    // Ground shadow (stretches with stride)
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = '#4A3A28';
    const sw = sprW * 0.6 + Math.abs(strideDir) * 3;
    ctx.beginPath();
    ctx.ellipse(gx, gy + 3, sw, 3.5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.translate(gx, gy + bob);
    if (dir < 0) ctx.scale(-1, 1);
    ctx.rotate(lean);

    // ── UPPER BODY (slight counter-sway) ──
    const counterSway = -strideDir * 1.5;
    ctx.drawImage(img,
      0, 0, sprW, waistY,
      -sprW/2 + counterSway, -sprH, sprW, waistY
    );

    // ── BACK LEG (drawn first, darker, shifted opposite, lifted) ──
    const bandH = 2;
    ctx.save();
    ctx.globalAlpha = 0.7;
    for (let y = 0; y < legH; y += bandH) {
      const progress = y / Math.max(1, legH - 1);
      const backOff = -strideDir * maxStride * 0.7 * (0.3 + 0.7 * progress);
      const lift = Math.abs(strideDir) * 3 * progress;
      const h = Math.min(bandH, legH - y);
      ctx.drawImage(img,
        0, waistY + y, sprW, h,
        -sprW/2 + backOff, -sprH + waistY + y - lift, sprW, h
      );
    }
    ctx.restore();

    // ── FRONT LEG (on top, full brightness, shifted forward) ──
    for (let y = 0; y < legH; y += bandH) {
      const progress = y / Math.max(1, legH - 1);
      const frontOff = strideDir * maxStride * (0.3 + 0.7 * progress);
      const h = Math.min(bandH, legH - y);
      ctx.drawImage(img,
        0, waistY + y, sprW, h,
        -sprW/2 + frontOff, -sprH + waistY + y, sprW, h
      );
    }

    ctx.restore();

  } else {
    // ── IDLE ANIMATION ──
    const bp = tick * 0.03 + frameOffset * 3;
    const breathe = Math.sin(bp) * 1.0 + Math.sin(bp * 0.6 + 0.5) * 0.4;
    const sway = Math.sin(tick * 0.01 + frameOffset * 2.5) * 0.008
               + Math.sin(tick * 0.023 + frameOffset) * 0.003;
    const bc = Math.sin(bp);
    const squashX = 1 + bc * 0.005;
    const squashY = 1 - bc * 0.005;

    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = '#4A3A28';
    ctx.beginPath();
    ctx.ellipse(gx, gy + 3, sprW * 0.6, 4, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.translate(gx, gy + breathe);
    if (dir < 0) ctx.scale(-1, 1);
    ctx.rotate(sway);
    ctx.scale(squashX, squashY);
    ctx.drawImage(img, -sprW/2, -sprH);
    ctx.restore();
  }
}

function drawFallbackPerson(x, y, who) {
  const colors = {
    ntemis: { shirt: '#2A4466', pants: '#1a2a3a', skin: '#DDAA88' },
    ajax:   { shirt: '#4A6644', pants: '#2a3a2a', skin: '#DDBB99' },
    clio:   { shirt: '#664466', pants: '#3a2a3a', skin: '#DDC0A0' },
  };
  const c = colors[who] || colors.ntemis;
  const h = who === 'ntemis' ? 40 : 32;
  // Simple rectangle person
  ctx.fillStyle = c.skin;
  ctx.fillRect(x - 4, y - h, 8, 10); // head
  ctx.fillStyle = c.shirt;
  ctx.fillRect(x - 6, y - h + 10, 12, 14); // body
  ctx.fillStyle = c.pants;
  ctx.fillRect(x - 5, y - h + 24, 10, h - 24); // legs
}

function drawCharacter(who, tick) {
  const c = chars[who];
  if (!c.visible) return;
  const offsets = { ntemis: 0, ajax: 1.05, clio: 2.1 };
  // Fade-in alpha with smoothstep
  let alpha = Math.min(1, c.fadeIn);
  if (alpha < 1) {
    alpha = alpha * alpha * (3 - 2 * alpha); // smoothstep
    ctx.save();
    ctx.globalAlpha = alpha;
  }
  drawSprite(who, c.x, c.y, c.dir, c.walking, c.frame, tick, offsets[who]);
  if (alpha < 1) ctx.restore();
}

// ════════════════════════════════════════════════════════════
// WALKING SYSTEM
// ════════════════════════════════════════════════════════════
function startWalk(who, targetX, cb) {
  const c = chars[who];
  const dist = Math.abs(targetX - c.x);
  if (dist < 5) { if (cb) cb(); return; }
  targetX = Math.max(30, Math.min(GW - 30, targetX));
  c.dir = targetX > c.x ? 1 : -1;
  c.walking = true;
  c.startX = c.x;
  c.targetX = targetX;
  c.walkT = 0;
  c.walkDur = Math.max(0.4, Math.min(2.0, (dist / GW) * 2.5));
  c.frame = 0;
  walkDoneCallback = cb;
}

function updateWalking(dt) {
  for (const who of ['ntemis','ajax','clio']) {
    const c = chars[who];
    if (!c.walking) continue;
    c.walkT += dt;
    const p = Math.min(1, c.walkT / c.walkDur);
    const ep = easeInOutCubic(p);
    c.x = c.startX + (c.targetX - c.startX) * ep;

    // Store raw walk time for smooth interpolation in drawSprite
    c.frame = c.walkT;

    if (p >= 1) {
      c.x = c.targetX;
      c.walking = false;
      c.targetX = null;
      c.dir = 1;
      if (who === 'ntemis' && walkDoneCallback) {
        const cb = walkDoneCallback;
        walkDoneCallback = null;
        cb();
      }
    }
  }
}

// Family follow: Ajax and Clio follow Ntemis with offset
function familyFollow(targetX) {
  const nX = targetX;
  // Ajax follows to the right, Clio to the left
  const ajaxTarget = Math.min(GW - 30, nX + 70);
  const clioTarget = Math.max(30, nX - 70);
  setTimeout(() => startWalk('ajax', ajaxTarget), 150);
  setTimeout(() => startWalk('clio', clioTarget), 280);
}

// ════════════════════════════════════════════════════════════
// HOTSPOT HIT TESTING
// ════════════════════════════════════════════════════════════
function hitTestObj(gx, gy) {
  if (!state.scene) return null;
  const sc = scenes[state.scene];
  for (const obj of sc.objects) {
    if (gx >= obj.x && gx <= obj.x + obj.w && gy >= obj.y && gy <= obj.y + obj.h) {
      return obj;
    }
  }
  return null;
}

function hitTestExit(gx, gy) {
  if (!state.scene) return null;
  const sc = scenes[state.scene];
  if (!sc.exits) return null;
  for (const exit of sc.exits) {
    if (exit.side === 'left' && gx < 25) return exit;
    if (exit.side === 'right' && gx > GW - 25) return exit;
  }
  return null;
}

// ════════════════════════════════════════════════════════════
// DIALOGUE SYSTEM
// ════════════════════════════════════════════════════════════
function showDlg(lines, cb) {
  const filtered = lines.filter(l => l.t);
  if (!filtered.length) { if (cb) cb(); return; }
  state.dlg.queue = [...filtered];
  state.dlg.active = true;
  state.dlg.cb = cb || null;
  nextDlgLine();
}

function nextDlgLine() {
  if (!state.dlg.queue.length) { closeDlg(); return; }
  const l = state.dlg.queue.shift();
  state.dlg.speaker = l.s || '';
  state.dlg.text = l.t;
  state.dlg.displayed = '';
  state.dlg.charIdx = 0;
  state.dlg.timer = 0;
}

function updateDlg(dt) {
  if (!state.dlg.active) return;
  if (state.dlg.charIdx < state.dlg.text.length) {
    state.dlg.timer += dt;
    while (state.dlg.timer >= 0.03 && state.dlg.charIdx < state.dlg.text.length) {
      state.dlg.timer -= 0.03;
      state.dlg.charIdx++;
      state.dlg.displayed = state.dlg.text.substring(0, state.dlg.charIdx);
    }
  }
}

function advanceDlg() {
  if (!state.dlg.active) return;
  if (state.dlg.charIdx < state.dlg.text.length) {
    // Skip typewriter
    state.dlg.charIdx = state.dlg.text.length;
    state.dlg.displayed = state.dlg.text;
  } else {
    nextDlgLine();
  }
}

function closeDlg() {
  state.dlg.active = false;
  state.dlg.queue = [];
  if (state.dlg.cb) { const cb = state.dlg.cb; state.dlg.cb = null; cb(); }
  checkEnd();
}

function drawDialogue() {
  if (!state.dlg.active) return;
  const boxH = 90;
  const boxY = GH - boxH;

  // Background
  ctx.save();
  ctx.globalAlpha = 0.92;
  ctx.fillStyle = '#0a0806';
  ctx.fillRect(0, boxY, GW, boxH);
  ctx.restore();

  // Top border
  ctx.fillStyle = '#D4A03C';
  ctx.fillRect(0, boxY, GW, 2);

  // Portrait — only show for named speakers
  const portSize = 56;
  const portX = 12;
  const portY = boxY + 8;
  const hasSpeaker = !!state.dlg.speaker;

  let textX;
  if (hasSpeaker) {
    ctx.strokeStyle = '#D4A03C';
    ctx.lineWidth = 2;
    ctx.strokeRect(portX, portY, portSize, portSize);
    ctx.fillStyle = '#1a1714';
    ctx.fillRect(portX + 1, portY + 1, portSize - 2, portSize - 2);

    const portImg = PORTRAITS[state.dlg.speaker];
    if (portImg && portImg.complete) {
      ctx.drawImage(portImg, portX + 2, portY + 2, portSize - 4, portSize - 4);
    } else {
      ctx.fillStyle = '#4a4a4a';
      ctx.font = '16px serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('?', portX + portSize/2, portY + portSize/2);
    }

    textX = portX + portSize + 12;

    ctx.fillStyle = '#D4A03C';
    ctx.font = '9px "Press Start 2P", monospace';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText(state.dlg.speaker, textX, portY + 2);
  } else {
    // Narration — no portrait box, full width
    textX = 16;
  }

  // Dialogue text with word wrapping
  ctx.fillStyle = hasSpeaker ? '#e8dcc8' : '#D4A03C';
  ctx.font = '8px "Press Start 2P", monospace';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  const maxW = GW - textX - 16;
  const lineH = 16;
  const startY = portY + (state.dlg.speaker ? 18 : 6);
  wrapText(state.dlg.displayed, textX, startY, maxW, lineH);

  // Continue indicator
  if (state.dlg.charIdx >= state.dlg.text.length) {
    const blink = Math.sin(state.tick * 0.12) > 0;
    if (blink) {
      ctx.fillStyle = '#4a4a4a';
      ctx.font = '8px "Press Start 2P", monospace';
      ctx.textAlign = 'right';
      ctx.fillText('▶', GW - 12, boxY + boxH - 14);
    }
  }
}

function wrapText(text, x, y, maxW, lineH) {
  const words = text.split(' ');
  let line = '';
  let curY = y;
  for (const word of words) {
    const test = line ? line + ' ' + word : word;
    const m = ctx.measureText(test);
    if (m.width > maxW && line) {
      ctx.fillText(line, x, curY);
      line = word;
      curY += lineH;
    } else {
      line = test;
    }
  }
  if (line) ctx.fillText(line, x, curY);
}

// ════════════════════════════════════════════════════════════
// VERB SYSTEM
// ════════════════════════════════════════════════════════════
const verbLabels = { look:'Κοίταξε', talk:'Μίλησε', open:'Άνοιξε', use:'Χρησιμοποίησε' };
// Verb fallbacks: "use" tries pick/push/close; "open" tries use
const verbFallbacks = { use: ['pick','push','close','open'], open: ['use'] };

function setVerb(v) {
  state.verb = v;
  document.querySelectorAll('.vb').forEach(b => b.classList.remove('on'));
  document.querySelector(`[data-v="${v}"]`)?.classList.add('on');
  updateActionLine();
}

function updateActionLine() {
  const al = document.getElementById('action-line');
  const obj = state.hoverObj;
  al.textContent = obj ? `${verbLabels[state.verb]} ${obj.label}` : (verbLabels[state.verb] || '');
}

function objClick(obj) {
  if (state.dlg.active) return;
  const objCenterX = obj.x + obj.w / 2;

  // Walk Ntemis to object, then execute verb
  startWalk('ntemis', objCenterX, () => {
    let d = obj.verbs[state.verb];
    // Verb fallback: "use" tries open/push/close if no direct match
    if (!d && verbFallbacks[state.verb]) {
      for (const fb of verbFallbacks[state.verb]) {
        if (obj.verbs[fb]) { d = obj.verbs[fb]; break; }
      }
    }
    if (!d) {
      const defs = {
        look:[{s:'',t:'Τίποτα ιδιαίτερο.'}],
        talk:[{s:'ΝΤΕΜΗΣ',t:'Δεν μπορώ να μιλήσω σε αυτό.'}],
        open:[{s:'ΝΤΕΜΗΣ',t:'Δεν ανοίγει.'}],
        use:[{s:'ΝΤΕΜΗΣ',t:'Δεν ξέρω πώς.'}],
      };
      if (defs[state.verb]?.length) showDlg(defs[state.verb]);
      return;
    }
    if (typeof d === 'string') { changeScene(d); return; }
    if (typeof d === 'function') d = d();
    if (Array.isArray(d) && d.length) showDlg(d);
  });
  familyFollow(objCenterX);
}

// ════════════════════════════════════════════════════════════
// INVENTORY
// ════════════════════════════════════════════════════════════
function addInv(item) {
  if (state.inv.find(i => i.id === item.id)) return;
  state.inv.push(item);
  renderInvUI();
}

// Inventory item icons — pixel art drawn on mini canvases (52x52)
const INV_ICONS = {
  note: (c) => {
    // Rolled scroll with wax seal
    c.fillStyle='#c4a870'; c.fillRect(12,4,28,40);
    c.fillStyle='#d8c490'; c.fillRect(14,6,24,36);
    // Roll top
    c.fillStyle='#b09058'; c.fillRect(10,4,32,5);
    c.fillStyle='#c4a870';
    c.beginPath(); c.ellipse(10,7,3,4,0,0,Math.PI*2); c.fill();
    c.beginPath(); c.ellipse(42,7,3,4,0,0,Math.PI*2); c.fill();
    // Text lines
    c.fillStyle='#8a7a58';
    for(let y=14;y<38;y+=5) c.fillRect(18,y,18,2);
    // Wax seal
    c.fillStyle='#b03030'; c.beginPath(); c.arc(36,38,5,0,Math.PI*2); c.fill();
    c.fillStyle='#d04040'; c.beginPath(); c.arc(35,37,3,0,Math.PI*2); c.fill();
    // "Γ" on seal
    c.fillStyle='#e8c8c8'; c.font='bold 5px sans-serif'; c.textAlign='center'; c.textBaseline='middle';
    c.fillText('Γ',36,38);
  },
  compass: (c) => {
    // Brass compass body
    c.fillStyle='#8a6a30'; c.beginPath(); c.arc(26,26,18,0,Math.PI*2); c.fill();
    c.fillStyle='#b08838'; c.beginPath(); c.arc(26,26,16,0,Math.PI*2); c.fill();
    c.fillStyle='#1a1810'; c.beginPath(); c.arc(26,26,14,0,Math.PI*2); c.fill();
    // Compass rose
    c.fillStyle='#c03030'; c.beginPath(); c.moveTo(26,12); c.lineTo(28,26); c.lineTo(24,26); c.fill();
    c.fillStyle='#e0d0c0'; c.beginPath(); c.moveTo(26,40); c.lineTo(28,26); c.lineTo(24,26); c.fill();
    c.fillStyle='#607090'; c.beginPath(); c.moveTo(12,26); c.lineTo(26,24); c.lineTo(26,28); c.fill();
    c.fillStyle='#607090'; c.beginPath(); c.moveTo(40,26); c.lineTo(26,24); c.lineTo(26,28); c.fill();
    // Center pin
    c.fillStyle='#d4a03c'; c.beginPath(); c.arc(26,26,2,0,Math.PI*2); c.fill();
    // N marker
    c.fillStyle='#c03030'; c.font='bold 5px sans-serif'; c.textAlign='center'; c.fillText('N',26,11);
  },
  shell: (c) => {
    // Scallop shell
    c.fillStyle='#e8d0b0'; c.beginPath(); c.ellipse(26,28,16,12,0,0,Math.PI*2); c.fill();
    c.fillStyle='#d4b89c'; c.beginPath(); c.ellipse(26,30,14,10,0,0,Math.PI); c.fill();
    // Ridges
    c.strokeStyle='#a08060'; c.lineWidth=1.5;
    for(let i=0;i<7;i++){c.beginPath();c.moveTo(26,16);c.lineTo(12+i*5,40);c.stroke();}
    // Highlight
    c.fillStyle='rgba(255,255,255,0.2)'; c.beginPath(); c.ellipse(22,24,6,4,-.3,0,Math.PI*2); c.fill();
  },
  candle: (c) => {
    // Candlestick with flame
    c.fillStyle='#8a6a30'; c.fillRect(20,36,12,8); // base
    c.fillStyle='#a08038'; c.fillRect(22,34,8,4); // holder
    c.fillStyle='#e8dcc0'; c.fillRect(24,16,4,20); // wax body
    c.fillStyle='#d4c8a0'; c.fillRect(23,16,6,3); // wax top
    // Wick
    c.fillStyle='#2a2a2a'; c.fillRect(25,12,2,5);
    // Flame
    c.fillStyle='#d4a03c'; c.beginPath(); c.ellipse(26,10,5,8,0,0,Math.PI*2); c.fill();
    c.fillStyle='#f0d060'; c.beginPath(); c.ellipse(26,10,3,5,0,0,Math.PI*2); c.fill();
    c.fillStyle='#fff8e0'; c.beginPath(); c.ellipse(26,11,1,3,0,0,Math.PI*2); c.fill();
  },
  key: (c) => {
    // Ornate brass key
    c.fillStyle='#c49030'; c.strokeStyle='#8a6020'; c.lineWidth=1;
    // Bow (head)
    c.beginPath(); c.arc(16,20,8,0,Math.PI*2); c.fill(); c.stroke();
    c.fillStyle='#1a1208'; c.beginPath(); c.arc(16,20,4,0,Math.PI*2); c.fill();
    // Shaft
    c.fillStyle='#c49030'; c.fillRect(23,18,20,4);
    c.strokeStyle='#8a6020'; c.strokeRect(23,18,20,4);
    // Teeth
    c.fillStyle='#c49030';
    c.fillRect(38,22,3,6); c.fillRect(34,22,2,4); c.fillRect(42,18,2,4);
    c.strokeStyle='#8a6020';
    c.strokeRect(38,22,3,6); c.strokeRect(34,22,2,4);
  },
};

function renderInvUI() {
  const grid = document.getElementById('inv-grid');
  grid.innerHTML = '';
  for (const item of state.inv) {
    const slot = document.createElement('div');
    slot.className = 'inv-slot';
    slot.dataset.id = item.id;
    slot.onclick = () => invClick(item.id);
    if (INV_ICONS[item.id]) {
      const cvs = document.createElement('canvas');
      cvs.width = 52; cvs.height = 52;
      cvs.style.cssText = 'width:52px;height:52px;image-rendering:pixelated';
      INV_ICONS[item.id](cvs.getContext('2d'));
      slot.appendChild(cvs);
    } else {
      const txt = document.createElement('span');
      txt.className = 'inv-text';
      txt.textContent = item.label;
      slot.appendChild(txt);
    }
    slot.title = item.label;
    grid.appendChild(slot);
  }
}

function scrollInv(dir) {
  const grid = document.getElementById('inv-grid');
  grid.scrollLeft += dir * 50;
}

function invClick(id) {
  if (id === 'note' && state.verb === 'look') {
    showDlg([{s:'',t:'«Σας περιμέναμε. Ελάτε στο λιμάνι απόψε. Τραπέζι για τρεις. — Γ.»'},{s:'',t:'Το χαρτί μυρίζει θάλασσα. Παλιομοδίτικο γράψιμο.'}]);
  }
  document.querySelectorAll('.inv-slot').forEach(s => s.classList.remove('on'));
  document.querySelector(`[data-id="${id}"]`)?.classList.add('on');
}

// ════════════════════════════════════════════════════════════
// SCENE MANAGEMENT
// ════════════════════════════════════════════════════════════
function startScene(id) {
  const sc = scenes[id];
  state.scene = id;
  state.hoverObj = null;

  document.getElementById('ui-panel').classList.add('on');
  document.getElementById('action-line').classList.add('on');

  // Position characters
  for (const [who, pos] of Object.entries(sc.charPos)) {
    chars[who].x = pos.x;
    chars[who].y = pos.y;
    chars[who].walking = false;
    chars[who].visible = true;
    chars[who].fadeIn = 0; // start fade-in
    chars[who].dir = 1;
  }

  initParticles();

  // Entry dialogue
  if (!state.visited.has(id) && sc.entry) {
    state.visited.add(id);
    setTimeout(() => showDlg(sc.entry), 600);
  } else {
    state.visited.add(id);
  }
}

function changeScene(id) {
  state.fade.active = true;
  state.fade.alpha = 0;
  state.fade.dir = 1; // fade out
  state.fade.cb = () => {
    startScene(id);
    state.fade.dir = -1; // fade in
    state.fade.cb = () => { state.fade.active = false; };
  };
}

function checkEnd() {
  if (state.flags.note && !state.flags.done) {
    state.flags.done = 1;
    setTimeout(() => showDlg([
      {s:'ΝΤΕΜΗΣ',t:'«Σας περιμέναμε»... Ποιος μας περιμένει;'},
      {s:'ΚΛΕΙΩ',t:'Ο «Γ.» ξέρει ότι είμαστε τρεις. Πρέπει να πάμε.'},
      {s:'ΑΙΑΣ',t:'Πάμε στο λιμάνι!'},
      {s:'',t:'Ο ήλιος βυθίζεται πίσω από τα βουνά. Το λιμάνι περιμένει.'},
      {s:'',t:'— Τέλος Σκηνής 1 —'},
      {s:'',t:'Συνέχεια στη Σκηνή 2: Το Γράμμα...'},
    ]), 1500);
  }
}

// ════════════════════════════════════════════════════════════
// RENDER — Main drawing function
// ════════════════════════════════════════════════════════════
function render() {
  ctx.clearRect(0, 0, GW, GH);

  // Canvas-rendered title screen
  if (state.phase === 'title') {
    drawTitleScreen(state.tick);
    return;
  }

  if (state.phase !== 'playing') return;
  if (!state.scene) return;

  const sc = scenes[state.scene];

  // Background
  const bgImg = images[sc.bg];
  if (bgImg) {
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(bgImg, 0, 0, GW, GH);
  } else {
    ctx.fillStyle = '#1a1510';
    ctx.fillRect(0, 0, GW, GH);
  }

  // Ambient overlay
  const grad = ctx.createLinearGradient(0, 0, 0, GH);
  grad.addColorStop(0, 'rgba(212,160,60,0.03)');
  grad.addColorStop(0.3, 'rgba(0,0,0,0)');
  grad.addColorStop(0.7, 'rgba(0,0,0,0)');
  grad.addColorStop(1, 'rgba(0,0,0,0.15)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, GW, GH);

  // Dust particles
  drawParticles();

  // Hotspot highlight on hover
  if (state.hoverObj) {
    const obj = state.hoverObj;
    ctx.save();
    ctx.strokeStyle = 'rgba(212,160,60,0.4)';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
    ctx.setLineDash([]);
    ctx.restore();
  }

  // Exit zone highlights
  if (sc.exits) {
    for (const exit of sc.exits) {
      const isHover = (exit.side === 'left' && state.mouseGX < 25) ||
                      (exit.side === 'right' && state.mouseGX > GW - 25);
      if (isHover) {
        ctx.save();
        const exGrad = exit.side === 'left'
          ? ctx.createLinearGradient(0, 0, 25, 0)
          : ctx.createLinearGradient(GW, 0, GW - 25, 0);
        exGrad.addColorStop(0, 'rgba(212,160,60,0.15)');
        exGrad.addColorStop(1, 'rgba(212,160,60,0)');
        ctx.fillStyle = exGrad;
        if (exit.side === 'left') ctx.fillRect(0, 0, 25, GH);
        else ctx.fillRect(GW - 25, 0, 25, GH);
        // Arrow
        ctx.fillStyle = '#D4A03C';
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        if (exit.side === 'left') ctx.fillText('◀', 12, GH / 2);
        else ctx.fillText('▶', GW - 12, GH / 2);
        ctx.restore();
      }
    }
  }

  // Characters — back to front for depth
  drawCharacter('clio', state.tick);
  drawCharacter('ajax', state.tick);
  drawCharacter('ntemis', state.tick);

  // Scene label
  ctx.save();
  ctx.fillStyle = '#D4A03C';
  ctx.font = '8px "Press Start 2P", monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.shadowColor = '#000';
  ctx.shadowBlur = 4;
  ctx.shadowOffsetX = 2;
  ctx.shadowOffsetY = 2;
  ctx.fillText(sc.label, GW / 2, 8);
  ctx.restore();

  // Music toggle icon
  ctx.save();
  ctx.globalAlpha = state.musicOn ? 0.5 : 0.2;
  ctx.fillStyle = '#D4A03C';
  ctx.font = '14px sans-serif';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'top';
  ctx.fillText('♪', GW - 8, 8);
  ctx.restore();

  // Dialogue overlay
  drawDialogue();

  // Fade overlay
  if (state.fade.active && state.fade.alpha > 0) {
    ctx.save();
    ctx.globalAlpha = state.fade.alpha;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, GW, GH);
    ctx.restore();
  }
}

// ════════════════════════════════════════════════════════════
// UPDATE — Main logic update
// ════════════════════════════════════════════════════════════
function update(dt) {
  state.tick++;

  // Title screen — start music on first interaction (handled by click)
  if (state.phase === 'title') return;

  if (state.phase !== 'playing') return;

  // Walking
  updateWalking(dt);

  // Character fade-in
  for (const who of ['ntemis','ajax','clio']) {
    if (chars[who].fadeIn < 1) {
      const delays = { ntemis: 0.1, ajax: 0.3, clio: 0.5 };
      if (state.tick > delays[who] * 60) {
        chars[who].fadeIn = Math.min(1, chars[who].fadeIn + dt * 1.5);
      }
    }
  }

  // Dialogue typewriter
  updateDlg(dt);

  // Particles
  updateParticles();

  // Fade transition
  if (state.fade.active) {
    const speed = 2.0; // fade speed (slower = smoother)
    state.fade.alpha += state.fade.dir * dt * speed;
    if (state.fade.dir > 0 && state.fade.alpha >= 1) {
      state.fade.alpha = 1;
      if (state.fade.cb) { const cb = state.fade.cb; state.fade.cb = null; cb(); }
    }
    if (state.fade.dir < 0 && state.fade.alpha <= 0) {
      state.fade.alpha = 0;
      if (state.fade.cb) { const cb = state.fade.cb; state.fade.cb = null; cb(); }
    }
  }
}

// ════════════════════════════════════════════════════════════
// GAME LOOP
// ════════════════════════════════════════════════════════════
let lastTime = 0;

function gameLoop(timestamp) {
  const dt = lastTime ? Math.min((timestamp - lastTime) / 1000, 0.05) : 0.016;
  lastTime = timestamp;

  // Resize canvas to fill available space
  const rect = CVS.getBoundingClientRect();
  // Keep internal resolution fixed, CSS handles scaling

  update(dt);
  render();
  requestAnimationFrame(gameLoop);
}

// ════════════════════════════════════════════════════════════
// INPUT HANDLING
// ════════════════════════════════════════════════════════════
CVS.addEventListener('mousemove', (e) => {
  const g = screenToGame(e.clientX, e.clientY);
  state.mouseGX = g.x;
  state.mouseGY = g.y;

  if (state.phase === 'title') {
    CVS.style.cursor = 'pointer';
    return;
  }

  if (state.phase !== 'playing' || state.dlg.active) {
    state.hoverObj = null;
    updateActionLine();
    return;
  }

  // Check hotspots
  const obj = hitTestObj(g.x, g.y);
  state.hoverObj = obj;

  // Check exits for cursor change
  const exit = hitTestExit(g.x, g.y);
  if (exit) {
    CVS.style.cursor = exit.side === 'left' ? 'w-resize' : 'e-resize';
    state.hoverObj = { label: exit.label }; // fake obj for action line
  } else if (obj) {
    CVS.style.cursor = 'pointer';
  } else {
    CVS.style.cursor = 'crosshair';
  }
  updateActionLine();
});

CVS.addEventListener('click', (e) => {
  const g = screenToGame(e.clientX, e.clientY);

  // Title clicks handled by dedicated handler
  if (state.phase !== 'playing') return;

  // Dialogue advance
  if (state.dlg.active) { advanceDlg(); return; }

  // Music toggle (top-right corner)
  if (g.x > GW - 30 && g.y < 25) { toggleMusic(); return; }

  // Check exit zones
  const exit = hitTestExit(g.x, g.y);
  if (exit) { changeScene(exit.target); return; }

  // Check hotspots
  const obj = hitTestObj(g.x, g.y);
  if (obj) { objClick(obj); return; }

  // Click ground — walk Ntemis
  if (g.y > 200) { // Only walk on ground area
    startWalk('ntemis', g.x);
    familyFollow(g.x);
  }
});

// Keyboard
document.addEventListener('keydown', e => {
  if (e.key === ' ' || e.key === 'Enter') {
    e.preventDefault();
    if (state.dlg.active) advanceDlg();
  }
  const vk = {'1':'look','2':'talk','3':'open','4':'use'};
  if (vk[e.key] && state.phase === 'playing') setVerb(vk[e.key]);
});

// ════════════════════════════════════════════════════════════
// MUSIC
// ════════════════════════════════════════════════════════════
const bgm = document.getElementById('bgm');
bgm.volume = 0.25;

function toggleMusic() {
  if (state.musicOn) {
    bgm.pause(); state.musicOn = false;
  } else {
    bgm.play().catch(() => {}); state.musicOn = true;
  }
}

// ════════════════════════════════════════════════════════════
// TITLE SCREEN — Indiana Jones / LucasArts style
// ════════════════════════════════════════════════════════════
const titleMusic = document.getElementById('title-music');
titleMusic.volume = 0.35;
let titleFadeOut = 0;

function drawTitleScreen(tick) {
  const t = tick * 0.02;

  // ── SKY — clear blue gradient like Indy's desert sky ──
  const skyGrad = ctx.createLinearGradient(0, 0, 0, 85);
  skyGrad.addColorStop(0, '#2848A0');
  skyGrad.addColorStop(0.3, '#3868B8');
  skyGrad.addColorStop(0.6, '#5088CC');
  skyGrad.addColorStop(0.85, '#70A0D8');
  skyGrad.addColorStop(1, '#88B4E0');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, GW, 85);

  // Distant mountains / headland silhouette (like Indy's horizon)
  ctx.save();
  ctx.fillStyle = '#4A6888';
  ctx.beginPath();
  ctx.moveTo(0, 85);
  ctx.lineTo(0, 72);
  ctx.quadraticCurveTo(80, 55, 160, 68);
  ctx.quadraticCurveTo(220, 75, 280, 62);
  ctx.quadraticCurveTo(350, 50, 420, 65);
  ctx.quadraticCurveTo(500, 72, 560, 58);
  ctx.quadraticCurveTo(610, 68, GW, 70);
  ctx.lineTo(GW, 85);
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  // ═══════════════════════════════════════════════════
  // SHIP HULL — fills most of the screen (the "boxcar")
  // Exact same role as the train car in Indy
  // ═══════════════════════════════════════════════════
  const hullTop = 75;
  const hullBot = 350;
  const hullL = -8;
  const hullR = GW + 8;
  const hullH = hullBot - hullTop;

  function hullPath() {
    ctx.beginPath();
    // Flat top deck line — edge to edge
    ctx.moveTo(hullL, hullTop + 8);
    ctx.lineTo(hullR, hullTop + 8);
    // Right side (stern) — slight inward curve at bottom
    ctx.lineTo(hullR + 4, hullBot - 20);
    ctx.quadraticCurveTo(hullR - 50, hullBot + 12, GW * 0.55, hullBot + 6);
    // Bottom keel curve
    ctx.quadraticCurveTo(GW * 0.25, hullBot + 2, hullL - 4, hullBot - 35);
    // Left side (bow)
    ctx.closePath();
  }

  // ── Hull fill ──
  ctx.save();
  hullPath();
  const woodGrad = ctx.createLinearGradient(0, hullTop, 0, hullBot);
  woodGrad.addColorStop(0, '#8B5A30');
  woodGrad.addColorStop(0.05, '#7A4C28');
  woodGrad.addColorStop(0.15, '#8B5530');
  woodGrad.addColorStop(0.35, '#7A4422');
  woodGrad.addColorStop(0.5, '#6E3C1E');
  woodGrad.addColorStop(0.65, '#7A4422');
  woodGrad.addColorStop(0.8, '#5E3018');
  woodGrad.addColorStop(0.92, '#4A2410');
  woodGrad.addColorStop(1, '#3A1A0C');
  ctx.fillStyle = woodGrad;
  ctx.fill();
  ctx.clip();

  // ── Wood planks — horizontal lines with varying darkness ──
  for (let y = hullTop + 6; y < hullBot; y += 12) {
    // Dark groove line
    const groove = 0.3 + Math.sin(y * 0.2) * 0.12;
    ctx.strokeStyle = `rgba(25,12,4,${groove})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(hullL - 10, y);
    ctx.lineTo(hullR + 10, y);
    ctx.stroke();
    // Light edge below (wood catch light)
    ctx.strokeStyle = `rgba(180,130,75,${0.06 + Math.sin(y * 0.15) * 0.03})`;
    ctx.beginPath();
    ctx.moveTo(hullL - 10, y + 1);
    ctx.lineTo(hullR + 10, y + 1);
    ctx.stroke();
  }

  // Vertical plank seams — staggered like real planking
  ctx.strokeStyle = 'rgba(25,12,4,0.18)';
  for (let row = 0; row < Math.ceil(hullH / 12); row++) {
    const y = hullTop + 6 + row * 12;
    const offset = (row % 3) * 70 + 30;
    for (let x = hullL + offset; x < hullR; x += 200) {
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x, y + 12);
      ctx.stroke();
    }
  }

  // ── KNOT HOLES — random wood details ──
  const knots = [[85, 140], [310, 200], [480, 165], [180, 280], [540, 310], [390, 120]];
  for (const [kx, ky] of knots) {
    ctx.beginPath();
    ctx.ellipse(kx, ky, 4, 3, 0.3, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(50,25,10,0.25)';
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(kx, ky, 2, 1.5, 0.3, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(30,15,5,0.2)';
    ctx.fill();
  }

  // ═══════════════════════════════════════
  // IRON BANDS with rivets (like train rails)
  // ═══════════════════════════════════════

  // Top gunwale band (thick)
  ctx.fillStyle = '#2E1408';
  ctx.fillRect(hullL, hullTop + 8, hullR - hullL, 14);
  // Highlight on top edge
  ctx.fillStyle = 'rgba(140,90,45,0.2)';
  ctx.fillRect(hullL, hullTop + 8, hullR - hullL, 2);
  // Dark bottom edge
  ctx.fillStyle = 'rgba(10,4,0,0.3)';
  ctx.fillRect(hullL, hullTop + 20, hullR - hullL, 2);
  // Rivets
  for (let x = 20; x < GW; x += 38) {
    ctx.beginPath();
    ctx.arc(x, hullTop + 15, 4, 0, Math.PI * 2);
    ctx.fillStyle = '#3A1E0C';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x - 1, hullTop + 14, 2, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(160,110,55,0.25)';
    ctx.fill();
  }

  // Upper wale band
  const wale1Y = hullTop + 38;
  ctx.fillStyle = '#281008';
  ctx.fillRect(hullL, wale1Y, hullR - hullL, 6);
  ctx.fillStyle = 'rgba(130,85,40,0.12)';
  ctx.fillRect(hullL, wale1Y, hullR - hullL, 1);

  // Lower wale band
  const wale2Y = hullBot - 68;
  ctx.fillStyle = '#281008';
  ctx.fillRect(hullL, wale2Y, hullR - hullL, 8);
  ctx.fillStyle = 'rgba(130,85,40,0.1)';
  ctx.fillRect(hullL, wale2Y, hullR - hullL, 1);
  // Rivets on lower band
  for (let x = 35; x < GW; x += 42) {
    ctx.beginPath();
    ctx.arc(x, wale2Y + 4, 3.5, 0, Math.PI * 2);
    ctx.fillStyle = '#3A1E0C';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x - 0.5, wale2Y + 3, 1.5, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(150,100,50,0.2)';
    ctx.fill();
  }

  // Copper sheathing at bottom (greenish tint — authentic detail)
  const copperY = hullBot - 30;
  const copperGrad = ctx.createLinearGradient(0, copperY, 0, hullBot + 10);
  copperGrad.addColorStop(0, 'rgba(60,75,55,0.3)');
  copperGrad.addColorStop(1, 'rgba(45,60,45,0.5)');
  ctx.fillStyle = copperGrad;
  ctx.fillRect(hullL, copperY, hullR - hullL, hullBot - copperY + 15);

  // ── PORTHOLES (7 across) ──
  for (let i = 0; i < 7; i++) {
    const px = 60 + i * 80;
    const py = hullBot - 90;
    // Cast shadow
    ctx.beginPath();
    ctx.arc(px + 2, py + 2, 11, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(10,4,0,0.3)';
    ctx.fill();
    // Brass ring
    ctx.beginPath();
    ctx.arc(px, py, 11, 0, Math.PI * 2);
    ctx.fillStyle = '#4A2A10';
    ctx.fill();
    // Inner recess
    ctx.beginPath();
    ctx.arc(px, py, 8, 0, Math.PI * 2);
    ctx.fillStyle = '#1a0e05';
    ctx.fill();
    // Glass
    ctx.beginPath();
    ctx.arc(px, py, 6, 0, Math.PI * 2);
    const glassG = ctx.createRadialGradient(px - 2, py - 2, 0, px, py, 6);
    glassG.addColorStop(0, 'rgba(80,120,170,0.25)');
    glassG.addColorStop(1, 'rgba(15,25,45,0.4)');
    ctx.fillStyle = glassG;
    ctx.fill();
    // Specular
    ctx.beginPath();
    ctx.arc(px - 2, py - 2, 2.5, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(200,220,255,0.2)';
    ctx.fill();
  }

  // ── Warm sunlight patch on hull ──
  const sunGrad = ctx.createRadialGradient(GW * 0.35, hullTop + 100, 30, GW * 0.35, hullTop + 100, 300);
  sunGrad.addColorStop(0, 'rgba(240,180,70,0.06)');
  sunGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = sunGrad;
  ctx.fillRect(hullL, hullTop, hullR - hullL, hullH);

  ctx.restore(); // un-clip

  // ── Hull outline ──
  ctx.save();
  hullPath();
  ctx.strokeStyle = '#140804';
  ctx.lineWidth = 4;
  ctx.stroke();
  ctx.restore();

  // ── DECK RAILING ──
  ctx.save();
  // Main rail
  ctx.strokeStyle = '#5E3418';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(0, hullTop + 6);
  ctx.lineTo(GW, hullTop + 6);
  ctx.stroke();
  // Stanchions
  ctx.lineWidth = 2;
  for (let x = 18; x < GW; x += 28) {
    ctx.beginPath();
    ctx.moveTo(x, hullTop + 6);
    ctx.lineTo(x, hullTop - 10);
    ctx.stroke();
    ctx.fillStyle = '#6A3820';
    ctx.fillRect(x - 2, hullTop - 12, 4, 3);
  }
  // Top rail
  ctx.strokeStyle = '#5E3418';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, hullTop - 10);
  ctx.lineTo(GW, hullTop - 10);
  ctx.stroke();
  ctx.restore();

  // ── MASTS with detailed rigging ──
  ctx.save();
  const m1 = GW * 0.28, m2 = GW * 0.72;
  // Mast poles
  ctx.fillStyle = '#4E2A14';
  ctx.fillRect(m1 - 4, hullTop - 60, 8, 68);
  ctx.fillRect(m2 - 4, hullTop - 68, 8, 76);
  // Yards (cross beams)
  ctx.fillStyle = '#3E1E0E';
  ctx.fillRect(m1 - 42, hullTop - 48, 84, 5);
  ctx.fillRect(m1 - 30, hullTop - 35, 60, 4);
  ctx.fillRect(m2 - 48, hullTop - 55, 96, 5);
  ctx.fillRect(m2 - 36, hullTop - 40, 72, 4);
  // Furled sails (rolled tubes on yards)
  ctx.fillStyle = 'rgba(200,185,155,0.35)';
  ctx.fillRect(m1 - 38, hullTop - 50, 76, 4);
  ctx.fillRect(m2 - 44, hullTop - 57, 88, 4);
  // Rigging lines
  ctx.strokeStyle = 'rgba(80,55,25,0.35)';
  ctx.lineWidth = 1;
  [[m1,hullTop-58, 10,hullTop+6], [m1,hullTop-58, m1+110,hullTop+6],
   [m2,hullTop-66, m2-120,hullTop+6], [m2,hullTop-66, GW-8,hullTop+6],
   [m1,hullTop-58, m2,hullTop-66],
   [m1-40,hullTop-48, m1-40,hullTop+6], [m1+40,hullTop-48, m1+40,hullTop+6],
   [m2-46,hullTop-55, m2-46,hullTop+6], [m2+46,hullTop-55, m2+46,hullTop+6],
  ].forEach(([x1,y1,x2,y2]) => {
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  });
  // Crow's nests
  ctx.fillStyle = '#3A1E0E';
  ctx.fillRect(m1 - 10, hullTop - 62, 20, 4);
  ctx.fillRect(m2 - 11, hullTop - 70, 22, 4);
  // Greek flag on mainmast
  const fX = m2 + 5, fY = hullTop - 68;
  // Flag waves gently
  const flagWave = Math.sin(t * 2) * 2;
  ctx.fillStyle = '#1848A0';
  ctx.fillRect(fX, fY - 11, 20, 12);
  ctx.fillStyle = '#FFFFFF';
  ctx.fillRect(fX, fY - 9, 20, 2);
  ctx.fillRect(fX, fY - 4, 20, 2);
  ctx.fillRect(fX, fY - 11, 7, 7);
  ctx.fillRect(fX + 2, fY - 11, 3, 7);
  ctx.fillRect(fX, fY - 9, 7, 2);
  ctx.restore();

  // ── ANCHOR on bow side ──
  ctx.save();
  ctx.strokeStyle = '#3A2010';
  ctx.lineWidth = 2;
  const ax = 42, ay = hullBot - 55;
  // Shank
  ctx.beginPath(); ctx.moveTo(ax, ay); ctx.lineTo(ax, ay + 22); ctx.stroke();
  // Crown
  ctx.beginPath();
  ctx.moveTo(ax - 10, ay + 18);
  ctx.quadraticCurveTo(ax, ay + 28, ax + 10, ay + 18);
  ctx.stroke();
  // Ring
  ctx.beginPath(); ctx.arc(ax, ay - 3, 4, 0, Math.PI * 2); ctx.stroke();
  // Flukes
  ctx.beginPath(); ctx.moveTo(ax - 10, ay + 18); ctx.lineTo(ax - 13, ay + 14); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(ax + 10, ay + 18); ctx.lineTo(ax + 13, ay + 14); ctx.stroke();
  ctx.restore();

  // ── ROPE LADDER (right side — like Indy's boxcar ladder!) ──
  ctx.save();
  ctx.strokeStyle = '#5A3418';
  ctx.lineWidth = 2;
  const ladX = GW - 35;
  // Verticals
  ctx.beginPath(); ctx.moveTo(ladX, hullTop - 8); ctx.lineTo(ladX, hullBot - 50); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(ladX + 14, hullTop - 8); ctx.lineTo(ladX + 14, hullBot - 50); ctx.stroke();
  // Rungs
  ctx.lineWidth = 2;
  for (let ry = hullTop + 10; ry < hullBot - 55; ry += 18) {
    ctx.beginPath(); ctx.moveTo(ladX, ry); ctx.lineTo(ladX + 14, ry); ctx.stroke();
  }
  ctx.restore();

  // ══════════════════════════════════════════════════
  // TITLE TEXT — "Το Μυστήριο του Γαλαξειδίου"
  // Layout: big / small / HUGE (like Indy Jones style)
  // ══════════════════════════════════════════════════
  ctx.save();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const glow = 0.3 + Math.sin(t * 1.2) * 0.15;

  // Multi-layer embossed text renderer
  function paintText(text, cx, cy, size) {
    ctx.font = `bold ${size}px "Press Start 2P", monospace`;
    // 6-layer depth shadow
    const shadows = [
      ['#060200', 6, 6],
      ['#0E0604', 5, 5],
      ['#1A0A04', 4, 4],
      ['#2E1508', 3, 3],
      ['#4A2010', 2, 2],
      ['#8B6020', 1, 1],
    ];
    for (const [col, dx, dy] of shadows) {
      ctx.fillStyle = col;
      ctx.fillText(text, cx + dx, cy + dy);
    }
    // Gold main fill with warm glow
    ctx.shadowColor = `rgba(255,180,40,${glow})`;
    ctx.shadowBlur = 25;
    ctx.fillStyle = '#D4A03C';
    ctx.fillText(text, cx, cy);
    // Specular highlight (top-left edge catch)
    ctx.shadowBlur = 0;
    ctx.fillStyle = 'rgba(255,235,170,0.35)';
    ctx.fillText(text, cx, cy - 1);
    ctx.fillStyle = 'rgba(255,245,200,0.15)';
    ctx.fillText(text, cx - 1, cy - 2);
  }

  // ── "ΤΟ ΜΥΣΤΗΡΙΟ" — large first line ──
  const y1 = hullTop + 80;
  paintText('ΤΟ ΜΥΣΤΗΡΙΟ', GW / 2, y1, 36);

  // ── "του" — small connector (like "and the") ──
  const y2 = y1 + 48;
  ctx.shadowBlur = 0;
  ctx.font = 'bold 14px "Press Start 2P", monospace';
  ctx.fillStyle = '#1A0A04';
  ctx.fillText('του', GW / 2 + 2, y2 + 2);
  ctx.fillStyle = '#9A7028';
  ctx.fillText('του', GW / 2, y2);

  // ── "ΓΑΛΑΞΕΙΔΙΟΥ" — MASSIVE bottom line ──
  const y3 = y2 + 55;
  paintText('ΓΑΛΑΞΕΙΔΙΟΥ', GW / 2, y3, 40);

  ctx.restore();

  // ── SEA with animated waves ──
  const seaTop = 342;
  const seaGrad = ctx.createLinearGradient(0, seaTop, 0, GH);
  seaGrad.addColorStop(0, '#1B3A5C');
  seaGrad.addColorStop(0.3, '#153050');
  seaGrad.addColorStop(1, '#0A1A30');
  ctx.fillStyle = seaGrad;
  ctx.fillRect(0, seaTop - 3, GW, GH - seaTop + 3);

  // Wave layers
  ctx.save();
  for (let l = 0; l < 4; l++) {
    const wy = seaTop + 2 + l * 10;
    const sp = 0.5 + l * 0.2;
    const am = 2.5 + l * 1.2;
    ctx.beginPath();
    for (let x = 0; x <= GW; x += 3) {
      const y = wy + Math.sin(x*0.013 + t*sp) * am + Math.sin(x*0.007 - t*sp*0.7) * am*0.5;
      if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.lineTo(GW, GH); ctx.lineTo(0, GH); ctx.closePath();
    ctx.fillStyle = `rgba(18,50,85,${0.3 - l*0.06})`;
    ctx.fill();
  }
  // Foam
  ctx.strokeStyle = 'rgba(160,200,230,0.1)';
  ctx.lineWidth = 1;
  for (let l = 0; l < 2; l++) {
    ctx.beginPath();
    for (let x = 0; x <= GW; x += 3) {
      const y = seaTop + 2 + l*10 + Math.sin(x*0.013 + t*(0.5+l*0.2)) * (2.5+l*1.2);
      if (x === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }
  ctx.restore();

  // ── Bottom ground strip (like Indy's brown earth) ──
  const groundGrad = ctx.createLinearGradient(0, GH - 30, 0, GH);
  groundGrad.addColorStop(0, '#3A2A18');
  groundGrad.addColorStop(0.1, '#2E1E10');
  groundGrad.addColorStop(1, '#1A100A');
  ctx.fillStyle = groundGrad;
  ctx.fillRect(0, GH - 30, GW, 30);
  // Ground top edge
  ctx.fillStyle = '#4A3420';
  ctx.fillRect(0, GH - 30, GW, 2);

  // ── Credits (like "TM & © 1990 LucasArts") ──
  ctx.save();
  ctx.font = '7px "Press Start 2P", monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#584830';
  ctx.fillText('Μια Περιπέτεια της Οικογένειας Λατσούδη', GW / 2, GH - 10);
  ctx.restore();

  // ── Blinking start prompt ──
  const blink = 0.2 + Math.sin(tick * 0.06) * 0.45;
  ctx.save();
  ctx.font = '8px "Press Start 2P", monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.globalAlpha = Math.max(0, blink);
  ctx.fillStyle = '#D4A03C';
  ctx.shadowColor = 'rgba(212,160,60,0.5)';
  ctx.shadowBlur = 10;
  ctx.fillText('► ΚΛΙΚ ΓΙΑ ΕΝΑΡΞΗ ◄', GW / 2, GH - 42);
  ctx.restore();

  // ── Fade overlay ──
  if (titleFadeOut > 0) {
    ctx.save();
    ctx.globalAlpha = titleFadeOut;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, GW, GH);
    ctx.restore();
  }
}

// ════════════════════════════════════════════════════════════
// TITLE & INTRO FLOW
// ════════════════════════════════════════════════════════════
let titleClicked = false;
let titleMusicStarted = false;

// Start title music on any user gesture (needed for autoplay policy)
function ensureTitleMusic() {
  if (!titleMusicStarted && state.phase === 'title') {
    titleMusic.play().catch(() => {});
    titleMusicStarted = true;
  }
}
document.addEventListener('click', ensureTitleMusic, { once: true });
document.addEventListener('keydown', ensureTitleMusic, { once: true });

CVS.addEventListener('click', function titleClickHandler(e) {
  if (state.phase !== 'title' || titleClicked) return;
  titleClicked = true;

  // Crossfade title music out
  const fadeInterval = setInterval(() => {
    if (titleMusic.volume > 0.02) {
      titleMusic.volume = Math.max(0, titleMusic.volume - 0.01);
    } else {
      titleMusic.pause();
      titleMusic.volume = 0.3;
      clearInterval(fadeInterval);
    }
  }, 50);

  // Animate fade to black
  const fadeStep = () => {
    titleFadeOut += 0.02;
    if (titleFadeOut < 1) {
      requestAnimationFrame(fadeStep);
    } else {
      titleFadeOut = 1;
      // Switch to intro
      state.phase = 'intro';
      bgm.play().catch(() => {}); state.musicOn = true;
      const intro = document.getElementById('intro-screen');
      intro.classList.add('show');
      showIntroPage();
    }
  };
  requestAnimationFrame(fadeStep);
}, { once: false });

function showIntroPage() {
  const t = document.getElementById('intro-text');
  const h = document.getElementById('intro-hint');
  t.style.opacity = '0';
  h.classList.remove('on');
  setTimeout(() => {
    t.innerHTML = introPages[state.introPage].replace(/\n/g, '<br>');
    t.style.opacity = '1';
    setTimeout(() => h.classList.add('on'), 1200);
  }, 300);
}

document.getElementById('intro-screen').onclick = () => {
  state.introPage++;
  if (state.introPage >= introPages.length) {
    const is = document.getElementById('intro-screen');
    is.style.opacity = '0';
    setTimeout(() => {
      is.style.display = 'none';
      state.phase = 'playing';
      startScene('exterior');
    }, 1500);
  } else {
    showIntroPage();
  }
};

// ════════════════════════════════════════════════════════════
// BOOT
// ════════════════════════════════════════════════════════════
loadAllAssets().then(() => {
  requestAnimationFrame(gameLoop);
});
</script>
</body>
</html>
