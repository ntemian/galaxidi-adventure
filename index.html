<!DOCTYPE html>
<html lang="el">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Το Μυστήριο του Γαλαξειδίου — Canvas Engine</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,600;0,700;1,400&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
  body { background: #000; overflow: hidden; font-family: 'Press Start 2P', monospace; display: flex; flex-direction: column; height: 100vh; }

  /* ── CANVAS ── */
  #game-canvas {
    display: block; background: #0a0812;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    cursor: none;
    flex: 1;
    width: 100%;
    min-height: 0;
  }

  /* ── ACTION LINE — MI2 exact style ── */
  #action-line {
    height: 22px; display: none; align-items: center; justify-content: center;
    font-family: 'Press Start 2P', monospace;
    font-size: .6rem; color: #39d52e; letter-spacing: 1px;
    background: #000;
    border-bottom: 1px solid #1a1a1a;
  }
  #action-line.on { display: flex; }

  /* ── UI PANEL — Monkey Island 2 exact style ── */
  #ui-panel {
    background: #000;
    display: none; flex-direction: column;
    border-top: 2px solid #1a1a1a;
  }
  #ui-panel.on { display: flex; }
  #ui-panel::before, #ui-panel::after { display: none; }

  /* Bottom row: verbs LEFT, inventory RIGHT */
  #ui-bottom {
    display: flex; height: 110px; padding: 0;
  }

  /* ── VERB GRID — MI2 exact flat text buttons ── */
  #verb-panel {
    display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr;
    gap: 0; width: 220px; flex-shrink: 0;
    padding: 8px 0 8px 12px;
    border-right: 1px solid #1a1a1a;
  }
  .vb {
    font-family: 'Press Start 2P', monospace; font-size: .58rem; color: #39d52e;
    background: none; border: none;
    cursor: pointer;
    display: flex; align-items: center; justify-content: flex-start;
    padding: 4px 10px; text-align: left;
    line-height: 1;
  }
  .vb:hover { color: #7fff7f; }
  .vb:active { color: #fff; }
  .vb.on { color: #fff; }

  /* ── INVENTORY — MI2 exact dark strip ── */
  #inv-panel {
    flex: 1; display: flex; align-items: stretch;
    margin: 0;
    border: none;
    background: #000;
    padding: 0;
  }
  #inv-label { display: none; }
  #inv-arrows {
    display: flex; flex-direction: column; justify-content: center;
    gap: 2px; padding: 6px 4px; flex-shrink: 0;
    border-right: 1px solid #1a1a1a;
  }
  #inv-arrows button {
    font-size: .65rem; color: #39d52e;
    background: none; border: 1px solid #333;
    cursor: pointer; padding: 5px 8px; line-height: 1;
  }
  #inv-arrows button:hover { color: #7fff7f; border-color: #39d52e; }
  #inv-grid {
    flex: 1; display: grid;
    grid-template-columns: repeat(auto-fill, 52px);
    grid-template-rows: repeat(2, 52px);
    grid-auto-flow: column;
    gap: 3px; padding: 4px;
    overflow: hidden;
    align-content: center;
  }
  .inv-slot {
    width: 52px; height: 52px;
    background: #0a0a0a;
    border: 1px solid #222;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer;
  }
  .inv-slot:hover { border-color: #39d52e; }
  .inv-slot.on { border-color: #7fff7f; background: #111; }
  .inv-slot .inv-text {
    font-family: 'Press Start 2P', monospace; font-size: .32rem; color: #39d52e;
    text-align: center; line-height: 1.3;
  }

  /* ── TITLE (canvas-rendered, no HTML overlay) ── */
  @keyframes blink { 0%,100%{opacity:.3} 50%{opacity:.9} }

  /* ── INTRO OVERLAY ── */
  #intro-screen {
    position: fixed; inset: 0; background: #0a0812;
    display: none; flex-direction: column; align-items: center; justify-content: center;
    z-index: 1500; padding: 2rem; cursor: pointer; transition: opacity 1.5s;
  }
  #intro-screen.show { display: flex; }
  #intro-text { max-width:600px; font-size:clamp(.6rem,1.2vw,.8rem); color:#D4A03C; line-height:2.5; text-align:center; opacity:0; transition: opacity 1.5s; }
  #intro-hint { font-size:.5rem; color:#4a4a4a; margin-top:2rem; opacity:0; transition: opacity .5s; }
  #intro-hint.on { opacity:1; animation: blink 2s infinite; }

  /* ── EPILOGUE OVERLAY ── */
  #epilogue-screen {
    position: fixed; inset: 0; background: #0a0812;
    display: none; flex-direction: column; align-items: center; justify-content: center;
    z-index: 1500; padding: 2rem; cursor: pointer; transition: opacity 1.5s;
  }
  #epilogue-screen.show { display: flex; }
  #epilogue-text { max-width:600px; font-size:clamp(.6rem,1.2vw,.8rem); color:#D4A03C; line-height:2.5; text-align:center; opacity:0; transition: opacity 1.5s; }
  #epilogue-hint { font-size:.5rem; color:#4a4a4a; margin-top:2rem; opacity:0; transition: opacity .5s; }
  #epilogue-hint.on { opacity:1; animation: blink 2s infinite; }

  /* ── FADE ── */
  #fade { position: fixed; inset: 0; background: #000; z-index: 3000; opacity: 0; pointer-events: none; transition: opacity .5s; }
  #fade.on { opacity: 1; }
</style>
</head>
<body>

<div id="fade"></div>

<!-- Title screen is canvas-rendered -->

<div id="intro-screen">
  <div id="intro-text"></div>
  <div id="intro-hint">▶ ΚΛΙΚ</div>
</div>

<div id="epilogue-screen">
  <div id="epilogue-text"></div>
  <div id="epilogue-hint">▶ ΚΛΙΚ</div>
</div>

<canvas id="game-canvas" width="640" height="400"></canvas>

<div id="action-line"></div>

<div id="ui-panel">
  <div id="ui-bottom">
    <div id="verb-panel">
      <button class="vb on" data-v="look" onclick="setVerb('look')">Κοίταξε</button>
      <button class="vb" data-v="talk" onclick="setVerb('talk')">Μίλησε</button>
      <button class="vb" data-v="open" onclick="setVerb('open')">Άνοιξε</button>
      <button class="vb" data-v="use" onclick="setVerb('use')">Χρησιμοποίησε</button>
    </div>
    <div id="inv-panel">
      <div id="inv-arrows">
        <button onclick="scrollInv(-1)">▲</button>
        <button onclick="scrollInv(1)">▼</button>
      </div>
      <div id="inv-grid"></div>
    </div>
  </div>
</div>

<audio id="title-music" loop preload="auto"><source src="music/galaxidi-title-theme-1.mp3" type="audio/mpeg"></audio>
<audio id="bgm" loop preload="auto"><source src="music/arrival-at-galaxidi-scene-1-1.mp3" type="audio/mpeg"></audio>

<script>
// ════════════════════════════════════════════════════════════
// CANVAS ENGINE — Pure requestAnimationFrame game loop
// ════════════════════════════════════════════════════════════
const CVS = document.getElementById('game-canvas');
const ctx = CVS.getContext('2d');
const GW = 640, GH = 400; // internal game resolution
const GAME_VERSION = 'v0.1-pilot';
const GAME_BUILD = '2026-02-17';
CVS.width = GW; CVS.height = GH;

// ── Layer cache: offscreen buffers for static content ──
const bgBuffer = document.createElement('canvas');
bgBuffer.width = GW; bgBuffer.height = GH;
const bgCtx = bgBuffer.getContext('2d');
let bgCachedScene = null; // invalidate when scene changes

// ════════════════════════════════════════════════════════════
// STATE
// ════════════════════════════════════════════════════════════
const state = {
  phase: 'title', // title, crawl, intro, playing
  crawlScroll: 0,
  crawlFading: false,
  crawlFadeAlpha: 0,
  scene: null,
  verb: 'look',
  inv: [],
  flags: {},
  visited: new Set(),
  tick: 0,
  mouseGX: 0, mouseGY: 0, cursorMode: 'default',
  hoverObj: null,
  musicOn: false,
  dlg: { active: false, queue: [], text: '', displayed: '', charIdx: 0, timer: 0, speaker: '', cb: null },
  fade: { active: false, alpha: 0, dir: 0, cb: null },
  introPage: 0,
  epiloguePage: 0,
  mapOpen: false,
  mapHover: null,
  helpOpen: false,
  statusOpen: false,
  cutscene: {
    active: false, id: null, frameIdx: 0, frameTime: 0, totalTime: 0,
    transitioning: false, fadeAlpha: 0,
    dlgText: '', dlgDisplayed: '', dlgSpeaker: '', dlgCharIdx: 0, dlgTimer: 0,
    dlgTriggered: new Set(),
  },
  seq: {
    active: false, steps: [], stepIdx: 0, stepTimer: 0,
    ghostMat: { progress: 0, alpha: 0, glowBlur: 30, active: false },
    env: { darken: 0, vignette: 0, spectral: 0 },
    swirlParticles: [],
    stoneGlow: { active: false, progress: 0 },
    jadeReveal: { active: false, progress: 0 },
  },
};

// Characters
const chars = {
  ntemis: { x: 0, y: 0, dir: 1, walking: false, frame: 0, targetX: null, startX: 0, walkT: 0, walkDur: 0, visible: true, fadeIn: 0 },
  ajax:   { x: 0, y: 0, dir: 1, walking: false, frame: 0, targetX: null, startX: 0, walkT: 0, walkDur: 0, visible: true, fadeIn: 0 },
  clio:   { x: 0, y: 0, dir: 1, walking: false, frame: 0, targetX: null, startX: 0, walkT: 0, walkDur: 0, visible: true, fadeIn: 0 },
};

// NPC characters — static, scene-specific (scale adjusts relative to CHAR_SCALE)
const npcChars = {
  ghost:   { scene: 'graveyard', x: 460, y: 280, dir: -1, visible: false, tilt: 0, wave: 0, scale: 1.0 },
  athos:   { scene: 'liotrivi', x: 510, y: 375, dir: -1, visible: true, scale: 0.85 },
  stathis: { scene: 'port', x: 80, y: 343, dir: 1, visible: true, scale: 0.85 },
  akis:    { scene: 'port', x: 150, y: 342, dir: 1, visible: true, scale: 0.85 },
  giannis: { scene: 'windmill', x: 150, y: 340, dir: 1, visible: true, scale: 0.85 },
  curator: { scene: 'museum', x: 230, y: 377, dir: 1, visible: true, scale: 0.85 },
  papas:   { scene: 'church_interior', x: 480, y: 375, dir: -1, visible: true, scale: 0.85 },
  chrysostomos: { scene: 'boat', x: 100, y: 375, dir: 1, visible: true, scale: 0.85 },
};

let walkDoneCallback = null;

// ════════════════════════════════════════════════════════════
// IMAGE LOADING
// ════════════════════════════════════════════════════════════
const images = {};
function loadImg(key, src) {
  return new Promise(resolve => {
    const img = new Image();
    img.onload = () => { images[key] = img; resolve(img); };
    img.onerror = () => { console.warn('Failed to load:', src); resolve(null); };
    img.src = src;
  });
}

// Character idle sprites
const CHAR_IMGS = {};
const PORTRAITS = {};

async function loadAllAssets() {
  // Backgrounds
  await Promise.all([
    loadImg('title-bg', 'assets/title-bg.webp'),
    loadImg('bg-exterior', 'assets/pixel-exterior.webp'),
    loadImg('bg-terrace', 'assets/pixel-terrace.webp'),
    loadImg('bg-kitchen', 'assets/pixel-kitchen.png'),
    loadImg('bg-port', 'assets/pixel-port.webp'),
    loadImg('bg-museum', 'assets/pixel-museum.webp'),
    loadImg('bg-liotrivi', 'assets/pixel-liotrivi.webp'),
    loadImg('bg-cave', 'assets/pixel-cave-new.png'),
    loadImg('bg-church', 'assets/pixel-church.png'),
    loadImg('bg-church-interior', 'assets/pixel-church-interior.webp'),
    loadImg('bg-windmill', 'assets/pixel-windmill.webp'),
    loadImg('bg-boat', 'assets/pixel-boat.webp'),
    loadImg('bg-graveyard', 'assets/pixel-graveyard.webp'),
    loadImg('bg-treasure', 'assets/pixel-treasure-new.png'),
    loadImg('bg-new-era', 'assets/pixel-new-era.png'),
    // Cutscene backgrounds
    loadImg('cutscene-road', 'assets/cutscene-road.png'),
    loadImg('cutscene-descent', 'assets/cutscene-descent.png'),
    loadImg('cutscene-letter', 'assets/cutscene-letter.png'),
    loadImg('cutscene-cave', 'assets/cutscene-cave.png'),
    loadImg('cutscene-ghost', 'assets/cutscene-ghost.png'),
    loadImg('cutscene-crossing', 'assets/cutscene-crossing.png'),
    loadImg('cutscene-treasure', 'assets/cutscene-treasure.png'),
    loadImg('cutscene-epilogue', 'assets/cutscene-epilogue.png'),
    loadImg('cutscene-church', 'assets/cutscene-church.png'),
    loadImg('cutscene-church-tile', 'assets/cutscene-church-tile.png'),
    loadImg('cutscene-ghost-appear', 'assets/cutscene-ghost-appear.png'),
    loadImg('cutscene-ghost-farewell', 'assets/cutscene-ghost-farewell.png'),
    loadImg('cutscene-crossing-dawn', 'assets/cutscene-crossing-dawn.png'),
    loadImg('cutscene-crossing-island', 'assets/cutscene-crossing-island.png'),
    loadImg('cutscene-telescope-island', 'assets/cutscene-telescope-island.png'),
    loadImg('cutscene-treasure-open', 'assets/cutscene-treasure-open.png'),
    loadImg('cutscene-treasure-letter', 'assets/cutscene-treasure-letter.png'),
    loadImg('cutscene-epilogue-speech', 'assets/cutscene-epilogue-speech.png'),
    loadImg('cutscene-epilogue-signing', 'assets/cutscene-epilogue-signing.png'),
    loadImg('cutscene-festival-celebration', 'assets/cutscene-festival-celebration.png'),
    loadImg('cutscene-festival-fireworks', 'assets/cutscene-festival-fireworks.png'),
    loadImg('cutscene-festival-ghost', 'assets/cutscene-festival-ghost.png'),
    loadImg('cutscene-festival-lantern', 'assets/cutscene-festival-lantern.png'),
    loadImg('cutscene-festival-panorama', 'assets/cutscene-festival-panorama.png'),
    loadImg('map-bg', 'assets/map-galaxidi.png'),
    loadImg('intro-parchment', 'assets/intro-parchment-v4.png'),
  ]);

  // Character idle sprites (family + NPCs)
  const charPromises = ['ntemis','ajax','clio','ghost','athos','stathis','akis','giannis','curator','papas','chrysostomos'].map(id =>
    loadImg(`char-${id}`, `assets/char-${id}-final.png`).then(img => { CHAR_IMGS[id] = img; })
  );

  // Portraits (family + NPCs)
  const portPromises = [
    loadImg('port-ntemis', 'assets/portrait-ntemis.webp').then(img => { PORTRAITS['ΝΤΕΜΗΣ'] = img; }),
    loadImg('port-ajax', 'assets/portrait-ajax.webp').then(img => { PORTRAITS['ΑΙΑΣ'] = img; }),
    loadImg('port-clio', 'assets/portrait-clio.webp').then(img => { PORTRAITS['ΚΛΕΙΩ'] = img; }),
    loadImg('port-ghost', 'assets/portrait-ghost.webp').then(img => { PORTRAITS['ΦΑΝΤΑΣΜΑ'] = img; }),
    loadImg('port-athos', 'assets/portrait-athos.webp').then(img => { PORTRAITS['ΑΘΟΣ'] = img; }),
    loadImg('port-stathis', 'assets/portrait-stathis.webp').then(img => { PORTRAITS['ΣΤΑΘΗΣ'] = img; }),
    loadImg('port-akis', 'assets/portrait-akis.webp').then(img => { PORTRAITS['ΑΚΗΣ'] = img; }),
    loadImg('port-giannis', 'assets/portrait-giannis.webp').then(img => { PORTRAITS['ΓΙΑΝΝΗΣ'] = img; }),
    loadImg('port-curator', 'assets/portrait-curator.webp').then(img => { PORTRAITS['ΕΠΙΜΕΛΗΤΗΣ'] = img; }),
    loadImg('port-papas', 'assets/portrait-papas.webp').then(img => { PORTRAITS['ΠΑΠΑΣ'] = img; }),
    loadImg('port-chrysostomos', 'assets/portrait-chrysostomos.webp').then(img => { PORTRAITS['ΧΡΥΣΟΣΤΟΜΟΣ'] = img; }),
  ];

  await Promise.all([...charPromises, ...portPromises]);
}

// ════════════════════════════════════════════════════════════
// SCENES DATA
// ════════════════════════════════════════════════════════════
const scenes = {
  exterior: {
    label: 'ΤΟ ΣΠΙΤΙ — ΓΑΛΑΞΙΔΙ', bg: 'bg-exterior',
    walkLine: [[30, 378], [200, 375], [400, 378], [530, 380]],
    walkBounds: [30, 530], // cobblestone ends before waterfront
    charPos: {
      ntemis: { x: 290, y: 375 },
      ajax:   { x: 370, y: 378 },
      clio:   { x: 210, y: 378 },
    },
    objects: [
      { id:'door', x:100, y:30, w:90, h:165, label:'Πόρτα',
        verbs: { look:[{s:'',t:'Ξύλινη πόρτα βαμμένη μπλε. Το χρώμα του Αιγαίου.'}],
                 open:() => { playSFX('door'); showDlg([{s:'ΝΤΕΜΗΣ',t:'Ας μπούμε μέσα.'}], () => changeScene('kitchen')); return; },
                 walk:'kitchen', use:'kitchen' }},
      { id:'bougainvillea', x:175, y:-88, w:150, h:120, label:'Μπουκαμβίλιες',
        verbs: { look:[{s:'',t:'Ροζ μπουκαμβίλιες σκαρφαλώνουν στον τοίχο. Εδώ το καλοκαίρι αρνείται να φύγει.'}],
                 pick:[{s:'ΚΛΕΙΩ',t:'Μπαμπά, μην τις κόβεις! Είναι τέλειες έτσι.'}] }},
      { id:'flowerpots', x:75, y:192, w:65, h:55, label:'Γλάστρες',
        verbs: { look:[{s:'',t:'Πήλινες γλάστρες με βασιλικό. Κάποιος τα περιποιείται ακόμα κι όταν το σπίτι μένει κλειστό.'}] }},
      { id:'barrel', x:245, y:168, w:55, h:60, label:'Βαρέλι',
        verbs: { look:[{s:'',t:'Ένα παλιό ξύλινο βαρέλι. Μυρίζει κρασί και αλμύρα.'}],
                 open:[{s:'ΑΙΑΣ',t:'Άδειο. Κρίμα!'}] }},
      { id:'boats', x:380, y:72, w:140, h:80, label:'Ψαροκάικα',
        verbs: { look:[{s:'',t:'Χρωματιστά ψαροκάικα δεμένα στο λιμάνι. Κουνιούνται αργά στο απογευματινό φως.'},{s:'ΑΙΑΣ',t:'Μπαμπά, θα πάμε βόλτα με βάρκα;'}] }},
      { id:'sea', x:350, y:-24, w:230, h:60, label:'Η θάλασσα',
        verbs: { look:[{s:'',t:'Ο Κορινθιακός κόλπος λάμπει χρυσαφί στο ηλιοβασίλεμα. Μαγικό.'}] }},
    ],
    exits: [
      { side:'right', target:'terrace', label:'Βεράντα →' },
      { side:'left', target:'port', label:'← Λιμάνι' },
    ],
    entry: [
      {s:'',t:'Ο ήλιος βάφει χρυσά τα καλντερίμια. Μυρωδιά πεύκου ανακατεμένη με θαλασσινό αλάτι.'},
      {s:'ΝΤΕΜΗΣ',t:'Φτάσαμε, παιδιά. Αυτό είναι το σπίτι μας για το Σαββατοκύριακο.'},
      {s:'ΑΙΑΣ',t:'Τέλειο! Πάμε κατευθείαν στο λιμάνι;'},
      {s:'ΚΛΕΙΩ',t:'Πρώτα ας αφήσουμε τις βαλίτσες. Θέλω να δω τη βεράντα.'},
    ],
  },
  terrace: {
    label: 'Η ΒΕΡΑΝΤΑ', bg: 'bg-terrace',
    walkLine: [[30, 385], [200, 380], [400, 382], [610, 387]],
    charPos: {
      ntemis: { x: 320, y: 382 },
      ajax:   { x: 420, y: 384 },
      clio:   { x: 225, y: 381 },
    },
    objects: [
      { id:'harbor', x:140, y:72, w:280, h:100, label:'Το λιμάνι',
        verbs: { look:()=>{
          if(!state.flags.dolphins){state.flags.dolphins=1;return[
            {s:'',t:'Ο Κορινθιακός λάμπει σαν λιωμένο χρυσάφι. Ψαροκάικα κουνιούνται αργά στο λιμάνι.'},
            {s:'ΚΛΕΙΩ',t:'Μπαμπά, κοίτα! Δελφίνια!'},
            {s:'',t:'Τρία δελφίνια κόβουν βόλτες στο λιμάνι.'},
            {s:'ΑΙΑΣ',t:'Δελφίνια μέσα στο λιμάνι; Αυτό δεν είναι συνηθισμένο...'}];}
          return[{s:'',t:'Τα δελφίνια συνεχίζουν τους κύκλους τους. Σαν να φυλάνε κάτι.'}];}}},
      { id:'rooftops', x:30, y:8, w:130, h:100, label:'Σκεπές',
        verbs: { look:[{s:'',t:'Κεραμίδια, σκεπές, καμινάδες. Κάθε σπίτι κι ένας καπετάνιος κάποτε.'}] }},
      { id:'mountains', x:250, y:-101, w:300, h:80, label:'Παρνασσός',
        verbs: { look:[{s:'',t:'Ο Παρνασσός στο βάθος. Οι Δελφοί κάπου εκεί πάνω.'},{s:'ΚΛΕΙΩ',t:'Οι Αμφικτίονες ξεκινούσαν από τους Δελφούς... Το Γαλαξίδι ήταν λιμάνι τους.'}] }},
      { id:'balustrade', x:90, y:264, w:370, h:40, label:'Κάγκελο',
        verbs: { look:[{s:'',t:'Πέτρινο κάγκελο με θέα ολόκληρο το Γαλαξίδι. Θα μπορούσες να κάτσεις εδώ ώρες.'}],
                 push:[{s:'ΚΛΕΙΩ',t:'Μπαμπά, μην ακουμπάς, φαίνεται παλιό!'}] }},
      { id:'flowerpot', x:10, y:232, w:65, h:60, label:'Γλάστρα',
        verbs: { look:[{s:'',t:'Γεράνια σε πήλινη γλάστρα. Τα χρώματα λάμπουν στο ηλιοβασίλεμα.'}] }},
    ],
    exits: [{ side:'left', target:'exterior', label:'← Σπίτι' }, { side:'right', target:'windmill', label:'Μύλος →' }],
    entry: [
      {s:'',t:'Η θέα κόβει την ανάσα.'},
      {s:'ΚΛΕΙΩ',t:'Αυτό είναι το πιο όμορφο μέρος στον κόσμο.'},
      {s:'ΝΤΕΜΗΣ',t:'Καλωσορίσατε στο Γαλαξίδι.'},
    ],
  },
  kitchen: {
    label: 'ΤΟ ΓΡΑΦΕΙΟ ΤΟΥ ΚΑΠΕΤΑΝΙΟΥ', bg: 'bg-kitchen',
    walkLine: [[30, 378], [320, 375], [610, 378]],
    charPos: {
      ntemis: { x: 350, y: 375 },
      ajax:   { x: 450, y: 377 },
      clio:   { x: 100, y: 377 },
    },
    objects: [
      { id:'model_ships', x:20, y:0, w:200, h:70, label:'Μοντέλα πλοίων',
        verbs: { look:[{s:'',t:'Μοντέλα πλοίων σε ράφια — σκούνες, μπρίκια, τρικάταρτα. Μικρογραφίες μιας χαμένης αυτοκρατορίας.'}] }},
      { id:'photo', x:115, y:70, w:65, h:80, label:'Φωτογραφία',
        verbs: { look:()=>{
            if(!state.flags.photo_seen){state.flags.photo_seen=1;return[{s:'',t:'Μια ξεθωριασμένη φωτογραφία σε χρυσή κορνίζα. Ένας άντρας με καπετάνιος στολή, λευκά μουστάκια, περήφανο βλέμμα.'},{s:'ΚΛΕΙΩ',t:'Ποιος είναι αυτός;'},{s:'ΝΤΕΜΗΣ',t:'Ο Καπετάν Βισβίκης. Ο προπάππους μου.'}];}
            return[{s:'',t:'Ο Καπετάν Λουκάς Βισβίκης. Τα μάτια του σε ακολουθούν.'}];
          }}},
      { id:'desk_drawer', x:210, y:230, w:210, h:35, label:'Κρυφό συρτάρι',
        verbs: {
          look:()=>{
            if(state.flags.drawer_open) return[{s:'',t:'Το συρτάρι είναι ανοιχτό. Άδειο πλέον.'}];
            return[{s:'',t:'Ένα κλειδωμένο συρτάρι στο γραφείο. Χρειάζεται κλειδί.'},{s:'ΑΙΑΣ',t:'Μπαμπά, είναι κλειδωμένο! Πού είναι το κλειδί;'}];
          },
          open:()=>{
            if(state.flags.drawer_open) return[{s:'',t:'Το συρτάρι είναι ήδη ανοιχτό.'}];
            if(!state.inv.find(i=>i.id==='brass_key')) return[{s:'',t:'Κλειδωμένο. Χρειάζεσαι κλειδί.'},{s:'ΚΛΕΙΩ',t:'Ψάξτε γύρω! Πρέπει να είναι κάπου εδώ.'}];
            state.flags.drawer_open=1;
            playSFX('key');
            setTimeout(() => playSFX('drawer'), 150);
            removeInv('brass_key');
            addInv({id:'visvikis_letter',label:'Γράμμα Βισβίκη',desc:'«Σε όποιον βρει αυτό το γράμμα — βρες το πράσινο πέτρωμα, εκεί που η γη μιλάει — εκεί που τα βράχια γίνονται σπήλαιο και ο ήχος δεν φεύγει ποτέ.»'});
            setTimeout(()=>{
              document.getElementById('ui-panel').classList.remove('on');
              document.getElementById('action-line').classList.remove('on');
              const origComplete = cutscenes.letter.onComplete;
              cutscenes.letter.onComplete = () => {
                if(origComplete) origComplete();
                state.phase = 'playing';
                document.getElementById('ui-panel').classList.add('on');
                document.getElementById('action-line').classList.add('on');
              };
              playSFX('paper');
              startCutscene('letter');
            }, 800);
            return[
              {s:'',t:'Γυρίζεις το κλειδί. Κλικ. Το συρτάρι ανοίγει αργά...'},
              {s:'',t:'Μέσα — ένα παλιό γράμμα, σφραγισμένο με κερί.', sfx:'paper'},
              {s:'ΚΛΕΙΩ',t:'Μπαμπά, διάβασέ το!'},
            ];
          },
          use:()=>{
            if(state.flags.drawer_open) return[{s:'',t:'Το συρτάρι είναι ήδη ανοιχτό.'}];
            if(state.inv.find(i=>i.id==='brass_key')){
              return scenes.kitchen.objects.find(o=>o.id==='desk_drawer').verbs.open();
            }
            return[{s:'',t:'Κλειδωμένο. Χρειάζεσαι κλειδί.'}];
          }}},
      { id:'copper_pot', x:0, y:100, w:80, h:90, label:'Χάλκινο δοχείο',
        verbs: {
          look:()=>{
            if(state.flags.key_found) return[{s:'',t:'Ένα χάλκινο δοχείο στο τζάκι. Τώρα άδειο.'}];
            return[{s:'',t:'Ένα χάλκινο δοχείο στο τζάκι. Κάτι κουδουνίζει μέσα.'}];
          },
          open:()=>{
            if(state.flags.key_found) return[{s:'',t:'Το δοχείο είναι άδειο.'}];
            state.flags.key_found=1;
            addInv({id:'brass_key',label:'Κλειδί',desc:'Ένα μικρό ορειχάλκινο κλειδί. Βρέθηκε στο χάλκινο δοχείο στο τζάκι.'});
            return[{s:'',t:'Ανοίγεις το δοχείο. Μέσα — ένα μικρό ορειχάλκινο κλειδί!'},{s:'ΚΛΕΙΩ',t:'Εγώ το βρήκα! Εγώ κοίταξα πρώτη!'},{s:'ΑΙΑΣ',t:'Δοκίμασέ το στο συρτάρι!'}];
          },
          use:()=>{
            return scenes.kitchen.objects.find(o=>o.id==='copper_pot').verbs.open();
          }}},
      { id:'fireplace', x:0, y:160, w:85, h:170, label:'Τζάκι',
        verbs: { look:[{s:'',t:'Πέτρινο τζάκι με στάχτες. Πάνω του — ένα χάλκινο δοχείο.'}] }},
      { id:'instruments', x:500, y:120, w:120, h:100, label:'Ναυτικά όργανα',
        verbs: { look:[{s:'',t:'Ορειχάλκινα ναυτικά όργανα: πυξίδα, εξάντας, τηλεσκόπιο. Γυαλισμένα σαν χθες.'},{s:'ΑΙΑΣ',t:'Ποιου παππού;'},{s:'ΝΤΕΜΗΣ',t:'Του προπάππου μου. Κανένας δεν έχει μπει εδώ χρόνια. Κληρονομιά.'}] }},
      { id:'charts', x:250, y:10, w:180, h:110, label:'Ναυτικοί χάρτες',
        verbs: { look:[{s:'',t:'Χάρτες στους τοίχους. Δρομολόγια προς Σμύρνη, Αλεξάνδρεια, Βηρυτό. Με μελάνι σημειωμένα.'},{s:'ΚΛΕΙΩ',t:'Θα έχει φαντάσματα;'},{s:'ΝΤΕΜΗΣ',t:'...Όχι, Κλειώ. Θα έχει σκόνη.'}] }},
    ],
    exits: [{ side:'left', target:'exterior', label:'← Έξω' }],
    entry: [
      {s:'',t:'Το γραφείο του καπετάνιου. Σκόνη και μνήμη.'},
      {s:'',t:'Μοντέλα πλοίων σε ράφια, ορειχάλκινα όργανα, χάρτες στους τοίχους.'},
      {s:'ΑΙΑΣ',t:'Ουάου! Κοιτάξτε όλα αυτά τα πλοία!'},
      {s:'ΚΛΕΙΩ',t:'Μπαμπά, ποιος ζούσε εδώ;'},
    ],
  },


  // ── SCENE 2: THE PORT ──
  port: {
    label: 'ΤΟ ΛΙΜΑΝΙ', bg: 'bg-port',
    walkLine: [[30, 345], [180, 342], [350, 340], [500, 342]],
    walkBounds: [30, 500], // large stone quay
    charPos: { ntemis: { x: 280, y: 342 }, ajax: { x: 350, y: 340 }, clio: { x: 200, y: 343 } },
    objects: [
      { id:'boats_port', x:120, y:8, w:200, h:100, label:'Ψαρόβαρκες',
        verbs: { look:[{s:'',t:'Χρωματιστά καΐκια δεμένα στα μπαλόνια. Η μπογιά ξεφλουδίζει — αλμύρα και χρόνια.'},{s:'ΑΙΑΣ',t:'Μπαμπά, μπορώ να πηδήξω σε κάποιο;'},{s:'ΝΤΕΜΗΣ',t:'Μπορείς να κοιτάξεις. Από εδώ.'}] }},
      { id:'bollards', x:380, y:300, w:80, h:60, label:'Δέστρες',
        verbs: { look:[{s:'',t:'Μεταλλικές δέστρες ψηλότερες από την Κλειώ. Φτιαγμένες για τρικάταρτα, όχι για βαρκούλες.'},{s:'ΚΛΕΙΩ',t:'Γιατί είναι τόσο μεγάλες;'},{s:'ΝΤΕΜΗΣ',t:'Γιατί κάποτε εδώ δένανε ιστιοφόρα πενήντα μέτρων.'}] }},
      { id:'nets', x:30, y:280, w:100, h:80, label:'Δίχτυα',
        verbs: { look:[{s:'',t:'Ένας ψαράς μπαλώνει τα δίχτυα του. Τα χέρια του κινούνται αυτόματα — πενήντα χρόνια πρακτική.'}],
                 talk:[{s:'ΝΤΕΜΗΣ',t:'Καλησπέρα! Πολύ ψάρι σήμερα;'},{s:'',t:'Ο ψαράς σηκώνει το βλέμμα. Τα μάτια του είναι γαλάζια σαν τον κόλπο.'},{s:'',t:'«Ψάρι λίγο. Ιστορίες πολλές. Κάτσε να σου πω.»'}] }},
      { id:'warehouses', x:450, y:-24, w:150, h:140, label:'Αποθήκες',
        verbs: { look:[{s:'',t:'Πέτρινες αποθήκες με σιδερένιες πόρτες. Κάποτε γεμάτες σταφίδα και λάδι για εξαγωγή. Τώρα σιωπή.'}] }},
      { id:'seagulls', x:300, y:-104, w:150, h:50, label:'Γλάροι',
        verbs: { look:[{s:'',t:'Γλάροι κράζουν πάνω από το λιμάνι. Αιώνιοι κάτοικοι.'},{s:'ΚΛΕΙΩ',t:'Αυτοί ξέρουν τα πάντα. Αν μιλούσαν...'}] }},
      { id:'stathis', x:55, y:312, w:70, h:100, label:'Στάθης',
        verbs: { look:[{s:'',t:'Ο Στάθης με την κιθάρα του. Φίλος από τα παλιά.'}],
                 talk:[{s:'ΣΤΑΘΗΣ',t:'Ντέμη! Τι κάνεις εδώ; Πάρε μια καρέκλα!'},{s:'ΝΤΕΜΗΣ',t:'Στάθη! Πόσο καιρό!'},{s:'ΣΤΑΘΗΣ',t:'Ψάχνεις κάτι; Ρώτα τον Άθο στο Λιοτρίβι. Ξέρει τα πάντα για τις παλιές οικογένειες.'},{s:'ΣΤΑΘΗΣ',t:'Κι αν χρειαστείς βάρκα, ψάξε τον Χρυσόστομο. Μόνο αυτός πλέει ακόμα με πανιά.'}] }},
      { id:'akis', x:125, y:315, w:60, h:98, label:'Άκης',
        verbs: { look:[{s:'',t:'Ο Άκης παίζει φλογέρα στο λιμάνι. Η μελωδία ταξιδεύει στο νερό.'}],
                 talk:[{s:'ΑΚΗΣ',t:'Ε, Ντέμη! Τα παιδιά μεγάλωσαν!'},{s:'ΚΛΕΙΩ',t:'Θείε Άκη, τι παίζεις;'},{s:'ΑΚΗΣ',t:'Ένα παλιό τραγούδι ναυτικό. Πήγαινε στο μουσείο — θα καταλάβεις.'}] }},
      { id:'elpida_dock', x:420, y:40, w:220, h:280, label:'Ελπίδα',
        verbs: { look:()=>{
                   if(!state.inv.find(i=>i.id==='nautical_chart')) return [{s:'',t:'Ένα ξύλινο ιστιοφόρο δεμένο στην προβλήτα. «ΕΛΠΙΔΑ» γράφει στην πλώρη.'},{s:'ΑΙΑΣ',t:'Ωραίο πλοίο! Πάμε βόλτα;'},{s:'ΝΤΕΜΗΣ',t:'Ίσως αργότερα. Δεν ξέρουμε πού να πάμε ακόμα.'}];
                   return [{s:'',t:'Η Ελπίδα περιμένει. Ο Χρυσόστομος στο τιμόνι.'},{s:'ΝΤΕΜΗΣ',t:'Ο χάρτης δείχνει τον Άγιο Γεώργιο. Πάμε.'}];
                 },
                 walk:()=>{
                   if(!state.inv.find(i=>i.id==='nautical_chart')) return [{s:'ΝΤΕΜΗΣ',t:'Δεν ξέρουμε πού να πάμε ακόμα. Χρειαζόμαστε χάρτη.'}];
                   if(!state.flags.threshold_done){
                     state.flags.threshold_done=1;
                     showDlg([
                       {s:'ΝΤΕΜΗΣ',t:'Ο χάρτης δείχνει τον Άγιο Γεώργιο. Σίγουροι;'},
                       {s:'ΑΙΑΣ',t:'Σίγουρος.'},
                       {s:'',t:'Η Κλειώ κουνάει σοβαρά το κεφάλι.'},
                     ], () => changeScene('boat'));
                     return [];
                   }
                   return 'boat';
                 },
                 use:()=>{
                   if(!state.inv.find(i=>i.id==='nautical_chart')) return [{s:'ΝΤΕΜΗΣ',t:'Δεν ξέρουμε πού να πάμε ακόμα. Χρειαζόμαστε χάρτη.'}];
                   if(!state.flags.threshold_done){
                     state.flags.threshold_done=1;
                     showDlg([
                       {s:'ΝΤΕΜΗΣ',t:'Ο χάρτης δείχνει τον Άγιο Γεώργιο. Σίγουροι;'},
                       {s:'ΑΙΑΣ',t:'Σίγουρος.'},
                       {s:'',t:'Η Κλειώ κουνάει σοβαρά το κεφάλι.'},
                     ], () => changeScene('boat'));
                     return [];
                   }
                   return 'boat';
                 }}},
    ],
    exits: [{ side:'right', target:'exterior', label:'Σπίτι →' }, { side:'left', target:'museum', label:'← Μουσείο' }],
    entry: [
      {s:'',t:'Το λιμάνι του Γαλαξειδίου. Μισοφέγγαρο από πέτρα, κυμαρισμένο φως, μυρωδιά αλμύρας.'},
      {s:'ΑΙΑΣ',t:'Αυτό το λιμάνι φαίνεται τεράστιο για τόσο μικρό χωριό.'},
      {s:'ΝΤΕΜΗΣ',t:'Γιατί κάποτε δεν ήταν μικρό χωριό. Ήταν ναυτική δύναμη.'},
      {s:'ΚΛΕΙΩ',t:'Τριακόσια καράβια, μπαμπά. Το διάβασα.'},
    ],
  },

  // ── SCENE 3: THE NAUTICAL MUSEUM ──
  museum: {
    label: 'ΤΟ ΝΑΥΤΙΚΟ ΜΟΥΣΕΙΟ', bg: 'bg-museum',
    walkLine: [[30, 380], [320, 377], [610, 380]],
    charPos: { ntemis: { x: 320, y: 377 }, ajax: { x: 420, y: 380 }, clio: { x: 200, y: 379 } },
    objects: [
      { id:'model_ship', x:20, y:40, w:180, h:150, label:'Μοντέλο ιστιοφόρου',
        verbs: { look:[{s:'',t:'Ένα πανέμορφο μοντέλο τρικάταρτου μέσα σε γυάλινη βιτρίνα. Κάθε λεπτομέρεια τέλεια.'},{s:'ΚΛΕΙΩ',t:'Κοιτάξτε τα πανιά! Ένα-ένα ραμμένα.'},{s:'',t:'Η πινακίδα γράφει: «Σκούνα Χρυσούλα, 1904 — το τελευταίο ιστιοφόρο του Γαλαξειδίου.»'}] }},
      { id:'steamship', x:380, y:40, w:180, h:150, label:'Ατμόπλοιο',
        verbs: { look:[{s:'',t:'Μια γωνιά αφιερωμένη στα ατμόπλοια. Ένα σιδερένιο μοντέλο, μικρότερο, λιγότερο εντυπωσιακό.'},{s:'ΝΤΕΜΗΣ',t:'Αυτό ήταν το μέλλον. Και το Γαλαξίδι δεν το είδε.'},{s:'ΑΙΑΣ',t:'Γιατί; Ήταν χαζοί;'},{s:'ΝΤΕΜΗΣ',t:'Όχι. Ήταν οι καλύτεροι στα πανιά. Γι\u0027 αυτό ακριβώς δεν άλλαξαν.'}] }},
      { id:'portraits_mus', x:200, y:-88, w:180, h:100, label:'Πορτρέτα καπεταναίων',
        verbs: { look:[{s:'',t:'Πορτρέτα σε χρυσές κορνίζες. Σοβαρά πρόσωπα, κομψά μουστάκια, μάτια που έχουν δει θάλασσα.'},{s:'ΚΛΕΙΩ',t:'Αυτός μοιάζει λίγο με τον μπαμπά.'},{s:'ΑΙΑΣ',t:'Ε, λίγο μόνο.'},{s:'ΝΤΕΜΗΣ',t:'Ευχαριστώ, νομίζω.'}] }},
      { id:'instruments', x:30, y:376, w:150, h:60, label:'Ναυτικά όργανα',
        verbs: { look:[{s:'',t:'Πυξίδες, εξάντες, χάρτες. Τα εργαλεία που οδηγούσαν τα πλοία σε κάθε γωνιά της Μεσογείου.'},{s:'ΚΛΕΙΩ',t:'Χωρίς GPS; Πώς;'},{s:'ΝΤΕΜΗΣ',t:'Αστέρια, εμπειρία, και θάρρος.'}] }},
      { id:'flags', x:100, y:-112, w:400, h:40, label:'Σημαίες',
        verbs: { look:[{s:'',t:'Ναυτικές σημαίες κρέμονται από το ταβάνι. Ελληνική, γαλλική, ρωσική — τα λιμάνια που γνώριζαν.'}] }},
      { id:'map_table', x:470, y:100, w:140, h:160, label:'Χάρτης',
        verbs: { look:[{s:'',t:'Ένας παλιός χάρτης του Κορινθιακού κρεμασμένος στον τοίχο. Σημειώσεις με μελάνι — δρόμοι ναυσιπλοΐας.'},{s:'ΚΛΕΙΩ',t:'Μπαμπά, σημείωσε αυτό. Μπορεί να μας χρειαστεί.'}] }},
      { id:'curator_npc', x:205, y:300, w:55, h:80, label:'Επιμελητής',
        verbs: { look:[{s:'',t:'Ο επιμελητής του μουσείου. Τα μάτια του λάμπουν πίσω από τα στρογγυλά γυαλιά.'}],
                 talk:[{s:'ΕΠΙΜΕΛΗΤΗΣ',t:'Καλώς ήρθατε! Βλέπω ξέρετε να εκτιμάτε την ιστορία.'},{s:'ΝΤΕΜΗΣ',t:'Τα παιδιά μου ήθελαν να δουν τα καράβια.'},{s:'ΕΠΙΜΕΛΗΤΗΣ',t:'Τριακόσια πλοία! Η Χρυσούλα ήταν το τελευταίο. Τα ατμόπλοια τα σκότωσαν όλα.'},{s:'ΚΛΕΙΩ',t:'Γιατί δεν έφτιαξαν κι αυτοί ατμόπλοια;'},{s:'ΕΠΙΜΕΛΗΤΗΣ',t:'Ωραία ερώτηση, μικρή. Ήταν τόσο καλοί στα πανιά, που δεν φαντάζονταν κόσμο χωρίς αυτά.'}] }},
    ],
    exits: [{ side:'right', target:'port', label:'Λιμάνι →' }, { side:'left', target:'liotrivi', label:'← Λιοτρίβι' }],
    entry: [
      {s:'',t:'Το Ναυτικό Μουσείο του Γαλαξειδίου. Μυρωδιά ξύλου και παλιού χαρτιού.'},
      {s:'ΚΛΕΙΩ',t:'Πόσα μοντέλα! Θέλω να τα δω ΟΛΑ.'},
      {s:'ΑΙΑΣ',t:'Εγώ θέλω να δω αν έχει κανόνια.'},
      {s:'ΝΤΕΜΗΣ',t:'Σσσ. Μουσείο, παιδιά. Ησυχία.'},
    ],
  },

  // ── SCENE 4: LIOTRIVI BAR ──
  liotrivi: {
    label: 'ΛΙΟΤΡΙΒΙ', bg: 'bg-liotrivi',
    walkLine: [[30, 378], [320, 375], [610, 378]],
    charPos: { ntemis: { x: 320, y: 375 }, ajax: { x: 400, y: 377 }, clio: { x: 240, y: 377 } },
    objects: [
      { id:'olive_press', x:10, y:8, w:140, h:180, label:'Ελαιοτριβείο',
        verbs: { look:[{s:'',t:'Το παλιό ελαιοτριβείο — πέτρα και ξύλο. Κάποτε έβγαζε λάδι, τώρα βγάζει ιστορίες.'},{s:'ΚΛΕΙΩ',t:'Φανταστείτε πόσα χέρια το γύρισαν.'}] }},
      { id:'bar_counter', x:200, y:8, w:180, h:120, label:'Μπαρ',
        verbs: { look:[{s:'',t:'Ξύλινο μπαρ γεμάτο μπουκάλια. Τσίπουρο, ρακή, κρασιά ντόπια. Φανάρια ρίχνουν ζεστό φως.'},{s:'ΑΙΑΣ',t:'Εγώ μπορώ να πάρω λεμονάδα;'}] }},
      { id:'window_liot', x:420, y:-40, w:130, h:140, label:'Παράθυρο',
        verbs: { look:[{s:'',t:'Γαλάζια πατζούρια ανοιχτά στο φεγγαρόφωτο. Το λιμάνι λάμπει ασημί.'},{s:'ΚΛΕΙΩ',t:'Μαγικό. Σαν πίνακας ζωγραφικής.'}] }},
      { id:'photos_liot', x:150, y:-88, w:100, h:60, label:'Παλιές φωτογραφίες',
        verbs: { look:[{s:'',t:'Ασπρόμαυρες φωτογραφίες στον τοίχο. Ψαράδες, καπετάνιοι, γυναίκες που περίμεναν.'},{s:'ΝΤΕΜΗΣ',t:'Κάθε φωτογραφία και μια ιστορία. Κάθε πρόσωπο και μια ζωή.'}] }},
      { id:'stools', x:280, y:280, w:80, h:60, label:'Σκαμπό',
        verbs: { look:[{s:'',t:'Ξύλινα σκαμπό τριγμένα από χρόνια. Πόσες κουβέντες έχουν ακούσει.'}],
                 use:[{s:'ΝΤΕΜΗΣ',t:'Κάτσε. Ξεκουράσου. Η νύχτα είναι μακριά.'}] }},
      { id:'checkered_floor', x:100, y:360, w:400, h:80, label:'Πλακάκια',
        verbs: { look:[{s:'',t:'Πλακάκια σε σκακιέρα — κίτρινα και καφέ. Λαμπυρίζουν στο φως των φαναριών.'}] }},
      { id:'athos_npc', x:485, y:280, w:55, h:95, label:'Άθος',
        verbs: { look:[{s:'',t:'Ο Άθος. Δικηγόρος και ιδιοκτήτης του Λιοτριβιού. Τα μάτια του κρύβουν χίλια μυστικά.'}],
                 talk:[{s:'ΑΘΟΣ',t:'Λατσούδη! Περίμενα πότε θα φτάσεις.'},{s:'ΝΤΕΜΗΣ',t:'Με ξέρεις;'},{s:'ΑΘΟΣ',t:'Ξέρω τον παππού σου. Ήξερα. Και ξέρω τι ψάχνεις.'},{s:'ΑΘΟΣ',t:'Ο Βισβίκης άφησε διαθήκη. Αν θέλεις απαντήσεις, ψάξε στο σπήλαιο του Κάρκαρου.'},{s:'ΑΘΟΣ',t:'Κι ο Χρυσόστομος στο λιμάνι — γνώριζε τον πατέρα σου. Θα σε πάει αν του δείξεις χάρτη.'},{s:'ΚΛΕΙΩ',t:'Σπήλαιο; Θα πάμε σε σπήλαιο;!'}] }},
    ],
    exits: [{ side:'right', target:'museum', label:'Μουσείο →' }, { side:'left', target:'church', label:'← Εκκλησία' }],
    entry: [
      {s:'',t:'Το Λιοτρίβι. Πέτρα, ξύλο, ζεστό φως. Μυρωδιά τσίπουρου και ελιάς.'},
      {s:'ΑΙΑΣ',t:'Αυτό μοιάζει σαν πειρατικό καπηλειό!'},
      {s:'ΚΛΕΙΩ',t:'Μυρίζει ωραία. Σαν τη γιαγιά.'},
      {s:'ΝΤΕΜΗΣ',t:'Ελάτε, ας δούμε ποιος είναι εδώ.'},
    ],
  },

  // ── SCENE 5: THE CAVE OF KARKAROS ──
  cave: {
    label: 'ΤΟ ΣΠΗΛΑΙΟ ΤΟΥ ΚΑΡΚΑΡΟΥ', bg: 'bg-cave',
    walkLine: [[30, 383], [310, 380], [610, 383]],
    charPos: { ntemis: { x: 310, y: 380 }, ajax: { x: 390, y: 382 }, clio: { x: 230, y: 381 } },
    objects: [
      { id:'vote_inscription', x:150, y:30, w:200, h:100, label:'Χαραγμένη επιγραφή',
        verbs: {
          look: () => {
            if (state.flags.vote_read) return [{s:'',t:'Η επιγραφή στον βράχο: «Πρόταση για ατμόπλοιο. Απορρίφθηκε, 9 προς 3.»'},{s:'ΑΙΑΣ',t:'Τρεις ήξεραν. Και κανείς δεν τους άκουσε.'}];
            state.flags.vote_read = true;
            return [
              {s:'ΑΙΑΣ',t:'Μπαμπά, κοίτα εκεί πάνω! Κάτι γράφει στον βράχο.'},
              {s:'ΝΤΕΜΗΣ',t:'Είναι ψηλά. Μπορείς να σκαρφαλώσεις, Αία;'},
              {s:'ΑΙΑΣ',t:'Εύκολο!'},
              {s:'',t:'Ο Αίαντας σκαρφαλώνει στον βράχο και διαβάζει δυνατά:'},
              {s:'ΑΙΑΣ',t:'«Πρόταση για ατμόπλοιο. Απορρίφθηκε, 9 προς 3.»'},
              {s:'',t:'Σιωπή.'},
              {s:'ΝΤΕΜΗΣ',t:'Ψηφοφορία. Κάποιος πρότεινε να αγοράσουν ατμόπλοιο. Εννιά καπεταναίοι είπαν όχι. Τρεις είπαν ναι.'},
              {s:'ΝΤΕΜΗΣ',t:'Ο Βισβίκης ήταν ένας από τους τρεις.'},
              {s:'ΑΙΑΣ',t:'Τρεις ήξεραν. Και κανείς δεν τους άκουσε.'},
            ];
          },
        }},
      { id:'captain_marks', x:10, y:100, w:100, h:120, label:'Σημάδια καπεταναίων',
        verbs: { look:[{s:'',t:'Χαραγμένα σύμβολα στον βράχο. Ονόματα πλοίων, αρχικά, ημερομηνίες.'},{s:'ΑΙΑΣ',t:'Μπαμπά, κοίτα — ο Βισβίκης ήταν εδώ. «Λ.Β. 1887.»'},{s:'ΚΛΕΙΩ',t:'Αυτά δεν είναι πειρατικά. Είναι σημάδια καπεταναίων!'},{s:'ΝΤΕΜΗΣ',t:'Σωστά. Κάθε καπετάνιος είχε το δικό του σήμα. Αυτοί οι τοίχοι θυμούνται.'}],
                 use:[{s:'ΝΤΕΜΗΣ',t:'Δεν τα αγγίζω. Αυτά πρέπει να μείνουν ανέπαφα.'}] }},
      { id:'cave_water', x:100, y:260, w:350, h:100, label:'Νερό',
        verbs: { look:[{s:'',t:'Τυρκουάζ νερό λάμπει από το φως του φαναριού. Κρυστάλλινο.'},{s:'ΑΙΑΣ',t:'Μπορώ να κολυμπήσω;'},{s:'ΝΤΕΜΗΣ',t:'Όχι τώρα, Αία. Ποιος ξέρει πόσο βαθιά είναι.'}],
                 use:[{s:'ΑΙΑΣ',t:'Μπορώ να—'},{s:'ΝΤΕΜΗΣ',t:'Όχι. Πολύ βαθιά, πολύ κρύα.'}] }},
      { id:'stalactites', x:50, y:0, w:500, h:60, label:'Σταλακτίτες',
        verbs: { look:[{s:'',t:'Σταλακτίτες κρέμονται σαν δάχτυλα γίγαντα. Χιλιάδες χρόνια σε κάθε σταγόνα.'},{s:'ΚΛΕΙΩ',t:'Ο Κάρκαρος. Λέγανε ότι η φωνή σου γυρίζει πίσω τρεις φορές.'}],
                 use:[{s:'ΝΤΕΜΗΣ',t:'Δεν αγγίζουμε σταλακτίτες. Χρειάστηκαν χιλιάδες χρόνια.'}] }},
      { id:'jade_stone', x:180, y:30, w:60, h:50, label:'Ρωγμή στον βράχο',
        verbs: {
          look: () => {
            if (state.inv.find(i => i.id === 'green_stone')) return [{s:'',t:'Η ρωγμή στον βράχο. Εκεί βρήκε η Κλειώ την πράσινη πέτρα.'}];
            if (state.flags.jade_found) return [{s:'',t:'Η ρωγμή είναι άδεια τώρα.'}];
            return [
              {s:'',t:'Μια βαθιά ρωγμή στον βράχο, ψηλά. Κάτι αχνοφέγγει μέσα.'},
              {s:'ΝΤΕΜΗΣ',t:'Ψάξτε παντού. Η πέτρα πρέπει να είναι εδώ κάπου.'},
              {s:'ΑΙΑΣ',t:'Κοίταξα σε κάθε σχισμή. Τίποτα.'},
              {s:'ΚΛΕΙΩ',t:'Εγώ βλέπω κάτι εκεί πάνω...'},
            ];
          },
          use: () => {
            if (state.inv.find(i => i.id === 'green_stone')) return [{s:'',t:'Ήδη βρήκατε την πράσινη πέτρα.'}];
            if (state.flags.jade_found) return [{s:'',t:'Η ρωγμή είναι άδεια τώρα.'}];
            showDlg([{s:'',t:'Ο Ντέμης σκύβει στη ρωγμή. Τα δάχτυλά του αγγίζουν κάτι λείο, ζεστό...'}], () => startJadeSequence());
            return [];
          },
        }},
    ],
    exits: [{ side:'right', target:'church', label:'Έξοδος →' }],
    entry: () => {
      const lines = [
        {s:'',t:'Ο Κάρκαρος. Το φανάρι φωτίζει τοίχους γεμάτους αρχαία σημάδια. Σταγόνες ηχούν στο σκοτάδι.'},
        {s:'ΚΛΕΙΩ',t:'Μπαμπά... αυτό δεν μοιάζει σπήλαιο. Μοιάζει σαν κάποιος να το έφτιαξε.'},
        {s:'ΑΙΑΣ',t:'Κοιτάξτε τους τοίχους! Παντού σημάδια!'},
        {s:'ΝΤΕΜΗΣ',t:'Ονόματα πλοίων, αρχικά, ημερομηνίες. Αιώνες ιστορίας χαραγμένοι στον βράχο.'},
      ];
      if (state.flags.jade_found) {
        lines.splice(0, lines.length,
          {s:'',t:'Ο Κάρκαρος. Ο βράχος θυμάται τη λάμψη της πέτρας.'},
          {s:'ΚΛΕΙΩ',t:'Νιώθω ότι κάτι άλλαξε εδώ μέσα.'},
        );
      }
      return lines;
    },
  },

  // ── SCENE 6: CHURCH OF AGIOS NIKOLAOS ──
  church: {
    label: 'ΑΓΙΟΣ ΝΙΚΟΛΑΟΣ', bg: 'bg-church',
    walkLine: [[30, 378], [300, 375], [610, 378]],
    charPos: { ntemis: { x: 300, y: 375 }, ajax: { x: 390, y: 377 }, clio: { x: 210, y: 377 } },
    objects: [
      { id:'fountain', x:220, y:230, w:160, h:120, label:'Σιντριβάνι',
        verbs: { look:[{s:'',t:'Πέτρινο σιντριβάνι στην πλατεία. Το νερό τρέχει αθόρυβα.'},{s:'ΚΛΕΙΩ',t:'Ρίχνω ένα νόμισμα;'},{s:'ΝΤΕΜΗΣ',t:'Γιατί όχι; Κάνε μια ευχή.'}] }},
      { id:'church_dome', x:250, y:-104, w:160, h:120, label:'Εκκλησία',
        verbs: { look:[{s:'',t:'Ο Άγιος Νικόλαος — προστάτης των ναυτικών. Ο τρούλος λάμπει κόκκινος στον ήλιο.'},{s:'ΝΤΕΜΗΣ',t:'Κάθε καπετάνιος προσευχόταν εδώ πριν φύγει. Και η οικογένειά του μετά.'}] }},
      { id:'bougainvillea_ch', x:0, y:-24, w:90, h:180, label:'Μπουκαμβίλιες',
        verbs: { look:[{s:'',t:'Φούξια μπουκαμβίλιες σκεπάζουν τον τοίχο. Χρώμα που αψηφά τον χρόνο.'}] }},
      { id:'benches', x:40, y:290, w:110, h:60, label:'Παγκάκια',
        verbs: { look:[{s:'',t:'Πέτρινα παγκάκια στη σκιά. Γέροι κάθονταν εδώ κάθε απόγευμα, εδώ και δεκαετίες.'}] }},
      { id:'pots_church', x:370, y:290, w:80, h:70, label:'Γλάστρες',
        verbs: { look:[{s:'',t:'Γλάστρες με γεράνια και λουλούδια. Κάποιος φροντίζει αυτή την πλατεία με αγάπη.'}] }},
      { id:'church_door', x:230, y:0, w:180, h:200, label:'Πόρτα εκκλησίας',
        verbs: { look:[{s:'',t:'Η πόρτα του Αγίου Νικολάου. Ξύλινη, βαριά, ανοιχτή.'}],
                 open:'church_interior', walk:'church_interior', use:'church_interior' }},
    ],
    exits: [{ side:'right', target:'liotrivi', label:'Λιοτρίβι →' }, { side:'left', target:'cave', label:'← Σπήλαιο' }],
    entry: [
      {s:'',t:'Η πλατεία του Αγίου Νικολάου. Ησυχία, λουλούδια, και ήχος νερού.'},
      {s:'ΚΛΕΙΩ',t:'Τι ωραία πλατεία!'},
      {s:'ΝΤΕΜΗΣ',t:'Ο Άγιος Νικόλαος. Προστάτης των ναυτικών. Κατάλληλος για το Γαλαξίδι.'},
    ],
  },

  // ── SCENE 6b: CHURCH INTERIOR — AGIOS NIKOLAOS ──
  church_interior: {
    label: 'ΑΓΙΟΣ ΝΙΚΟΛΑΟΣ — ΕΣΩΤΕΡΙΚΟ', bg: 'bg-church-interior',
    walkLine: [[30, 378], [300, 375], [610, 378]],
    charPos: { ntemis: { x: 300, y: 375 }, ajax: { x: 390, y: 377 }, clio: { x: 210, y: 377 } },
    objects: [
      { id:'icons', x:350, y:8, w:180, h:140, label:'Εικόνες',
        verbs: { look:[{s:'',t:'Χρυσές εικόνες αγίων λάμπουν στο φως των κεριών. Αφιερώματα καπεταναίων και οικογενειών τους.'},{s:'ΚΛΕΙΩ',t:'Κοίτα αυτή — ένα πλοίο στο φόντο πίσω από τον άγιο.'},{s:'ΝΤΕΜΗΣ',t:'Κάθε εικόνα ήταν ευχαριστία για ασφαλή επιστροφή.'}] }},
      { id:'iconostasis', x:120, y:-40, w:280, h:200, label:'Τέμπλο',
        verbs: { look:[{s:'',t:'Σκαλιστό ξύλινο τέμπλο. Φύλλα αμπέλου, ρόδια, δελφίνια — ο καλλιτέχνης ήξερε τη θάλασσα.'},{s:'ΝΤΕΜΗΣ',t:'Αριστούργημα λαϊκής τέχνης. Δεν υπάρχει σαν αυτό.'}],
                 use:[{s:'ΑΙΑΣ',t:'Μπορώ να σκαρφαλώσω;'},{s:'ΠΑΠΑΣ',t:'ΟΧΙ στις εικόνες!'},{s:'ΑΙΑΣ',t:'...εντάξει.'},{s:'ΚΛΕΙΩ',t:'Χαχαχα!'}] }},
      { id:'candles_ci', x:50, y:168, w:100, h:120, label:'Κεριά',
        verbs: {
          look:[{s:'',t:'Μανουάλι με κεριά. Μερικά καίνε ακόμα — κάποιος πέρασε πρόσφατα.'}],
          use: () => {
            if (state.flags.candle_lit) return [{s:'',t:'Το κερί της Κλειώς καίει ήσυχα.'}];
            state.flags.candle_lit = 1;
            playSFX('candle');
            const sc = scenes.church_interior;
            const tile = sc.objects.find(o => o.id === 'floor_tile');
            if (tile) tile._hidden = false;
            return [{s:'ΚΛΕΙΩ',t:'Θέλω να ανάψω ένα κερί.'},{s:'ΝΤΕΜΗΣ',t:'Για ποιον, αγάπη μου;'},{s:'ΚΛΕΙΩ',t:'Για τους καπεταναίους και τα πλοία τους.'},{s:'',t:'Η φλόγα τρεμοπαίζει. Σκιές χορεύουν στους τοίχους.'}];
          },
        }},
      { id:'floor_tile', x:220, y:340, w:100, h:50, label:'Πλάκα «Λ.Β.»', _hidden: true,
        verbs: {
          look: () => {
            if (!state.flags.candle_lit) return [{s:'',t:'Τίποτα ιδιαίτερο στο πάτωμα.'}];
            return [{s:'ΚΛΕΙΩ',t:'Μπαμπά! Κοίτα αυτή την πλάκα — έχει γράμματα!'},{s:'ΝΤΕΜΗΣ',t:'«Λ.Β.» — Λουκάς Βισβίκης!'},{s:'ΑΙΑΣ',t:'Ανοίξτε την! Ανοίξτε την!'}];
          },
          use: () => {
            if (!state.flags.candle_lit) return [{s:'ΝΤΕΜΗΣ',t:'Δεν βλέπω τίποτα εδώ κάτω.'}];
            if (state.inv.find(i => i.id === 'nautical_chart')) return [{s:'',t:'Η κρυψώνα κάτω από την πλάκα είναι άδεια τώρα.'}];
            addInv({id:'nautical_chart', label:'Ναυτικός Χάρτης', desc: 'Χειρόγραφος χάρτης του Κορινθιακού Κόλπου. Ένα X σημαδεύει τον Άγιο Γεώργιο. «Κάτω από τον σταυρό, πέντε βήματα. Σκάψε.»'});
            return [{s:'',t:'Κάτω από την πλάκα — ένα δερμάτινο κύλινδρο. Μέσα, ένας χειρόγραφος χάρτης.'},{s:'ΝΤΕΜΗΣ',t:'Χειρόγραφος χάρτης του Κορινθιακού. X σημαδεύει τον Άγιο Γεώργιο.'},{s:'ΚΛΕΙΩ',t:'Υπάρχει σημείωμα: «Κάτω από τον σταυρό, πέντε βήματα. Σκάψε.»'},{s:'ΑΙΑΣ',t:'ΘΗΣΑΥΡΟΣ!'}];
          },
          open: function() { return scenes.church_interior.objects.find(o => o.id === 'floor_tile').verbs.use(); },
        }},
      { id:'floor', x:100, y:340, w:400, h:55, label:'Πάτωμα',
        verbs: {
          look: () => {
            if (state.flags.candle_lit) return [{s:'',t:'Πέτρινες πλάκες στο πάτωμα. Μια φαίνεται... διαφορετική. Με χαραγμένα γράμματα.'}];
            return [{s:'',t:'Πέτρινες πλάκες στο πάτωμα. Με περισσότερο φως ίσως φανεί κάτι...'},{s:'ΚΛΕΙΩ',t:'Ας ανάψουμε ένα κερί!'}];
          },
        }},
      { id:'papas_npc', x:450, y:280, w:80, h:110, label:'Παπά Νικόλα',
        verbs: { look:[{s:'',t:'Ο Παπά Νικόλας. Εξήντα χρονών, ζεστό πρόσωπο, πονηρό χαμόγελο.'}],
                 talk:[{s:'ΠΑΠΑΣ',t:'Καλώς ήρθατε στον Άγιο Νικόλαο, παιδιά μου.'},{s:'ΝΤΕΜΗΣ',t:'Γεια σας, πάτερ. Ψάχνουμε για τον Βισβίκη.'},{s:'ΠΑΠΑΣ',t:'Α, τον Λουκά! Ο μεγαλύτερος ευεργέτης αυτής της εκκλησίας.'},{s:'ΠΑΠΑΣ',t:'Αυτός έφτιαξε το τέμπλο, αυτός πλήρωνε τα κεριά, αυτός...'},{s:'ΑΙΑΣ',t:'Αυτός τα έκανε ΟΛΑ;'},{s:'ΠΑΠΑΣ',t:'Σχεδόν, παιδί μου. Σχεδόν. Κοιτάξτε γύρω σας — βλέπετε τα ίχνη του παντού.'}] }},
    ],
    exits: [{ side:'left', target:'church', label:'← Πλατεία' }],
    entry: [
      {s:'',t:'Ημίφως και μυρωδιά λιβανιού. Χρυσές εικόνες λάμπουν στη σιωπή.'},
      {s:'ΚΛΕΙΩ',t:'Τι ωραία... σαν να μπαίνεις σε άλλο κόσμο.'},
      {s:'ΑΙΑΣ',t:'Γιατί είναι σκοτεινά;'},
      {s:'ΝΤΕΜΗΣ',t:'Γιατί εδώ μέσα ακούς καλύτερα. Ακόμα κι τη σιωπή.'},
    ],
  },

  // ── SCENE 7: THE WINDMILL ──
  windmill: {
    label: 'Ο ΜΥΛΟΣ', bg: 'bg-windmill',
    walkLine: [[30, 380], [350, 377], [530, 380]],
    walkBounds: [30, 530], // stone path narrows before hill edge
    charPos: { ntemis: { x: 350, y: 377 }, ajax: { x: 440, y: 379 }, clio: { x: 260, y: 378 } },
    objects: [
      { id:'telescope', x:470, y:220, w:80, h:160, label:'Παρατηρητήριο',
        verbs: { look:[{s:'',t:'Ένα παλιό παρατηρητήριο στην άκρη του λόφου. Βλέπει ολόκληρο τον κόλπο.'},{s:'ΚΛΕΙΩ',t:'Αφήστε με να κοιτάξω!'}],
                 use:()=>{
                   if(!state.flags.telescope_used){
                     state.flags.telescope_used=1;
                     setTimeout(()=>{ startCutscene('telescope_island'); },800);
                   }
                   return [{s:'ΚΛΕΙΩ',t:'Βλέπω... ένα νησάκι! Με ένα λευκό εκκλησάκι πάνω στον βράχο!'},{s:'ΑΙΑΣ',t:'Πού; Δείξε μου!'},{s:'ΚΛΕΙΩ',t:'Εκεί, στη μέση του κόλπου. Λάμπει στον ήλιο!'},{s:'ΝΤΕΜΗΣ',t:'Ο Άγιος Γεώργιος. Σημείωσέ τον, Κλειώ.'}];
                 } }},
      { id:'panorama', x:0, y:-88, w:640, h:100, label:'Πανόραμα',
        verbs: { look:[{s:'',t:'Η θέα κόβει την ανάσα. Ολόκληρο το Γαλαξίδι, ο κόλπος, τα βουνά. Από εδώ βλέπεις τα πάντα.'},{s:'ΑΙΑΣ',t:'Μπαμπά, βλέπω μέχρι την Ιτέα!'},{s:'ΚΛΕΙΩ',t:'Και τους Δελφούς! Εκεί πάνω!'}] }},
      { id:'windmill_tower', x:470, y:88, w:120, h:130, label:'Ο μύλος',
        verbs: { look:[{s:'',t:'Πέτρινος ανεμόμυλος — φτερά ακόμα όρθια, αψηφώντας τον χρόνο. Κάποτε άλεθε σιτάρι για ολόκληρο το Γαλαξείδι.'}],
                 use:[{s:'ΑΙΑΣ',t:'Μπορώ να ανέβω;'},{s:'ΝΤΕΜΗΣ',t:'Δεν είναι ασφαλές. Ο μύλος είναι ερείπιο.'}] }},
      { id:'wildflowers', x:150, y:280, w:200, h:80, label:'Αγριολούλουδα',
        verbs: { look:[{s:'',t:'Παπαρούνες, μαργαρίτες, θυμάρι. Ο λόφος μυρίζει μέλι και καλοκαίρι.'},{s:'ΚΛΕΙΩ',t:'Θέλω να ζωγραφίσω αυτά.'}],
                 use:[{s:'ΚΛΕΙΩ',t:'Μπορώ να μαζέψω μερικά;'},{s:'ΝΤΕΜΗΣ',t:'Άσε τα εδώ, Κλειώ. Εδώ είναι πιο ωραία.'}] }},
      { id:'stone_path_wm', x:300, y:360, w:200, h:60, label:'Μονοπάτι',
        verbs: { look:[{s:'',t:'Πέτρινο καλντερίμι ανεβαίνει τον λόφο. Λειασμένο από πόδια αιώνων.'}] }},
      { id:'giannis_npc', x:125, y:309, w:75, h:105, label:'Γιάννης Βελανής',
        verbs: { look:()=>{
                   if(state.flags.lantern_given) return [{s:'',t:'Ο Γιάννης Βελανής. Μας έδωσε φανάρι και φτυάρι. Βλέπει τα πάντα από ψηλά.'}];
                   return [{s:'',t:'Ο Γιάννης Βελανής. Ιδιοκτήτης του παλιού μύλου. Ήσυχος, βλέπει τα πάντα από ψηλά.'}];
                 },
                 talk:()=>{
                   if(state.flags.lantern_given) return [{s:'ΓΙΑΝΝΗΣ',t:'Προσοχή εκεί κάτω. Το σπήλαιο έχει μυστικά.'}];
                   state.flags.lantern_given=1;
                   addInv({id:'lantern',label:'Φανάρι',desc:'Ένα ορειχάλκινο ναυτικό φανάρι. Παλιό αλλά καλοσυντηρημένο. Δώρο του Γιάννη.'});
                   addInv({id:'shovel',label:'Φτυάρι',desc:'Ένα μικρό σιδερένιο φτυάρι. Σκουριασμένο αλλά γερό. Δώρο του Γιάννη.'});
                   return [{s:'ΓΙΑΝΝΗΣ',t:'...'},{s:'ΝΤΕΜΗΣ',t:'Γεια σου. Ψάχνουμε το σπήλαιο του Κάρκαρου.'},{s:'ΓΙΑΝΝΗΣ',t:'Το ξέρω. Σε βλέπω από εδώ πάνω.'},{s:'ΓΙΑΝΝΗΣ',t:'Πάρε αυτά. Θα τα χρειαστείς.'},{s:'',t:'Ο Γιάννης σου δίνει ένα ορειχάλκινο φανάρι κι ένα μικρό φτυάρι.'},{s:'ΓΙΑΝΝΗΣ',t:'Δεν ξέρεις τι θα βρεις εκεί κάτω.'}];
                 } }},
    ],
    exits: [{ side:'right', target:'graveyard', label:'Νεκροταφείο →' }, { side:'left', target:'terrace', label:'← Βεράντα' }],
    entry: () => {
      const lines = [
        {s:'',t:'Ο αέρας σφυρίζει στα ερείπια του μύλου. Η θέα κόβει την ανάσα.'},
        {s:'ΑΙΑΣ',t:'Μπαμπά, από εδώ βλέπεις τα πάντα!'},
        {s:'ΚΛΕΙΩ',t:'Κοίτα, ένας ανεμόμυλος!'},
      ];
      if (state.flags.lantern_given) {
        lines.push(
          {s:'ΝΤΕΜΗΣ',t:'Ο Γιάννης μας έδωσε ό,τι χρειαζόμαστε. Ώρα για το σπήλαιο.'},
        );
      }
      return lines;
    },
  },

  // ── SCENE 8: THE BOAT (ELPIDA) ──
  boat: {
    label: 'ΤΟ ΚΑΡΑΒΙ — ΕΛΠΙΔΑ', bg: 'bg-boat',
    walkLine: [[50, 378], [250, 375], [430, 378]],
    walkBounds: [50, 430], // deck ends before open sea
    charPos: { ntemis: { x: 350, y: 375 }, ajax: { x: 430, y: 377 }, clio: { x: 270, y: 377 } },
    objects: [
      { id:'nameplate', x:50, y:376, w:120, h:40, label:'ΕΛΠΙΔΑ',
        verbs: { look:[{s:'',t:'«ΕΛΠΙΔΑ» — χρυσά γράμματα σε ξεφλουδισμένο μπλε ξύλο.'},{s:'ΝΤΕΜΗΣ',t:'Ελπίδα. Πάντα υπάρχει ελπίδα.'}] }},
      { id:'chapel', x:30, y:-24, w:150, h:150, label:'Παρεκκλήσι',
        verbs: { look:[{s:'',t:'Ένα μικρό λευκό παρεκκλήσι πάνω στον βράχο. Ελληνική σημαία κυματίζει.'},{s:'ΚΛΕΙΩ',t:'Ποιος πάει εκεί πάνω για λειτουργία;'},{s:'ΝΤΕΜΗΣ',t:'Οι ψαράδες. Πριν και μετά το ταξίδι.'}] }},
      { id:'sunset_sea', x:200, y:-88, w:400, h:120, label:'Ηλιοβασίλεμα',
        verbs: { look:[{s:'',t:'Ο ήλιος βυθίζεται στον Κορινθιακό. Χρυσό, πορτοκαλί, ροζ. Τα βουνά γίνονται σκιές.'},{s:'',t:'Κανείς δεν μιλάει. Δεν χρειάζεται.'}] }},
      { id:'rope', x:350, y:280, w:80, h:60, label:'Σχοινιά',
        verbs: { look:[{s:'',t:'Σχοινιά τυλιγμένα στο κατάστρωμα. Μυρίζουν θάλασσα και πεύκο.'}],
                 use:[{s:'ΑΙΑΣ',t:'Ξέρω κόμπους! Ο παππούς μου έμαθε.'},{s:'ΝΤΕΜΗΣ',t:'Δείξε μας.'}] }},
      { id:'lifebuoy', x:460, y:344, w:60, h:60, label:'Σωσίβιο',
        verbs: { look:[{s:'',t:'Πορτοκαλί σωσίβιο. Λευκά γράμματα: ΕΛΠΙΔΑ — ΓΑΛΑΞΙΔΙ.'}] }},
      { id:'galaxidi_view', x:400, y:8, w:200, h:100, label:'Γαλαξίδι στο βάθος',
        verbs: { look:[{s:'',t:'Το Γαλαξίδι λάμπει στον ήλιο του δειλινού. Σπίτια, εκκλησίες, το λιμάνι — σαν μακέτα.'},{s:'ΚΛΕΙΩ',t:'Από εδώ φαίνεται σαν παραμύθι.'}] }},
      { id:'chrysostomos_npc', x:75, y:280, w:75, h:110, label:'Χρυσόστομος',
        verbs: { look:[{s:'',t:'Ο Χρυσόστομος στο τιμόνι. Εβδομήντα χρονών, μάτια σαν τη θάλασσα.'}],
                 talk:()=>{
                   // Drop music to let his words fill the silence
                   const prevVol = bgm.volume;
                   bgm.volume = prevVol * 0.3;
                   showDlg([
                     {s:'ΧΡΥΣΟΣΤΟΜΟΣ',t:'Ο πατέρας σου μου είπε ότι κάποια μέρα θα ερχόσουν.'},
                     {s:'ΧΡΥΣΟΣΤΟΜΟΣ',t:'Η θάλασσα δεν σε ρωτάει τι αγαπάς. Αλλάζει κι εσύ αλλάζεις μαζί της.'},
                     {s:'ΝΤΕΜΗΣ',t:'Γνώριζες τον Βισβίκη;'},
                     {s:'ΧΡΥΣΟΣΤΟΜΟΣ',t:'Ήταν ο τελευταίος ρομαντικός. Κανείς δεν τον πίστεψε. Πέθανε μόνος. Αλλά δεν πέθανε χωρίς σχέδιο.'},
                     {s:'ΧΡΥΣΟΣΤΟΜΟΣ',t:'Η Ελπίδα ξέρει τον δρόμο. Εγώ απλά κρατάω το τιμόνι.'},
                   ], () => { bgm.volume = prevVol; });
                   return [];
                 } }},
    ],
    exits: [{ side:'left', target:'treasure', label:'← Νησί' },{ side:'right', target:'port', label:'Γαλαξίδι →' }],
    entry: [
      {s:'',t:'Η Ελπίδα πλέει αργά στον Κορινθιακό. Ο κόσμος σταμάτησε.'},
      {s:'ΚΛΕΙΩ',t:'Αυτό... αυτό είναι τέλειο.'},
      {s:'ΑΙΑΣ',t:'Μπαμπά, μπορούμε να μείνουμε για πάντα εδώ;'},
      {s:'ΝΤΕΜΗΣ',t:'Για λίγο ακόμα. Κοιτάξτε τον ήλιο.'},
    ],
  },

  // ── SCENE 9: THE GRAVEYARD ──
  graveyard: {
    label: 'ΤΟ ΝΕΚΡΟΤΑΦΕΙΟ', bg: 'bg-graveyard',
    walkLine: [[30, 380], [300, 377], [500, 380]],
    walkBounds: [30, 500], // cemetery path ends before sea overlook
    charPos: { ntemis: { x: 250, y: 377 }, ajax: { x: 340, y: 379 }, clio: { x: 160, y: 378 } },
    objects: [
      { id:'visvikis_grave', x:355, y:248, w:80, h:90, label:'Τάφος Βισβίκη',
        verbs: {
          look:[{s:'',t:'Μαρμάρινη πλάκα, πιο μεγαλοπρεπής από τις άλλες. Χαραγμένο: «Πλοίαρχος Λ. Βισβίκης».'},{s:'ΚΛΕΙΩ',t:'Κοίτα κάτω — «Η θάλασσα θυμάται».'},{s:'ΑΙΑΣ',t:'Αυτός είναι ο καπετάνιος από το γράμμα!'}],
          use: () => {
            if (state.flags.ghost_summoned) return [{s:'',t:'Η πέτρα ήδη τοποθετήθηκε. Η πλάκα λάμπει αχνά.'}];
            if (!state.inv.find(i => i.id === 'green_stone')) return [{s:'ΝΤΕΜΗΣ',t:'Λείπει κάτι. Η εσοχή στην πλάκα... σαν να περιμένει κάτι.'}];
            showDlg([
              {s:'ΝΤΕΜΗΣ',t:'Η εσοχή... αυτό ζητάει η πλάκα.'},
              {s:'',t:'Η πράσινη πέτρα ταιριάζει ακριβώς. Λάμπει αχνά...', sfx:'stone'}
            ], () => {
              removeInv('green_stone');
              state.flags.ghost_summoned = true;
              startGhostSequence();
            });
            return [];
          },
        }},
      { id:'headstones', x:50, y:216, w:150, h:120, label:'Ταφόπλακες',
        verbs: { look:[{s:'',t:'Μαρμάρινοι σταυροί και πλάκες. Χαραγμένα πλοία στις πέτρες. Ονόματα καπεταναίων: Τσώνης, Ρήγας, Μαμάς.'},{s:'ΚΛΕΙΩ',t:'Κάθε πέτρα και ένα ταξίδι.'},{s:'ΝΤΕΜΗΣ',t:'Κάθε πέτρα και μια οικογένεια που περίμενε.'}] }},
      { id:'cypress', x:0, y:-88, w:70, h:320, label:'Κυπαρίσσια',
        verbs: { look:[{s:'',t:'Κυπαρίσσια ψηλά σαν κατάρτια. Φρουροί αιώνιοι στο φεγγαρόφωτο.'}] }},
      { id:'angel_statue', x:560, y:152, w:70, h:150, label:'Άγγελος',
        verbs: { look:[{s:'',t:'Μαρμάρινος άγγελος με σκυμμένο κεφάλι. Προσεύχεται πάνω από τον τάφο του Βισβίκη.'},{s:'ΚΛΕΙΩ',t:'Σαν να τον φυλάει ακόμα.'}] }},
      { id:'poppies_gr', x:200, y:360, w:180, h:60, label:'Παπαρούνες',
        verbs: { look:[{s:'',t:'Κόκκινες παπαρούνες ανάμεσα στους τάφους, ζωντανές ακόμα και στο σκοτάδι.'},{s:'ΚΛΕΙΩ',t:'Μπαμπά, δεν είναι τρομακτικό. Είναι... ωραίο.'}] }},
      { id:'sea_view_gr', x:220, y:-56, w:220, h:130, label:'Θέα στη θάλασσα',
        verbs: { look:[{s:'',t:'Το φεγγάρι ρίχνει ασημένιο δρόμο στη θάλασσα. Τα φώτα του Γαλαξειδίου αντανακλούν στο νερό.'},{s:'ΑΙΑΣ',t:'Τους έβαλαν εδώ επίτηδες. Να βλέπουν τη θάλασσα για πάντα.'}] }},
      { id:'moon', x:170, y:-88, w:100, h:100, label:'Φεγγάρι',
        verbs: { look:[{s:'',t:'Ολόγιομο φεγγάρι πάνω από τον Κορινθιακό. Φωτίζει τους τάφους σαν ασημένιος φανός.'},{s:'ΚΛΕΙΩ',t:'Σαν να ξέρει ότι ήρθαμε.'}] }},
      { id:'candles', x:350, y:344, w:80, h:40, label:'Κεριά',
        verbs: { look:[{s:'',t:'Αναμμένα κεριά μπροστά στον τάφο. Κάποιος τα φροντίζει ακόμα.'},{s:'ΝΤΕΜΗΣ',t:'120 χρόνια και κάποιος ανάβει ακόμα κεριά. Αυτό είναι αφοσίωση.'}] }},
      { id:'path_stones_gr', x:150, y:376, w:200, h:50, label:'Πέτρινο μονοπάτι',
        verbs: { look:[{s:'',t:'Πλακόστρωτο μονοπάτι ανάμεσα στους τάφους. Λειασμένο από χιλιάδες επισκέψεις.'}] }},
      { id:'ghost_npc', x:445, y:232, w:65, h:120, label: 'Σκιά',
        verbs: {
          look: () => {
            if (!state.flags.ghost_summoned) return [{s:'',t:'Σκιές τρεμοπαίζουν ανάμεσα στα κυπαρίσσια. Σαν να κινείται κάτι...'},{s:'ΚΛΕΙΩ',t:'Μπαμπά... νιώθω κάτι εδώ.'}];
            return [{s:'',t:'Μια αχνή, ψηλή σιλουέτα πάνω από τον τάφο. Τρεμοπαίζει σαν φως σε νερό.'},{s:'ΚΛΕΙΩ',t:'Μπαμπά... βλέπω κάτι εκεί.'},{s:'ΑΙΑΣ',t:'Φάντασμα; Σοβαρά τώρα;'}];
          },
          talk: () => {
            if (!state.flags.ghost_summoned) return [{s:'',t:'Δεν υπάρχει κανείς εδώ... ακόμα.'}];
            return [{s:'ΦΑΝΤΑΣΜΑ',t:'...'},{s:'',t:'Το φάντασμα δεν μιλάει. Δείχνει προς την εκκλησία.'},{s:'ΚΛΕΙΩ',t:'Θέλει να πάμε στον Άγιο Νικόλαο!'},{s:'ΝΤΕΜΗΣ',t:'Μόλις μας έδωσε οδηγίες ένα φάντασμα.'}];
          },
        }},
    ],
    exits: [{ side:'left', target:'terrace', label:'← Βεράντα' }],
    entry: () => {
      const lines = [
        {s:'',t:'Το παλιό νεκροταφείο. Το φεγγάρι φωτίζει τους τάφους, μυρωδιά θυμαριού, ησυχία.'},
        {s:'ΚΛΕΙΩ',t:'Μπαμπά... δεν μου αρέσουν τα νεκροταφεία τη νύχτα.'},
        {s:'ΝΤΕΜΗΣ',t:'Αυτό δεν είναι τρομακτικό. Είναι γεμάτο ιστορίες.'},
        {s:'ΑΙΑΣ',t:'Κοίτα — βλέπεις τη θάλασσα από κάθε τάφο. Αυτό ήθελαν.'},
      ];
      // Transitional dialog: arriving with the green stone — building tension
      if (state.inv.find(i => i.id === 'green_stone')) {
        lines.push(
          {s:'ΚΛΕΙΩ',t:'Μπαμπά, νιώθω κάτι περίεργο με αυτή την πέτρα.'},
          {s:'ΑΙΑΣ',t:'Μη λες βλακείες.'},
          {s:'ΝΤΕΜΗΣ',t:'...Βρείτε τον τάφο του Βισβίκη.'},
        );
      }
      return lines;
    },
  },

  // ── SCENE 10: THE TREASURE ──
  // Simple flow: arrive → LOOK cross → USE dig_spot → cutscene → read letter → exit
  treasure: {
    label: 'Ο ΘΗΣΑΥΡΟΣ', bg: 'bg-treasure',
    walkLine: [[50, 380], [320, 377], [560, 380]],
    walkBounds: [50, 560],
    charPos: { ntemis: { x: 320, y: 377 }, ajax: { x: 410, y: 379 }, clio: { x: 230, y: 378 } },
    objects: [
      { id:'stone_cross', x:420, y:200, w:80, h:100, label:'Πέτρινος σταυρός',
        verbs: {
          look:()=>{
            if(state.flags.cross_examined) return [{s:'',t:'Ο σταυρός του Βισβίκη. «Λ.Β. 1860». Πέντε βήματα νοτιοδυτικά.'}];
            state.flags.cross_examined=1;
            state.flags.spot_found=1;
            return [
              {s:'',t:'Ένας χαμηλός πέτρινος σταυρός. Φαγωμένος από τον χρόνο και την αλμύρα.'},
              {s:'ΚΛΕΙΩ',t:'Κοίτα — γράμματα!'},
              {s:'ΑΙΑΣ',t:'Λ... Β... 1860!'},
              {s:'ΝΤΕΜΗΣ',t:'Λ.Β. — Λουκάς Βισβίκης. Ο χάρτης λέει: πέντε βήματα νοτιοδυτικά. Σκάψε.'},
              {s:'ΑΙΑΣ',t:'Πέντε βήματα! Ένα... δύο... τρία... τέσσερα... πέντε! ΕΔΏΣΚΑΒΟΥΜΕ!'},
            ];
          },
        }},
      { id:'panorama', x:0, y:40, w:350, h:120, label:'Θέα στο Γαλαξίδι',
        verbs: { look:[
          {s:'',t:'Το Γαλαξίδι λάμπει στον πρωινό ήλιο απέναντι. Σπίτια, εκκλησίες, το λιμάνι.'},
          {s:'ΝΤΕΜΗΣ',t:'Από εδώ τα έβλεπε όλα ο Βισβίκης.'},
        ]}},
      { id:'chapel_ext', x:500, y:100, w:140, h:200, label:'Εκκλησάκι Αγ. Γεωργίου',
        verbs: { look:[
          {s:'',t:'Λευκό εκκλησάκι με μπλε τρούλο. Ο Άγιος Γεώργιος φυλάει αυτόν τον βράχο εδώ και αιώνες.'},
          {s:'ΚΛΕΙΩ',t:'Τι ωραίο... Σαν ζαχαρωτό!'},
        ]}},
      { id:'dig_spot', x:120, y:320, w:160, h:60, label:'Σημείο ανασκαφής',
        verbs: {
          look:()=>{
            if(!state.flags.spot_found) return [{s:'',t:'Χώμα και πέτρες. Κοίταξε πρώτα τον σταυρό.'}];
            if(state.flags.chest_opened) return [{s:'',t:'Η τρύπα στη γη. Εδώ βρήκαμε τον θησαυρό.'}];
            return [{s:'',t:'Σκούρο χώμα, πατημένο. Πέντε βήματα νοτιοδυτικά από τον σταυρό.'},{s:'ΑΙΑΣ',t:'ΣΚΑΒΟΥΜΕ!'}];
          },
          use:()=>{
            if(!state.flags.spot_found) return [{s:'ΝΤΕΜΗΣ',t:'Πρέπει να βρούμε το σωστό σημείο πρώτα. Κοίταξε τον σταυρό.'}];
            if(state.flags.chest_opened) return [{s:'',t:'Ο θησαυρός ήδη βγήκε στο φως.'}];
            if(!state.inv.find(i=>i.id==='shovel')) return [{s:'ΑΙΑΣ',t:'Πώς θα σκάψουμε; Χρειαζόμαστε φτυάρι!'},{s:'ΝΤΕΜΗΣ',t:'Ποιος θα είχε φτυάρι εδώ γύρω...'}];
            removeInv('shovel');
            // Dig sequence → silence pocket → metallic hit → chest → cutscene → letter
            playSFX('dig');
            showDlg([
              {s:'',t:'Πατέρας κι γιος σκάβουν μαζί. Σκληρό χώμα, ρίζες θυμαριού, πέτρες.'},
              {s:'ΚΛΕΙΩ',t:'Κι αν δεν υπάρχει τίποτα;'},
              {s:'ΝΤΕΜΗΣ',t:'Τότε ήρθαμε για τη θέα.'},
            ], () => {
              // Silence pocket — fade ALL audio before the CLANG
              fadeAllAudio(0, 600, () => {
                setTimeout(() => {
                  playSFX('metallic_hit');
                  setTimeout(() => fadeAllAudio(1, 2000), 1200);
                }, 800);
              });
              showDlg([
                {s:'',t:'ΚΛΑΝΓΚ! Το φτυάρι χτυπάει κάτι σκληρό.'},
                {s:'ΑΙΑΣ',t:'ΧΤΥΠΗΣΕ! ΚΑΤΙ ΧΤΥΠΗΣΕ!'},
                {s:'ΚΛΕΙΩ',t:'Βλέπω σίδερο... μαντάλια! Είναι κιβώτιο!'},
                {s:'ΑΙΑΣ',t:'ΒΡΗΚΑΜΕ! Μπαμπά, βρήκαμε!'},
              ], () => {
                // Pause before opening
                showDlg([
                  {s:'',t:'Ένα σιδερόδετο ξύλινο κιβώτιο αναδύεται από τη γη. Εκατόν είκοσι χρόνια κάτω από τη γη.'},
                  {s:'ΝΤΕΜΗΣ',t:'Εκατόν είκοσι χρόνια περίμενε. Μπορεί να περιμένει κι ένα λεπτό ακόμα.'},
                  {s:'ΚΛΕΙΩ',t:'Η θάλασσα θυμάται.'},
                  {s:'ΝΤΕΜΗΣ',t:'Ας δούμε τι μας άφησε ο Βισβίκης.'},
                ], () => {
                  // Open chest → cutscene
                  state.flags.chest_opened=1;
                  playSFX('chest');
                  showDlg([
                    {s:'',t:'Το καπάκι ανοίγει αργά... Χρυσό φως ξεχύνεται.'},
                    {s:'',t:'Νομίσματα — Οθωμανικά, Βενετικά, αρχαία. Ένα κολιέ νεφρίτη. Ένα βιβλίο.'},
                    {s:'ΑΙΑΣ',t:'Εκατόν τέσσερις υπογραφές. Σαν ομάδα.'},
                    {s:'',t:'Και στον πάτο... ένα γράμμα. Σφραγισμένο με κερί.'},
                  ], () => {
                    // Launch cutscene
                    document.getElementById('ui-panel').classList.remove('on');
                    document.getElementById('action-line').classList.remove('on');
                    const origComplete = cutscenes.treasure.onComplete;
                    cutscenes.treasure.onComplete = () => {
                      if(origComplete) origComplete();
                      state.phase = 'playing';
                      document.getElementById('ui-panel').classList.add('on');
                      document.getElementById('action-line').classList.add('on');
                      // After cutscene, show the letter reading & family decision
                      state.flags.letter_read=1;
                      playSFX('paper');
                      showDlg([
                        {s:'ΝΤΕΜΗΣ',t:'«Αυτός ο θησαυρός δεν είναι δικός μου. Είναι του Γαλαξειδίου.»', auto:3.5},
                        {s:'ΝΤΕΜΗΣ',t:'«Κράτα την αλληλεγγύη. Άλλαξε το πλοίο. — Καπ. Λ. Βισβίκης»', auto:4},
                        {s:'',t:'Σιωπή. Κύματα και γλάροι.', auto:3},
                        {s:'ΑΙΑΣ',t:'Μπαμπά... τόσο χρυσάφι. ΕΜΕΙΣ το βρήκαμε.'},
                        {s:'ΝΤΕΜΗΣ',t:'Αίαντα. Τι έλεγε η αλληλασφάλεια;'},
                        {s:'ΑΙΑΣ',t:'...Ότι κανείς δεν ταξιδεύει μόνος. Οκ. Το δίνουμε.'},
                        {s:'ΝΤΕΜΗΣ',t:'Όλο. Αλλά εσύ κράτα το κολιέ, Κλειώ.'},
                        {s:'ΚΛΕΙΩ',t:'Η θάλασσα μου το χάρισε.'},
                        {s:'ΑΙΑΣ',t:'Κι εγώ; Τι κρατάω;'},
                        {s:'ΝΤΕΜΗΣ',t:'Τη μνήμη. Κι αυτό αξίζει περισσότερο.'},
                        {s:'ΑΙΑΣ',t:'...Ε ντάξει. Αλλά θα το πω σε ΟΛΟΥΣ στο σχολείο.'},
                        {s:'',t:'Ώρα να γυρίσουν στο Γαλαξίδι.'},
                      ]);
                    };
                    playSFX('fanfare');
                    startCutscene('treasure');
                  });
                });
              });
            });
            return [];
          },
        }},
    ],
    exits: [
      { side:'left', target:'boat', label:'← Ελπίδα' },
      { side:'right', target:'new_era', label:'Γαλαξίδι →' },
    ],
    entry: [
      {s:'',t:'Ο Άγιος Γεώργιος. Ένα ξεχασμένο νησάκι στον κόλπο. Θυμάρι, πέτρα, κι ο ήχος του ανέμου.'},
      {s:'ΑΙΑΣ',t:'Πού σκάβουμε;'},
      {s:'ΝΤΕΜΗΣ',t:'Σιγά. Πρώτα βρίσκουμε τον σταυρό.'},
      {s:'ΚΛΕΙΩ',t:'Εκεί! Βλέπω σταυρό στα βράχια!'},
    ],
  },

  // ── SCENE 11: THE NEW ERA ──
  new_era: {
    label: 'Η ΝΕΑ ΕΠΟΧΗ', bg: 'bg-new-era',
    walkLine: [[30, 378], [320, 375], [520, 380]],
    walkBounds: [30, 520], // harbor walkway before water
    charPos: { ntemis: { x: 320, y: 375 }, ajax: { x: 400, y: 377 }, clio: { x: 240, y: 377 } },
    objects: [
      { id:'crowd', x:0, y:200, w:300, h:150, label:'Κόσμος',
        verbs: { look:[{s:'',t:'Ολόκληρο το Γαλαξίδι μαζεμένο στο λιμάνι. Ψαράδες, ταβερνιάρηδες, γριές με μαύρα, παιδιά.'},{s:'ΚΛΕΙΩ',t:'Μπαμπά, είναι ΟΛΟΙ εδώ!'}],
                 talk:()=>{
                   const podium = scenes.new_era.objects.find(o => o.id === 'podium');
                   return podium.verbs.talk();
                 } }},
      { id:'podium', x:250, y:180, w:150, h:100, label:'Βήμα',
        verbs: {
          look:[{s:'',t:'Ένα απλό ξύλινο βήμα μπροστά στη θάλασσα. Πάνω του το κιβώτιο και το βιβλίο.'}],
          talk:()=>{
            if(state.flags.speech_done) return [{s:'',t:'Η ομιλία τελείωσε. Τώρα είναι η σειρά τους.'}];
            state.flags.speech_done=1;
            const lines = [
              {s:'ΝΤΕΜΗΣ',t:'Ο Βισβίκης δεν μας άφησε θησαυρό. Μας άφησε ερώτηση.'},
              {s:'ΝΤΕΜΗΣ',t:'Τι κάνεις όταν ο κόσμος αλλάζει κι εσύ αγαπάς αυτό που ήταν;'},
              {s:'ΝΤΕΜΗΣ',t:'Οι καπεταναίοι αρνήθηκαν τον ατμό. Δεν θα κάνουμε το ίδιο λάθος.'},
              {s:'ΝΤΕΜΗΣ',t:'Αλλά ξέρετε ποιο ήταν το πραγματικό τους μυστικό; Η αλληλεγγύη.'},
              {s:'ΝΤΕΜΗΣ',t:'Να βρούμε αυτά που μας ενώνουν. Όχι αυτά που μας χωρίζουν.'},
              {s:'ΝΤΕΜΗΣ',t:'Τα χρήματα θα γίνουν αρχή. Για να μπει το Γαλαξίδι στη νέα εποχή.'},
              {s:'ΝΤΕΜΗΣ',t:'Το Γαλαξίδι δεν χρειάζεται να γίνει σαν την Αθήνα. Χρειάζεται να γίνει περισσότερο Γαλαξίδι.'},
              {s:'',t:'Ο Ντέμης κοιτάζει τον Άθο στο πλήθος.'},
              {s:'ΝΤΕΜΗΣ',t:'Ναι, Άθο. Βρήκαμε το ατμόπλοιο.'},
              {s:'',t:'Σιωπή. Μετά, η γριά με τα μαύρα σηκώνεται πρώτη. Πλησιάζει το βιβλίο και υπογράφει.'},
              {s:'',t:'Ένας-ένας, οι Γαλαξειδιώτες ακολουθούν. Ψαράδες, ταβερνιάρηδες, νέοι, γέροι.'},
              {s:'ΑΙΑΣ',t:'Μπαμπά, πόσες υπογραφές;'},
              {s:'ΝΤΕΜΗΣ',t:'Εκατόν τρεις. Λείπει μία.'},
              {s:'',t:'Ο Αίας αρπάζει το στυλό και υπογράφει.'},
              {s:'ΑΙΑΣ',t:'Εκατόν τέσσερις. Σαν τότε.'},
              {s:'ΚΛΕΙΩ',t:'ΕΛΠΙΔΑ!'},
            ];
            showDlg(lines, () => {
              document.getElementById('ui-panel').classList.remove('on');
              document.getElementById('action-line').classList.remove('on');
              // Switch to epic festival music
              changeSceneMusic('_festival');
              cutscenes.festival.onComplete = () => {
                state.phase = 'epilogue';
                state.epiloguePage = 0;
                const el = document.getElementById('epilogue-screen');
                el.classList.add('show');
                showEpiloguePage();
              };
              startCutscene('festival');
            });
            return [];
          },
          use:()=>{ return [{s:'ΝΤΕΜΗΣ',t:'Πρέπει να μιλήσω πρώτα.'}]; },
        }},
      { id:'ledger_ne', x:280, y:200, w:100, h:60, label:'Βιβλίο Αλληλασφάλειας',
        verbs: {
          look: () => {
            if (!state.flags.speech_done) return [{s:'',t:'Δερματόδετο βιβλίο πάνω στο βήμα. Η σελίδα είναι ανοιχτή, περιμένει υπογραφές.'}];
            return [{s:'',t:'104 υπογραφές. Ο ίδιος αριθμός με το 1860. Η τελευταία — του Αίαντα.'},{s:'ΚΛΕΙΩ',t:'Σαν να μην πέρασε μια μέρα.'}];
          },
          open: () => {
            if (!state.flags.speech_done) return [{s:'',t:'Πρώτα η ομιλία. Μετά οι υπογραφές.'}];
            return [{s:'',t:'Σελίδες γεμάτες ονόματα. Ψαράδες, δάσκαλοι, ταβερνιάρηδες. Γαλαξειδιώτες.'},{s:'ΝΤΕΜΗΣ',t:'Ξέρεις τι σημαίνει αλληλασφάλεια; Ότι κανείς δεν βυθίζεται μόνος.'}];
          },
        }},
      { id:'akis_camera_ne', x:500, y:280, w:80, h:100, label:'Άκης με κάμερα',
        verbs: { look:[{s:'',t:'Ο Άκης με την κάμερά του. Καταγράφει τα πάντα.'}],
                 talk:[{s:'ΑΚΗΣ',t:'Τριάντα χρόνια κινηματογραφώ τόπους που σβήνουν. Αυτή τη φορά δεν γράφω ελεγείο. Γράφω αρχή.'}] }},
      { id:'sunset_ne', x:0, y:0, w:640, h:150, label:'Ηλιοβασίλεμα',
        verbs: { look:[{s:'',t:'Ο ήλιος βυθίζεται στον Κορινθιακό. Χρυσό φως λούζει τα πρόσωπα. Η θάλασσα θυμάται.'}] }},
    ],
    exits: [{ side:'left', target:'port', label:'← Λιμάνι' }],
    entry: [
      {s:'',t:'Εβδομάδες αργότερα. Το λιμάνι του Γαλαξειδίου στο ηλιοβασίλεμα. Ολόκληρη η πόλη είναι εδώ.'},
      {s:'ΚΛΕΙΩ',t:'Μπαμπά, είναι ΟΛΟΙ εδώ!'},
      {s:'ΑΙΑΣ',t:'Τι θα πεις;'},
      {s:'ΝΤΕΜΗΣ',t:'Την αλήθεια.'},
    ],
  },

};

// ════════════════════════════════════════════════════════════
// HOTSPOT RECALIBRATION — MI2-grade background alignment
// ════════════════════════════════════════════════════════════
// Background images are 1024x1024 but canvas is 640x400 (1.6:1).
// Cover-fit crops 192px from top & bottom, shifting visual positions.
// Recalibrate hotspot rectangles to match the cropped backgrounds.
(function recalibrateHotspots() {
  const cal = {
    exterior: {
      door:          { x:32,  y:108, w:55,  h:150 },
      bougainvillea: { x:125, y:2,   w:190, h:130 },
      flowerpots:    { x:25,  y:240, w:90,  h:50  },
      barrel:        { x:185, y:225, w:55,  h:60  },
      boats:         { x:350, y:99,  w:163, h:131 },
      sea:           { x:344, y:2,   w:296, h:55  },
    },
    terrace: {
      harbor:     { x:130, y:60,  w:290, h:110 },
      rooftops:   { x:28,  y:52,  w:135, h:92  },
      mountains:  { x:200, y:0,   w:350, h:42  },
      balustrade: { x:85,  y:252, w:385, h:38  },
      flowerpot:  { x:5,   y:210, w:72,  h:52  },
    },
    kitchen: {
      model_ships: { x:148, y:0,   w:245, h:55  },
      photo:       { x:452, y:5,   w:98,  h:108 },
      charts:      { x:220, y:28,  w:225, h:135 },
      desk_drawer: { x:185, y:305, w:260, h:55  },
      copper_pot:  { x:35,  y:245, w:55,  h:45  },
      fireplace:   { x:0,   y:255, w:95,  h:145 },
      instruments: { x:420, y:190, w:145, h:90  },
    },
    port: {
      boats_port:  { x:55,  y:80,  w:210, h:100 },
      bollards:    { x:330, y:235, w:50,  h:50  },
      nets:        { x:30,  y:345, w:105, h:55  },
      warehouses:  { x:0,   y:5,   w:160, h:110 },
      seagulls:    { x:250, y:0,   w:180, h:25  },
      elpida_dock: { x:370, y:30,  w:230, h:260 },
      stathis:     { x:55,  y:312, w:70,  h:80  },
      akis:        { x:125, y:315, w:60,  h:78  },
    },
    museum: {
      model_ship:    { x:18,  y:48,  w:182, h:152 },
      steamship:     { x:378, y:45,  w:182, h:152 },
      portraits_mus: { x:195, y:0,   w:185, h:82  },
      instruments:   { x:28,  y:340, w:152, h:58  },
      flags:         { x:95,  y:0,   w:410, h:28  },
      map_table:     { x:468, y:98,  w:142, h:162 },
      curator_npc:   { x:203, y:298, w:57,  h:82  },
    },
    liotrivi: {
      olive_press:  { x:8,   y:12,  w:142, h:178 },
      bar_counter:  { x:198, y:10,  w:182, h:118 },
      window_liot:  { x:415, y:2,   w:138, h:138 },
      photos_liot:  { x:145, y:0,   w:105, h:52  },
      stools:       { x:278, y:278, w:82,  h:58  },
      checkered_floor: { x:98, y:342, w:408, h:58 },
      athos_npc:    { x:485, y:280, w:55,  h:95  },
    },
    cave: {
      vote_inscription: { x:188, y:25,  w:205, h:102 },
      captain_marks:    { x:8,   y:68,  w:82,  h:72  },
      cave_water:       { x:128, y:282, w:255, h:78  },
      stalactites:      { x:45,  y:0,   w:510, h:42  },
      jade_stone:       { x:418, y:62,  w:82,  h:72  },
    },
    church: {
      fountain:         { x:220, y:230, w:160, h:120 },
      church_dome:      { x:200, y:0,   w:250, h:100 },
      bougainvillea_ch: { x:50,  y:30,  w:120, h:180 },
      benches:          { x:40,  y:290, w:110, h:60  },
      pots_church:      { x:370, y:290, w:80,  h:70  },
      church_door:      { x:250, y:70,  w:140, h:150 },
    },
    church_interior: {
      icons:       { x:348, y:10,  w:182, h:138 },
      iconostasis: { x:118, y:2,   w:282, h:198 },
      candles_ci:  { x:48,  y:168, w:102, h:118 },
      floor_tile:  { x:220, y:340, w:100, h:50  },
      papas_npc:   { x:450, y:280, w:80,  h:110 },
    },
    windmill: {
      telescope:     { x:422, y:218, w:82,  h:162 },
      panorama:      { x:0,   y:0,   w:640, h:52  },
      windmill_tower:{ x:468, y:88,  w:122, h:128 },
      wildflowers:   { x:148, y:278, w:202, h:78  },
      stone_path_wm: { x:298, y:348, w:202, h:52  },
      giannis_npc:   { x:125, y:309, w:75,  h:85  },
    },
    boat: {
      nameplate:       { x:48,  y:348, w:122, h:42  },
      chapel:          { x:25,  y:12,  w:155, h:148 },
      sunset_sea:      { x:195, y:0,   w:405, h:78  },
      rope:            { x:348, y:278, w:82,  h:62  },
      lifebuoy:        { x:458, y:322, w:62,  h:62  },
      galaxidi_view:   { x:398, y:8,   w:202, h:98  },
      chrysostomos_npc:{ x:75,  y:280, w:75,  h:110 },
    },
    graveyard: {
      visvikis_grave: { x:388, y:248, w:152, h:88  },
      headstones:     { x:48,  y:215, w:152, h:122 },
      cypress:        { x:0,   y:0,   w:72,  h:302 },
      angel_statue:   { x:558, y:152, w:72,  h:148 },
      poppies_gr:     { x:198, y:352, w:182, h:48  },
      sea_view_gr:    { x:218, y:0,   w:222, h:88  },
      moon:           { x:168, y:0,   w:102, h:62  },
      candles:        { x:348, y:342, w:82,  h:38  },
      path_stones_gr: { x:148, y:372, w:202, h:28  },
      ghost_npc:      { x:430, y:232, w:65,  h:120 },
    },
    treasure: {
      stone_cross:  { x:40,  y:230, w:100, h:120 },
      panorama:     { x:60,  y:10,  w:360, h:200 },
      chapel_ext:   { x:460, y:40,  w:180, h:300 },
      dig_spot:     { x:170, y:340, w:180, h:45  },
    },
    new_era: {
      crowd:          { x:0,   y:180, w:280, h:160 },
      podium:         { x:30,  y:230, w:130, h:120 },
      ledger_ne:      { x:40,  y:240, w:100, h:60  },
      akis_camera_ne: { x:480, y:200, w:110, h:140 },
      sunset_ne:      { x:250, y:0,   w:390, h:120 },
    },
  };
  for (const [sceneId, objects] of Object.entries(cal)) {
    const sc = scenes[sceneId];
    if (!sc) continue;
    for (const [objId, coords] of Object.entries(objects)) {
      const obj = sc.objects.find(o => o.id === objId);
      if (obj) Object.assign(obj, coords);
    }
  }
})();

// ════════════════════════════════════════════════════════════
// FAST-TRAVEL MAP DATA
// ════════════════════════════════════════════════════════════
// Galaxidi: North shore of Corinthian Gulf, harbor crescent facing south
// Layout: sea at bottom, town center-top, hills above
const MAP_LOCATIONS = [
  { id:'exterior', sceneIds:['exterior','terrace','kitchen'], label:'Το Σπίτι', x:175, y:235 },
  { id:'port',     sceneIds:['port'],                        label:'Το Λιμάνι', x:320, y:300 },
  { id:'museum',   sceneIds:['museum'],                      label:'Μουσείο',   x:270, y:255 },
  { id:'liotrivi', sceneIds:['liotrivi'],                    label:'Λιοτρίβι',  x:199, y:270 },
  { id:'church',   sceneIds:['church','church_interior'],    label:'Αγ. Νικόλαος', x:245, y:175 },
  { id:'cave',     sceneIds:['cave'],                        label:'Σπήλαιο',   x:390, y:235 },
  { id:'windmill', sceneIds:['windmill'],                    label:'Ο Μύλος',    x:199, y:150 },
  { id:'graveyard',sceneIds:['graveyard'],                   label:'Νεκροταφείο',x:280, y:150 },
  { id:'boat',     sceneIds:['boat'],                        label:'Ελπίδα',     x:220, y:330 },
  { id:'treasure', sceneIds:['treasure','new_era'],          label:'Αγ. Γεώργιος', x:430, y:145 },
];

// Path connections for drawing roads on map
const MAP_PATHS = [
  ['exterior','port'], ['exterior','liotrivi'], ['port','museum'],
  ['museum','liotrivi'], ['liotrivi','church'], ['church','cave'],
  ['exterior','windmill'], ['windmill','graveyard'],
];

// ════════════════════════════════════════════════════════════
// HELP SYSTEM DATA
// ════════════════════════════════════════════════════════════
const HELP_GENERAL = [
  'ΡΗΜΑΤΑ: 1=Κοίταξε 2=Μίλησε 3=Άνοιξε 4=Χρησιμοποίησε',
  'ΠΛΗΚΤΡΑ: S=Αποθήκευση M=Χάρτης Q=Πρόοδος H=Βοήθεια',
  'Κλικ σε αντικείμενα για αλληλεπίδραση.',
  'Κλικ στο έδαφος για βάδισμα.',
  'Βέλη στα άκρα → νέα τοποθεσία.',
  'Space/Enter → προχώρα τον διάλογο.',
];
const HELP_HINTS = {
  exterior: 'Κοιτάξτε την πόρτα, το βαρέλι, τις γλάστρες. Αριστερά → Λιμάνι. Δεξιά → Βεράντα.',
  terrace: 'Κοιτάξτε τη θέα: λιμάνι, σκεπές, βουνά. Δεξιά → Μύλος.',
  kitchen: 'Κοιτάξτε τη φωτογραφία. Ψάξτε το χάλκινο δοχείο στο τζάκι. Ανοίξτε το συρτάρι.',
  port: 'Μιλήστε στον Άκη και τον Στάθη. Κοιτάξτε το πλοίο Ελπίδα στην προβλήτα. Αριστερά → Μουσείο.',
  museum: 'Μιλήστε στον επιμελητή. Κοιτάξτε τα μοντέλα πλοίων και τον χάρτη. Αριστερά → Λιοτρίβι.',
  liotrivi: 'Μιλήστε στον Άθο. Κοιτάξτε τις φωτογραφίες και το ελαιοτριβείο. Αριστερά → Εκκλησία.',
  cave: 'Κοιτάξτε τις χαράξεις στους τοίχους. Κοιτάξτε ψηλά στη ρωγμή! Δεξιά → Εκκλησία.',
  church: 'Κοιτάξτε το σιντριβάνι. Ανοίξτε την πόρτα της εκκλησίας για να μπείτε μέσα.',
  church_interior: 'Χρησιμοποιήστε τα κεριά πρώτα. Μετά ψάξτε το πάτωμα. Μιλήστε στον Παπά Νικόλα.',
  windmill: 'Μιλήστε στον Γιάννη — θα σας δώσει κάτι. Κοιτάξτε από το τηλεσκόπιο. Δεξιά → Νεκροταφείο.',
  graveyard: 'Βρείτε τον τάφο του Βισβίκη. Χρησιμοποιήστε ό,τι βρήκατε στο σπήλαιο πάνω του.',
  boat: 'Κοιτάξτε γύρω σας — τα σχοινιά, το σωσίβιο, τη θέα. Δεξιά → Νησί.',
  treasure: 'Ανοίξτε το κιβώτιο. Μετά κοιτάξτε το γράμμα και διαβάστε το. Δεξιά → Γαλαξίδι.',
  new_era: 'Μιλήστε στο βήμα για να ξεκινήσει η ομιλία. Κοιτάξτε τον Άκη με την κάμερα.',
};

// ════════════════════════════════════════════════════════════
// INTRO PAGES
// ════════════════════════════════════════════════════════════
const introPages = [
  'Γαλαξίδι.\nΤέλη Σεπτεμβρίου, 2026.',
  'Ένα μικρό λιμάνι\nστον Κορινθιακό κόλπο.\n\nΕκεί που κάποτε ξεκινούσαν\nτα πιο τολμηρά καράβια\nτης Ελλάδας.',
  'Ο Ντέμης έφτασε\nμε τα δυο του παιδιά\nγια ένα ήσυχο\nΣαββατοκύριακο.\n\nΤουλάχιστον,\nαυτό νόμιζε.',
];

const epiloguePages = [
  'Ο Καπετάν Βισβίκης\nταξίδεψε στην Ανατολή,\nγύρισε πλούσιος,\nκι έκρυψε τον θησαυρό του\nγια κάποιον που θα αγαπούσε\nτο Γαλαξίδι αρκετά\nγια να τον βρει.',
  'Εκατόν είκοσι χρόνια αργότερα,\nτρεις ταξιδιώτες τον βρήκαν.\n\nΚαι έκαναν αυτό\nπου ο Καπετάνιος ονειρευόταν.',
  'Να βρούμε αυτά που μας ενώνουν.\nΌχι αυτά που μας χωρίζουν.\n\nΚράτα την αλληλεγγύη.\nΆλλαξε το πλοίο.',
  'Η θάλασσα θυμάται.\nΚι εμείς τώρα,\nαλλάζουμε μαζί της.',
  'ΤΟ ΜΥΣΤΗΡΙΟ ΤΟΥ ΓΑΛΑΞΕΙΔΙΟΥ\n\n104 υπογραφές.\nΤότε και τώρα.\n\n\nΓια τον Αίαντα και την Κλειώ.',
];

// ════════════════════════════════════════════════════════════
// STAR WARS STYLE TEXT CRAWL
// ════════════════════════════════════════════════════════════
const CRAWL_LINES = [
  'ΓΑΛΑΞΙΔΙ — Η ΘΑΛΑΣΣΑ ΘΥΜΑΤΑΙ',
  '',
  '',
  'Εκεί που ο Κορινθιακός',
  'φιλάει τα βουνά,',
  'ένα μικρό λιμάνι κάποτε',
  'γέμιζε τον κόσμο με πανιά.',
  '',
  'Τριακόσια καράβια.',
  'Έξι χιλιάδες ψυχές.',
  'Ο μεγαλύτερος στόλος της Ελλάδας.',
  '',
  'Οι καπεταναίοι ταξίδευαν',
  'ως τη Μαύρη Θάλασσα,',
  'την Αλεξάνδρεια, τη Σμύρνη —',
  'και πάντα γύριζαν σπίτι.',
  '',
  '',
  'Μέχρι που ήρθε η ψηφοφορία.',
  '',
  '«Να φτιάξουμε ατμόπλοια;»',
  '',
  'Εννέα είπαν ΟΧΙ.',
  'Τρεις είπαν ΝΑΙ.',
  '',
  '',
  'Ένας από τους τρεις',
  'ήταν ο Καπετάν Βισβίκης.',
  '',
  'Πριν φύγει, έκρυψε κάτι',
  'για όποιον αγαπήσει',
  'το Γαλαξίδι αρκετά.',
  '',
  '«Η θάλασσα θυμάται.»',
  '',
  '',
  '· · ·',
  '',
  '',
  'Σεπτέμβριος 2026.',
  '',
  'Ένας πατέρας και δυο παιδιά',
  'φτάνουν στο Γαλαξίδι',
  'για ένα ήσυχο Σαββατοκύριακο.',
];

const CRAWL_LINE_SPACING = 24;
const CRAWL_VISIBLE_DEPTH = 380;
const CRAWL_SPEED = 15; // world units per second

// ════════════════════════════════════════════════════════════
// CUTSCENE ENGINE
// ════════════════════════════════════════════════════════════

const cutscenes = {
  arrival: {
    frames: [
      {
        duration: 7,
        draw: drawArrivalRoad,
        dialogue: [
          { s: 'ΑΙΑΣ', t: 'Πόσο ακόμα, μπαμπά;', at: 1.2 },
          { s: 'ΝΤΕΜΗΣ', t: 'Λίγο ακόμα. Σχεδόν φτάσαμε.', at: 3.0 },
        ],
      },
      {
        duration: 6,
        draw: drawArrivalDescent,
        dialogue: [
          { s: 'ΚΛΕΙΩ', t: 'Βλέπω τη θάλασσα! Κοίτα, καράβια!', at: 0.8 },
          { s: 'ΑΙΑΣ', t: 'Θα κολυμπήσουμε;', at: 2.8 },
          { s: 'ΝΤΕΜΗΣ', t: 'Πρώτα θα βρούμε το σπίτι του παππού.', at: 4.2 },
        ],
      },
      {
        duration: 5,
        draw: drawArrivalHarbor,
        dialogue: [
          { s: 'ΝΤΕΜΗΣ', t: 'Φτάσαμε. Γαλαξίδι.', at: 1.5 },
          { s: 'ΚΛΕΙΩ', t: 'Μυρίζει αλάτι και πεύκο!', at: 3.2 },
        ],
      },
    ],
    onComplete: () => {
      document.getElementById('ui-panel').classList.add('on');
      document.getElementById('action-line').classList.add('on');
      state.phase = 'playing';
      // Crossfade title music out, scene music in
      currentMusicSrc = sceneMusic['exterior'];
      bgm.src = currentMusicSrc;
      bgm.volume = 0;
      bgm.play().catch(() => {});
      const fadeDur = 2000;
      const fadeStart = performance.now();
      const fadeStep = () => {
        const t = Math.min(1, (performance.now() - fadeStart) / fadeDur);
        const ease = t < 0.5 ? 4*t*t*t : 1-Math.pow(-2*t+2,3)/2;
        titleMusic.volume = Math.max(0, 0.4 * (1 - ease));
        bgm.volume = 0.25 * ease;
        if (t < 1) {
          requestAnimationFrame(fadeStep);
        } else {
          titleMusic.pause();
          titleMusic.volume = 0.7;
        }
      };
      requestAnimationFrame(fadeStep);
      startScene('exterior');
    },
  },

  // ── THE LETTER — Quest hook (triggered after opening the drawer)
  letter: {
    frames: [
      {
        duration: 14,
        draw: drawLetterSingle,
        dialogue: [
          { s: 'ΝΤΕΜΗΣ', t: '«...εγώ, Καπετάν Λουκάς Βισβίκης, αφήνω πίσω μου τον θησαυρό μιας ζωής στη θάλασσα.»', at: 1.0 },
          { s: 'ΝΤΕΜΗΣ', t: '«Βρες το πράσινο πέτρωμα, εκεί που η γη μιλάει — εκεί που τα βράχια γίνονται σπήλαιο.»', at: 4.5 },
          { s: 'ΑΙΑΣ', t: 'Είναι νεκρός εδώ και εκατό χρόνια!', at: 8.0 },
          { s: 'ΚΛΕΙΩ', t: 'Στο νεκροταφείο, βλάκα. Λογικό είναι.', at: 9.5 },
          { s: 'ΝΤΕΜΗΣ', t: 'Κάποιος στην πόλη θα ξέρει για τον Βισβίκη. Πάμε στο λιμάνι.', at: 11.5 },
        ],
      },
    ],
    onComplete: () => {
      state.phase = 'playing';
    },
  },

  // ── TELESCOPE — Clio spots Agios Georgios island from the windmill
  telescope_island: {
    frames: [
      {
        duration: 8,
        draw: drawTelescopeIsland,
        dialogue: [
          { s: 'ΚΛΕΙΩ', t: 'Κοίτα... ένα νησάκι με εκκλησάκι! Στη μέση του κόλπου!', at: 1.0 },
          { s: 'ΑΙΑΣ', t: 'Πώς φτάνεις εκεί; Με βάρκα;', at: 3.5 },
          { s: 'ΝΤΕΜΗΣ', t: 'Ο Άγιος Γεώργιος. Λένε ότι οι ψαράδες πάνε εκεί πριν κάθε ταξίδι.', at: 5.5 },
        ],
      },
    ],
    onComplete: () => {
      state.phase = 'playing';
      document.getElementById('ui-panel').classList.add('on');
      document.getElementById('action-line').classList.add('on');
    },
  },

  // ── THE CAVE — Entering Karkaros (triggered at cave entrance)
  cave_enter: {
    frames: [
      {
        duration: 8,
        draw: drawCaveEntrance,
        dialogue: [
          { s: 'ΑΙΑΣ', t: 'Σκοτεινά... Μπαμπά, κράτα ψηλά το φανάρι!', at: 1.0 },
          { s: 'ΚΛΕΙΩ', t: 'Κοίτα στον τοίχο! Ονόματα πλοίων!', at: 3.2 },
          { s: 'ΝΤΕΜΗΣ', t: 'Οι καπεταναίοι σημάδευαν το πέρασμά τους εδώ.', at: 5.5 },
        ],
      },
    ],
    onComplete: () => {
      state.phase = 'playing';
    },
  },

  // (Ghost cutscene removed — ghost moment handled by startGhostSequence() with in-game choreography)

  // ── THE CHURCH — Clio finds the floor tile (triggered after candle scene in church)
  church_tile: {
    frames: [
      {
        duration: 7,
        draw: drawChurchCandle,
        dialogue: [
          { s: 'ΚΛΕΙΩ', t: 'Θέλω να ανάψω ένα κερί. Για τους καπεταναίους.', at: 1.2 },
          { s: 'ΠΑΠΑΣ', t: 'Αυτό το παιδί... Ο Βισβίκης θα χαμογελούσε.', at: 3.5 },
          { s: 'ΝΤΕΜΗΣ', t: 'Άναψέ το, κόρη μου.', at: 5.5 },
        ],
      },
      {
        duration: 8,
        draw: drawChurchTile,
        dialogue: [
          { s: 'ΚΛΕΙΩ', t: 'Μπαμπά! Κοίτα! Γράμματα στο πάτωμα! «Λ.Β.»!', at: 1.5 },
          { s: 'ΑΙΑΣ', t: 'Λάμβδα Βήτα... Λουκάς Βισβίκης!', at: 3.5 },
          { s: 'ΝΤΕΜΗΣ', t: 'Ένας χάρτης... Δείχνει τον Άγιο Γεώργιο. Με ένα Χ.', at: 5.8 },
        ],
      },
    ],
    onComplete: () => {
      state.phase = 'playing';
    },
  },

  // ── THE CROSSING — Dawn on the Ελπίδα (triggered when boarding the boat)
  crossing: {
    frames: [
      {
        duration: 9,
        draw: drawCrossingWide,
        dialogue: [
          { s: 'ΧΡΥΣΟΣΤΟΜΟΣ', t: 'Δεν πίστευα ότι θα ζούσα να το δω. Η Ελπίδα ξαναταξιδεύει.', at: 1.5 },
          { s: 'ΑΙΑΣ', t: 'Αυτό είναι το πλοίο του Βισβίκη; Είναι πανέμορφο!', at: 4.5 },
          { s: 'ΧΡΥΣΟΣΤΟΜΟΣ', t: 'Ήξερα τον πατέρα σου, Ντέμη. Θα ήταν περήφανος.', at: 7.0 },
        ],
      },
      {
        duration: 9,
        draw: drawCrossingClose,
        dialogue: [
          { s: 'ΑΙΑΣ', t: 'Βλέπω το νησάκι! Με το εκκλησάκι!', at: 1.5 },
          { s: 'ΧΡΥΣΟΣΤΟΜΟΣ', t: 'Η θάλασσα αλλάζει κι εσύ αλλάζεις μαζί της. Αλλιώς πνίγεσαι.', at: 4.0 },
          { s: 'ΝΤΕΜΗΣ', t: 'Σχεδόν φτάσαμε. Κάτω από τον σταυρό, πέντε βήματα.', at: 7.0 },
        ],
      },
    ],
    onComplete: () => {
      state.phase = 'playing';
    },
  },

  // ── SAILING BACK — Return from boat to Galaxidi (triggered when exiting boat toward port)
  sail_back: {
    frames: [
      {
        duration: 8,
        draw: drawSailBackSunset,
        dialogue: [
          { s: 'ΧΡΥΣΟΣΤΟΜΟΣ', t: 'Ώρα να γυρίσουμε. Η Ελπίδα ξέρει τον δρόμο.', at: 1.5 },
          { s: 'ΚΛΕΙΩ', t: 'Ήδη τελειώνει; Δεν θέλω να φύγουμε...', at: 4.0 },
          { s: 'ΑΙΑΣ', t: 'Κοίτα πίσω — το νησάκι μικραίνει!', at: 6.0 },
        ],
      },
      {
        duration: 7,
        draw: drawSailBackGalaxidi,
        dialogue: [
          { s: 'ΝΤΕΜΗΣ', t: 'Να, βλέπετε; Τα φώτα του Γαλαξειδίου.', at: 1.5 },
          { s: 'ΧΡΥΣΟΣΤΟΜΟΣ', t: 'Πάντα γυρνάς. Αυτό είναι το μυστικό.', at: 4.0 },
        ],
      },
    ],
    onComplete: () => {
      state.phase = 'playing';
      document.getElementById('ui-panel').classList.add('on');
      document.getElementById('action-line').classList.add('on');
      startScene('port');
    },
  },

  // ── THE TREASURE — Expanded 5-frame reveal (triggered when opening chest)
  treasure: {
    frames: [
      // Frame 1: Chest opens — golden light, let the image speak
      {
        duration: 7,
        draw: drawTreasureGlow,
        dialogue: [
          { s: '', t: 'Το καπάκι ανοίγει. Χρυσό φως πλημμυρίζει τον βράχο.', at: 2.0 },
        ],
      },
      // Frame 2: Coins and necklace — kids react
      {
        duration: 8,
        draw: drawTreasureCoins,
        dialogue: [
          { s: 'ΑΙΑΣ', t: 'Χρυσάφι! Βλέπεις, Κλειώ; Χρυσάφι παντού!', at: 1.5 },
          { s: 'ΚΛΕΙΩ', t: 'Ένα κολιέ! Πράσινο σαν το πέτρωμα... Μπορώ να το φορέσω;', at: 5.0 },
        ],
      },
      // Frame 3: The ledger — 104 signatures
      {
        duration: 8,
        draw: drawTreasureLedger,
        dialogue: [
          { s: 'ΝΤΕΜΗΣ', t: 'Η αλληλασφάλεια... Εκατόν τέσσερις ψυχές. 1860.', at: 1.5 },
          { s: 'ΑΙΑΣ', t: 'Εκατόν τέσσερις. Σαν ομάδα.', at: 5.5 },
        ],
      },
      // Frame 4: The letter — Ntemis breaks the wax seal
      {
        duration: 9,
        draw: drawTreasureLetterLift,
        dialogue: [
          { s: '', t: 'Στον πάτο, κάτω από τα νομίσματα... ένα γράμμα. Σφραγισμένο με κερί σαν να ήταν χθες.', at: 1.0 },
          { s: '', t: 'Ο Ντέμης σπάει αργά τη σφραγίδα. Τα χέρια του τρέμουν.', at: 5.5 },
        ],
      },
      // Frame 5: Family reads together — the climax
      {
        duration: 10,
        draw: drawTreasureFamilyRead,
        dialogue: [
          { s: 'ΝΤΕΜΗΣ', t: '«Κράτα την αλληλεγγύη. Άλλαξε το πλοίο.»', at: 1.5 },
          { s: 'ΑΙΑΣ', t: 'Τι εννοεί "άλλαξε το πλοίο";', at: 4.5 },
          { s: 'ΝΤΕΜΗΣ', t: 'Ότι δεν αρκεί να είσαι ο καλύτερος. Πρέπει να αλλάζεις.', at: 6.5 },
          { s: 'ΚΛΕΙΩ', t: 'Ο Καπετάνιος... ήξερε.', at: 9.0 },
        ],
      },
    ],
    onComplete: () => {
      state.phase = 'playing';
    },
  },

  // ── FESTIVAL — Epic celebration cutscene (5 frames, ~63 seconds)
  festival: {
    frames: [
      { duration: 11, draw: drawFestivalCelebration, dialogue: [
        { s: '', t: 'Η πλατεία εκρήγνυται. Χειροκροτήματα, αγκαλιές, δάκρυα χαράς.', at: 1.0 },
        { s: 'ΑΙΑΣ', t: 'Αυτό είναι! Αυτά μας ενώνουν! Όχι αυτά που μας χωρίζουν!', at: 4.0 },
        { s: '', t: 'Η μελωδία των ναυτικών ξαναρχίζει. Τώρα δεν είναι αποχαιρετισμός. Είναι αρχή.', at: 7.5 },
      ]},
      { duration: 12, draw: drawFestivalFireworks, dialogue: [
        { s: '', t: 'Βεγγαλικά φωτίζουν τον Κορινθιακό. Σκάφη με φαναράκια — μια ρεγκάτα φωτός.', at: 1.5 },
        { s: 'ΑΙΑΣ', t: 'Κοίτα! Η Ελπίδα μπροστά! Με σημαίες!', at: 5.0 },
        { s: '', t: 'Τριακόσια καράβια κάποτε. Απόψε, η θάλασσα θυμάται.', at: 8.5 },
      ]},
      { duration: 13, draw: drawFestivalGhost, dialogue: [
        { s: '', t: 'Κι εκεί, στην πλώρη της Ελπίδας... ένα φως.', at: 1.5 },
        { s: 'ΚΛΕΙΩ', t: 'Μπαμπά... ο Καπετάνιος. Τον βλέπεις;', at: 4.0 },
        { s: '', t: 'Ο Βισβίκης, διάφανος κι ήρεμος. Χαμογελάει. Δεν περιμένει πια.', at: 7.0 },
        { s: 'ΝΤΕΜΗΣ', t: 'Καλό ταξίδι, Καπετάνιε.', at: 10.5 },
      ]},
      { duration: 13, draw: drawFestivalLantern, dialogue: [
        { s: 'ΚΛΕΙΩ', t: 'Κάτι πρέπει να στείλουμε κι εμείς.', at: 1.5 },
        { s: '', t: 'Η Κλειώ βάζει ένα φαναράκι χαρτί στο νερό. Η φλόγα αντανακλά στη θάλασσα.', at: 4.0 },
        { s: '', t: 'Πλέει αργά, προς την Ελπίδα. Η σκιά του Βισβίκη γνέφει. Κι εξαφανίζεται.', at: 7.5 },
        { s: 'ΚΛΕΙΩ', t: 'Καληνύχτα, Καπετάνιε.', at: 11.0 },
      ]},
      { duration: 14, draw: drawFestivalPanorama, dialogue: [
        { s: '', t: 'Ολόκληρο το Γαλαξίδι ζωντανό. Μουσική, γέλιο, φως.', at: 1.5 },
        { s: '', t: 'Να βρούμε αυτά που μας ενώνουν. Όχι αυτά που μας χωρίζουν.', at: 4.5 },
        { s: 'ΑΙΑΣ', t: 'Μπαμπά; Ξέρω τι θα γίνω μεγάλος.', at: 8.0 },
        { s: 'ΝΤΕΜΗΣ', t: 'Τι;', at: 10.0 },
        { s: 'ΑΙΑΣ', t: 'Καπετάνιος.', at: 11.5 },
      ]},
    ],
    onComplete: () => { state.phase = 'playing'; },
  },
  // ── EPILOGUE (legacy)
  epilogue: {
    frames: [
      { duration: 8, draw: drawEpilogueHarbor, dialogue: [
        { s: 'ΝΤΕΜΗΣ', t: 'Κράτα την αλληλεγγύη. Άλλαξε το πλοίο.', at: 2.0 },
      ]},
    ],
    onComplete: () => { state.phase = 'playing'; },
  },
};

function startCutscene(id) {
  const cs = cutscenes[id];
  if (!cs) { state.phase = 'playing'; startScene('exterior'); return; }
  state.cutscene.active = true;
  state.cutscene.id = id;
  state.cutscene.frameIdx = 0;
  state.cutscene.frameTime = 0;
  state.cutscene.totalTime = 0;
  state.cutscene.fadeAlpha = 1;
  state.cutscene.transitioning = false;
  state.cutscene.dlgText = '';
  state.cutscene.dlgDisplayed = '';
  state.cutscene.dlgSpeaker = '';
  state.cutscene.dlgCharIdx = 0;
  state.cutscene.dlgTimer = 0;
  state.cutscene.dlgTriggered = new Set();
  state.cutscene.skipHover = false;
  state.phase = 'cutscene';
  document.getElementById('ui-panel').classList.remove('on');
  document.getElementById('action-line').classList.remove('on');
}

function updateCutscene(dt) {
  if (!state.cutscene.active) return;
  const cs = cutscenes[state.cutscene.id];
  if (!cs) return;

  // Handle fade transitions between frames
  if (state.cutscene.transitioning) {
    state.cutscene.fadeAlpha = Math.min(1, state.cutscene.fadeAlpha + dt * 2.0);
    if (state.cutscene.fadeAlpha >= 1) {
      if (state.cutscene.frameIdx >= cs.frames.length - 1) {
        state.cutscene.active = false;
        stopVoice();
        cs.onComplete();
        return;
      }
      state.cutscene.frameIdx++;
      state.cutscene.frameTime = 0;
      state.cutscene.dlgText = '';
      state.cutscene.dlgDisplayed = '';
      state.cutscene.dlgSpeaker = '';
      state.cutscene.transitioning = false;
      stopVoice();
    }
    return;
  }

  const frame = cs.frames[state.cutscene.frameIdx];
  if (!frame) return;

  state.cutscene.frameTime += dt;
  state.cutscene.totalTime += dt;

  // Fade in at start of each frame
  if (state.cutscene.fadeAlpha > 0) {
    state.cutscene.fadeAlpha = Math.max(0, state.cutscene.fadeAlpha - dt * 1.5);
  }

  // Trigger dialogue at timestamps
  if (frame.dialogue) {
    for (let i = 0; i < frame.dialogue.length; i++) {
      const key = `${state.cutscene.frameIdx}-${i}`;
      if (!state.cutscene.dlgTriggered.has(key) && state.cutscene.frameTime >= frame.dialogue[i].at) {
        state.cutscene.dlgTriggered.add(key);
        state.cutscene.dlgSpeaker = frame.dialogue[i].s;
        state.cutscene.dlgText = frame.dialogue[i].t;
        state.cutscene.dlgDisplayed = '';
        state.cutscene.dlgCharIdx = 0;
        state.cutscene.dlgTimer = 0;
        playVoice(frame.dialogue[i].t);
      }
    }
  }

  // Typewriter
  if (state.cutscene.dlgCharIdx < state.cutscene.dlgText.length) {
    state.cutscene.dlgTimer += dt;
    while (state.cutscene.dlgTimer >= 0.03 && state.cutscene.dlgCharIdx < state.cutscene.dlgText.length) {
      state.cutscene.dlgDisplayed += state.cutscene.dlgText[state.cutscene.dlgCharIdx];
      state.cutscene.dlgCharIdx++;
      state.cutscene.dlgTimer -= 0.03;
    }
  }

  // Auto-advance when frame duration reached
  if (state.cutscene.frameTime >= frame.duration) {
    advanceCutsceneFrame();
  }
}

function advanceCutsceneFrame() {
  if (state.cutscene.transitioning) return;
  state.cutscene.transitioning = true;
}

function skipCutscene() {
  if (!state.cutscene.active) return;
  const cs = cutscenes[state.cutscene.id];
  state.cutscene.active = false;
  state.cutscene.fadeAlpha = 0;
  cs.onComplete();
}

// Debug: play all cutscenes back to back (call from console: playAllCutscenes())
function playAllCutscenes() {
  const ids = ['arrival','letter','cave_enter','church_tile','crossing','sail_back','treasure','epilogue'].filter(id => {
    if (!cutscenes[id]) {
      console.warn('playAllCutscenes: unknown cutscene "' + id + '" skipped');
      return false;
    }
    return true;
  });
  let i = 0;
  const savedCompletes = {};
  ids.forEach(id => { savedCompletes[id] = cutscenes[id].onComplete; });
  function playNext() {
    if (i >= ids.length) {
      // Restore original onComplete handlers
      ids.forEach(id => { cutscenes[id].onComplete = savedCompletes[id]; });
      state.phase = 'playing';
      startScene('exterior');
      return;
    }
    const id = ids[i++];
    cutscenes[id].onComplete = () => { playNext(); };
    startCutscene(id);
  }
  document.getElementById('ui-panel').classList.remove('on');
  document.getElementById('action-line').classList.remove('on');
  playNext();
}

function renderCutscene() {
  if (!state.cutscene.active) return;
  const cs = cutscenes[state.cutscene.id];
  if (!cs) return;
  const frame = cs.frames[state.cutscene.frameIdx];
  if (!frame) return;

  const t = state.cutscene.frameTime;
  const p = Math.min(1, t / frame.duration);

  ctx.fillStyle = '#0a0812';
  ctx.fillRect(0, 0, GW, GH);

  // Draw scene content
  ctx.save();
  frame.draw(t, p, state.tick);
  ctx.restore();

  // Cinematic vignette
  ctx.save();
  const vig = ctx.createRadialGradient(GW / 2, GH / 2, GW * 0.28, GW / 2, GH / 2, GW * 0.72);
  vig.addColorStop(0, 'rgba(0,0,0,0)');
  vig.addColorStop(1, 'rgba(0,0,0,0.35)');
  ctx.fillStyle = vig;
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();

  // Letterbox bars
  const barH = 38;
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, GW, barH);
  ctx.fillRect(0, GH - barH, GW, barH);

  // Film grain
  ctx.save();
  ctx.globalAlpha = 0.02;
  for (let i = 0; i < 40; i++) {
    ctx.fillStyle = Math.random() > 0.5 ? '#fff' : '#000';
    ctx.fillRect(Math.random() * GW | 0, Math.random() * GH | 0, 1, 1);
  }
  ctx.restore();

  // Dialogue subtitles
  if (state.cutscene.dlgDisplayed) {
    const dlgY = GH - barH;
    ctx.save();
    ctx.globalAlpha = 0.6;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, dlgY - 42, GW, 42);
    ctx.globalAlpha = 1;
    if (state.cutscene.dlgSpeaker) {
      ctx.font = '6px "Press Start 2P", monospace';
      ctx.fillStyle = '#D4A03C';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.shadowColor = '#000';
      ctx.shadowBlur = 3;
      ctx.fillText(state.cutscene.dlgSpeaker, GW / 2, dlgY - 26);
    }
    ctx.font = '8px "Press Start 2P", monospace';
    ctx.fillStyle = '#e8dcc8';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.shadowColor = '#000';
    ctx.shadowBlur = 4;
    ctx.fillText(state.cutscene.dlgDisplayed, GW / 2, dlgY - 6);
    ctx.restore();
  }

  // Skip button (top-right)
  const skipW = 80, skipH = 18, skipX = GW - skipW - 8, skipY = 8;
  ctx.save();
  ctx.globalAlpha = state.cutscene.skipHover ? 0.85 : 0.5;
  ctx.fillStyle = '#1a1a2e';
  ctx.strokeStyle = '#D4A03C';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.roundRect(skipX, skipY, skipW, skipH, 4);
  ctx.fill();
  ctx.stroke();
  ctx.globalAlpha = state.cutscene.skipHover ? 1 : 0.7;
  ctx.font = '6px "Press Start 2P", monospace';
  ctx.fillStyle = '#D4A03C';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('Παράλειψη ▸▸', skipX + skipW / 2, skipY + skipH / 2 + 1);
  ctx.restore();

  // Fade overlay
  if (state.cutscene.fadeAlpha > 0) {
    ctx.save();
    ctx.globalAlpha = state.cutscene.fadeAlpha;
    ctx.fillStyle = '#0a0812';
    ctx.fillRect(0, 0, GW, GH);
    ctx.restore();
  }
}

// ═══════════════════════════════════════════════════════════
// CUTSCENE DRAWING HELPERS
// ═══════════════════════════════════════════════════════════

function drawPixelCar(x, y, scale, dir) {
  ctx.save();
  ctx.translate(x, y);
  ctx.scale(scale * dir, scale);

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.beginPath();
  ctx.ellipse(0, 6, 26, 4, 0, 0, Math.PI * 2);
  ctx.fill();

  // Lower body (dark blue Peugeot hatchback)
  ctx.fillStyle = '#2a3a5a';
  ctx.fillRect(-28, -8, 56, 14);
  // Cabin
  ctx.fillStyle = '#2e3e62';
  ctx.fillRect(-18, -20, 36, 14);
  // Roof
  ctx.fillStyle = '#2a3a5a';
  ctx.fillRect(-14, -22, 28, 4);

  // Window frame
  ctx.fillStyle = '#1e2e4a';
  ctx.fillRect(-17, -19, 34, 12);
  // Glass
  ctx.fillStyle = '#7aa8c8';
  ctx.fillRect(-15, -18, 12, 10); // rear
  ctx.fillRect(-1, -18, 14, 10);  // front
  ctx.fillStyle = '#8ab8d8';
  ctx.fillRect(13, -16, 3, 7);    // windshield angle

  // Character silhouettes
  ctx.fillStyle = '#1a2838';
  ctx.fillRect(4, -17, 6, 5);   // driver (Ntemis)
  ctx.fillRect(2, -12, 9, 3);
  ctx.fillRect(-13, -17, 5, 5); // Ajax
  ctx.fillRect(-14, -12, 7, 3);
  ctx.fillRect(-6, -17, 4, 4);  // Clio
  ctx.fillRect(-7, -13, 6, 2);

  // Headlights
  ctx.fillStyle = '#FFE8A0';
  ctx.fillRect(27, -5, 2, 3);
  ctx.fillRect(27, -2, 2, 2);
  // Taillights
  ctx.fillStyle = '#cc2222';
  ctx.fillRect(-29, -5, 2, 3);
  // Bumpers
  ctx.fillStyle = '#3a3a3a';
  ctx.fillRect(-29, -2, 2, 4);
  ctx.fillRect(27, -2, 2, 4);

  // Wheels
  ctx.fillStyle = '#111';
  ctx.beginPath(); ctx.arc(-15, 5, 5.5, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(17, 5, 5.5, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#555';
  ctx.beginPath(); ctx.arc(-15, 5, 2.5, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(17, 5, 2.5, 0, Math.PI * 2); ctx.fill();

  ctx.restore();
}

function drawCutsceneMountains(scrollOffset, baseY, amplitudes, color) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(-5, GH);
  for (let x = -5; x <= GW + 5; x += 2) {
    const sx = x + scrollOffset;
    const h = Math.abs(Math.sin(sx * 0.008) * amplitudes[0])
            + Math.abs(Math.sin(sx * 0.02 + 1.5) * amplitudes[1])
            + Math.abs(Math.sin(sx * 0.004 + 3) * amplitudes[2]);
    ctx.lineTo(x, baseY - h);
  }
  ctx.lineTo(GW + 5, GH);
  ctx.closePath();
  ctx.fill();
}

function drawOliveTree(x, y, scale) {
  const s = scale || 1;
  ctx.save();
  ctx.translate(x, y);
  ctx.scale(s, s);
  ctx.fillStyle = '#5a4428';
  ctx.fillRect(-2, -18, 4, 20);
  ctx.fillStyle = '#4a6a30';
  ctx.beginPath(); ctx.arc(0, -22, 10, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#5a7a38';
  ctx.beginPath(); ctx.arc(-5, -18, 7, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(6, -20, 8, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#6a8a42';
  ctx.beginPath(); ctx.arc(2, -25, 6, 0, Math.PI * 2); ctx.fill();
  ctx.restore();
}

// ═══════════════════════════════════════════════════════════
// CUTSCENE: THE ARRIVAL — Ken Burns Image Frames
// ═══════════════════════════════════════════════════════════

// Render an image with Ken Burns (pan + zoom) to fill the canvas
function drawKenBurns(imgKey, zoom, panX, panY) {
  const img = images[imgKey];
  if (!img) { ctx.fillStyle = '#0a0812'; ctx.fillRect(0, 0, GW, GH); return; }
  ctx.save();
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
  const baseScale = Math.max(GW / img.naturalWidth, GH / img.naturalHeight);
  const scale = baseScale * zoom;
  const dw = img.naturalWidth * scale;
  const dh = img.naturalHeight * scale;
  const dx = (GW - dw) / 2 + panX;
  const dy = (GH - dh) / 2 + panY;
  ctx.drawImage(img, dx, dy, dw, dh);
  ctx.imageSmoothingEnabled = false;
  ctx.restore();
}

function drawArrivalRoad(t, p, tick) {
  // Slow zoom out + slight leftward drift following the car
  drawKenBurns('cutscene-road', 1.18 - p * 0.12, -p * 15, -20 + p * 15);
  // Warm golden light pulse
  ctx.save();
  ctx.globalAlpha = 0.03 + Math.sin(tick * 0.02) * 0.01;
  ctx.fillStyle = '#FFD880';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

function drawArrivalDescent(t, p, tick) {
  // Pan down toward the town as we descend
  drawKenBurns('cutscene-descent', 1.15 - p * 0.08, p * 10, -30 + p * 45);
  // Location label fades in
  if (p > 0.3) {
    ctx.save();
    ctx.globalAlpha = Math.min(1, (p - 0.3) / 0.2) * 0.8;
    ctx.font = '10px "Press Start 2P", monospace';
    ctx.fillStyle = '#FFE8A0';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = '#000';
    ctx.shadowBlur = 8;
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;
    ctx.fillText('ΓΑΛΑΞΙΔΙ', GW / 2, 60);
    ctx.restore();
  }
}

function drawArrivalHarbor(t, p, tick) {
  // Existing exterior bg with gentle zoom in — visual continuity with gameplay
  drawKenBurns('bg-exterior', 1.08 + p * 0.06, 0, p * -10);
  // Warm overlay
  ctx.save();
  ctx.globalAlpha = 0.04;
  ctx.fillStyle = '#D4A03C';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

// ═══════════════════════════════════════════════════════════
// CUTSCENE: THE LETTER — Quest begins
// ═══════════════════════════════════════════════════════════

function drawLetterSingle(t, p, tick) {
  // Smooth zoom in then slowly pull back — no reload
  const zoom = p < 0.5
    ? 1.05 + p * 0.30          // zoom in first half
    : 1.20 - (p - 0.5) * 0.15; // ease back second half
  const panY = p < 0.5 ? p * -20 : -10 + (p - 0.5) * 20;
  drawKenBurns('cutscene-letter', zoom, 0, panY);
  ctx.save();
  ctx.globalAlpha = 0.04 + Math.sin(tick * 0.08) * 0.02;
  ctx.fillStyle = '#FFB040';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

// ═══════════════════════════════════════════════════════════
// CUTSCENE: THE CAVE — Into darkness
// ═══════════════════════════════════════════════════════════

function drawCaveEntrance(t, p, tick) {
  // Pan forward into the cave, lantern light flickers
  drawKenBurns('cutscene-cave', 1.10 + p * 0.10, 0, p * -15);
  ctx.save();
  ctx.globalAlpha = 0.05 + Math.sin(tick * 0.06) * 0.03;
  ctx.fillStyle = '#FFa040';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
  // Darken edges for cave atmosphere
  ctx.save();
  const caveVig = ctx.createRadialGradient(GW / 2, GH / 2, GW * 0.15, GW / 2, GH / 2, GW * 0.55);
  caveVig.addColorStop(0, 'rgba(0,0,0,0)');
  caveVig.addColorStop(1, 'rgba(0,0,0,0.45)');
  ctx.fillStyle = caveVig;
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

// ═══════════════════════════════════════════════════════════
// CUTSCENE: THE GHOST — Captain Visvikis appears
// ═══════════════════════════════════════════════════════════

function drawGhostAppear(t, p, tick) {
  drawKenBurns('cutscene-ghost-appear', 1.06 + p * 0.10, 0, p * -8);
  // Jade green ethereal pulse
  ctx.save();
  ctx.globalAlpha = 0.04 + Math.sin(tick * 0.04) * 0.03;
  ctx.fillStyle = '#40D8A0';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
  // Dusk vignette
  ctx.save();
  ctx.globalAlpha = 0.12;
  ctx.fillStyle = '#1a0a2e';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

function drawGhostFade(t, p, tick) {
  drawKenBurns('cutscene-ghost-farewell', 1.10 + p * 0.06, -p * 4, p * -6);
  // Fading jade light particles
  ctx.save();
  ctx.globalAlpha = (1 - p) * 0.06 + Math.sin(tick * 0.05) * 0.02;
  ctx.fillStyle = '#40D8A0';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
  // Deepening twilight
  ctx.save();
  ctx.globalAlpha = 0.10 + p * 0.10;
  ctx.fillStyle = '#1a0a2e';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

// ═══════════════════════════════════════════════════════════
// CUTSCENE: TELESCOPE — Clio spots Agios Georgios island
// ═══════════════════════════════════════════════════════════

function drawTelescopeIsland(t, p, tick) {
  drawKenBurns('cutscene-telescope-island', 1.06 + p * 0.10, 0, p * -8);
  // Soft golden shimmer on the chapel
  ctx.save();
  ctx.globalAlpha = 0.04 + Math.sin(tick * 0.02) * 0.02;
  ctx.fillStyle = '#FFD880';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

// ═══════════════════════════════════════════════════════════
// CUTSCENE: THE CROSSING — Dawn on the Ελπίδα
// ═══════════════════════════════════════════════════════════

function drawCrossingWide(t, p, tick) {
  // Chrysostomos at the helm, dawn stories
  drawKenBurns('cutscene-crossing-dawn', 1.08 + p * 0.08, -8 + p * 16, 0);
  // Dawn pink-gold overlay
  ctx.save();
  ctx.globalAlpha = 0.05 + Math.sin(tick * 0.015) * 0.02;
  ctx.fillStyle = '#FFB8A0';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

function drawCrossingClose(t, p, tick) {
  // Island approaching, golden path on water
  drawKenBurns('cutscene-crossing-island', 1.06 + p * 0.12, p * 10, p * -12);
  // Golden path shimmer
  ctx.save();
  ctx.globalAlpha = 0.04 + Math.sin(tick * 0.02) * 0.015;
  ctx.fillStyle = '#FFD880';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

// ═══════════════════════════════════════════════════════════
// CUTSCENE: SAILING BACK — Return to Galaxidi
// ═══════════════════════════════════════════════════════════

function drawSailBackSunset(t, p, tick) {
  // Reuse crossing-island image, slow reverse pan (island receding)
  drawKenBurns('cutscene-crossing-island', 1.12 - p * 0.06, -p * 10, p * -6);
  // Warm sunset overlay
  ctx.save();
  ctx.globalAlpha = 0.06 + Math.sin(tick * 0.018) * 0.025;
  ctx.fillStyle = '#FF9040';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

function drawSailBackGalaxidi(t, p, tick) {
  // Galaxidi approaching — reuse crossing-dawn, pan toward town
  drawKenBurns('cutscene-crossing-dawn', 1.12 - p * 0.08, 8 - p * 16, 0);
  // Golden hour glow
  ctx.save();
  ctx.globalAlpha = 0.05 + Math.sin(tick * 0.02) * 0.02;
  ctx.fillStyle = '#FFD060';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

// ═══════════════════════════════════════════════════════════
// CUTSCENE: THE TREASURE — 5-frame expanded reveal
// ═══════════════════════════════════════════════════════════

// Frame 1: Chest opening — wide shot, golden glow building from darkness
function drawTreasureGlow(t, p, tick) {
  drawKenBurns('cutscene-treasure-open', 1.0 + p * 0.06, 0, 0);
  // Golden glow builds from nothing to intense
  ctx.save();
  ctx.globalAlpha = p * 0.12 + Math.sin(tick * 0.04) * 0.03;
  ctx.fillStyle = '#FFD040';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

// Frame 2: Coins and necklace — zoom into chest contents
function drawTreasureCoins(t, p, tick) {
  drawKenBurns('cutscene-treasure-open', 1.12 + p * 0.15, -p * 10, p * -20);
  // Sparkling gold shimmer
  ctx.save();
  ctx.globalAlpha = 0.06 + Math.sin(tick * 0.05) * 0.03;
  ctx.fillStyle = '#FFD040';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

// Frame 3: The ledger — slow zoom to book area
function drawTreasureLedger(t, p, tick) {
  drawKenBurns('cutscene-treasure-open', 1.20 + p * 0.08, p * 15, p * -10);
  // Warm amber glow
  ctx.save();
  ctx.globalAlpha = 0.05 + Math.sin(tick * 0.03) * 0.02;
  ctx.fillStyle = '#FFB850';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

// Frame 4: Hands lifting the letter — close-up with dramatic pause
function drawTreasureLetterLift(t, p, tick) {
  drawKenBurns('cutscene-treasure-letter', 1.15 + p * 0.08, 0, p * -12);
  // Warm parchment glow
  ctx.save();
  ctx.globalAlpha = 0.04 + Math.sin(tick * 0.025) * 0.02;
  ctx.fillStyle = '#FFD880';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

// Frame 5: Family reading together — pull back, emotional
function drawTreasureFamilyRead(t, p, tick) {
  // Slow zoom in then settle
  const zoom = p < 0.5 ? 1.10 + p * 0.12 : 1.16 + (p - 0.5) * 0.04;
  drawKenBurns('cutscene-treasure-letter', zoom, -p * 5, p * -8);
  // Warm emotional glow intensifying
  ctx.save();
  ctx.globalAlpha = 0.04 + p * 0.03 + Math.sin(tick * 0.025) * 0.015;
  ctx.fillStyle = '#FFD880';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}


// ═══════════════════════════════════════════════════════════
// CUTSCENE: THE CHURCH — Clio finds the floor tile
// ═══════════════════════════════════════════════════════════

function drawChurchCandle(t, p, tick) {
  // Warm interior, slow zoom toward Clio lighting the candle
  drawKenBurns('cutscene-church', 1.08 + p * 0.10, 0, p * -12);
  // Beeswax candlelight warmth
  ctx.save();
  ctx.globalAlpha = 0.06 + Math.sin(tick * 0.05) * 0.03;
  ctx.fillStyle = '#FFD060';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

function drawChurchTile(t, p, tick) {
  // Low angle close-up, zoom into the discovery
  drawKenBurns('cutscene-church-tile', 1.06 + p * 0.14, 0, p * -18);
  // Sacred warm glow
  ctx.save();
  ctx.globalAlpha = 0.05 + Math.sin(tick * 0.04) * 0.02;
  ctx.fillStyle = '#FFB840';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}


// ═══════════════════════════════════════════════════════════
// CUTSCENE: EPILOGUE — The new αλληλασφάλεια
// ═══════════════════════════════════════════════════════════

function drawEpilogueHarbor(t, p, tick) {
  drawKenBurns('cutscene-epilogue-speech', 1.08 + p * 0.08, p * 6, 0);
  // Warm night festive glow
  ctx.save();
  ctx.globalAlpha = 0.06 + Math.sin(tick * 0.03) * 0.025;
  ctx.fillStyle = '#FFB860';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

function drawEpilogueClose(t, p, tick) {
  drawKenBurns('cutscene-epilogue-signing', 1.06 + p * 0.12, -p * 6, p * -10);
  // Golden ceremony light
  ctx.save();
  ctx.globalAlpha = 0.05 + Math.sin(tick * 0.025) * 0.02;
  ctx.fillStyle = '#FFD880';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

// ═══════════════════════════════════════════════════════════
// CUTSCENE: FESTIVAL — Epic celebration with particle effects
// ═══════════════════════════════════════════════════════════

// Fireworks particle pool
const festivalParticles = [];
function spawnFirework(x, y) {
  const colors = ['#FF4444','#FFD700','#44FF44','#4488FF','#FF44FF','#FF8800','#FFFFFF'];
  const color = colors[Math.floor(Math.random() * colors.length)];
  const count = 14 + Math.floor(Math.random() * 10);
  for (let i = 0; i < count; i++) {
    const angle = (Math.PI * 2 * i) / count + (Math.random() - 0.5) * 0.3;
    const speed = 1.2 + Math.random() * 2.5;
    festivalParticles.push({
      x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed - 0.5,
      life: 1.0, decay: 0.008 + Math.random() * 0.012,
      color, size: 1.5 + Math.random() * 1.5,
    });
  }
}
function updateAndDrawFireworks(tick) {
  if (tick % 35 === 0 || tick % 61 === 0 || tick % 83 === 0) {
    spawnFirework(80 + Math.random() * 480, 20 + Math.random() * 90);
  }
  ctx.save();
  for (let i = festivalParticles.length - 1; i >= 0; i--) {
    const p = festivalParticles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.025; p.life -= p.decay;
    if (p.life <= 0) { festivalParticles.splice(i, 1); continue; }
    ctx.globalAlpha = p.life * 0.85;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = p.life * 0.25;
    ctx.beginPath();
    ctx.arc(p.x - p.vx * 0.5, p.y - p.vy * 0.5, p.size * p.life * 1.5, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}
function drawStringLights(tick) {
  ctx.save();
  for (let i = 0; i < 22; i++) {
    const x = 20 + (i / 22) * 600;
    const y = 18 + Math.sin(i * 0.7 + 0.3) * 8;
    const flicker = 0.5 + Math.sin(tick * 0.06 + i * 1.4) * 0.3 + Math.random() * 0.15;
    const colors = ['#FFD700','#FF6600','#FF4444','#44FF44','#4488FF','#FF44FF'];
    ctx.globalAlpha = flicker;
    ctx.fillStyle = colors[i % colors.length];
    ctx.beginPath(); ctx.arc(x, y, 2.5, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = flicker * 0.3;
    ctx.beginPath(); ctx.arc(x, y, 7, 0, Math.PI * 2); ctx.fill();
  }
  ctx.restore();
}

function drawFestivalCelebration(t, p, tick) {
  drawKenBurns('cutscene-festival-celebration', 1.06 + p * 0.10, p * 8, 0);
  drawStringLights(tick);
  ctx.save();
  ctx.globalAlpha = 0.06 + Math.sin(tick * 0.03) * 0.03;
  ctx.fillStyle = '#FFB860';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

function drawFestivalFireworks(t, p, tick) {
  drawKenBurns('cutscene-festival-fireworks', 1.04 + p * 0.06, -p * 4, 0);
  updateAndDrawFireworks(tick);
  ctx.save();
  ctx.globalAlpha = 0.06 + Math.sin(tick * 0.02) * 0.03;
  ctx.fillStyle = '#FFD700';
  ctx.fillRect(0, GH * 0.65, GW, GH * 0.35);
  ctx.restore();
}

function drawFestivalGhost(t, p, tick) {
  drawKenBurns('cutscene-festival-ghost', 1.08 + p * 0.08, p * 5, -p * 3);
  ctx.save();
  const pulse = 0.08 + Math.sin(tick * 0.04) * 0.05;
  ctx.globalAlpha = pulse;
  ctx.fillStyle = '#88BBFF';
  ctx.fillRect(0, 0, GW, GH);
  const grd = ctx.createRadialGradient(GW * 0.5, GH * 0.4, 20, GW * 0.5, GH * 0.4, 180);
  grd.addColorStop(0, 'rgba(150, 200, 255, 0.35)');
  grd.addColorStop(1, 'rgba(150, 200, 255, 0)');
  ctx.globalAlpha = 0.25 + Math.sin(tick * 0.03) * 0.12;
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

function drawFestivalLantern(t, p, tick) {
  drawKenBurns('cutscene-festival-lantern', 1.05 + p * 0.10, -p * 6, p * -5);
  ctx.save();
  ctx.globalAlpha = 0.04 + Math.sin(tick * 0.025) * 0.02;
  ctx.fillStyle = '#FFB040';
  ctx.fillRect(0, 0, GW, GH);
  const grd = ctx.createRadialGradient(GW * 0.4, GH * 0.6, 8, GW * 0.4, GH * 0.6, 110);
  grd.addColorStop(0, 'rgba(255, 180, 60, 0.4)');
  grd.addColorStop(1, 'rgba(255, 180, 60, 0)');
  ctx.globalAlpha = 0.3 + Math.sin(tick * 0.04) * 0.15;
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, GW, GH);
  for (let i = 0; i < 6; i++) {
    const sx = GW * 0.15 + Math.sin(tick * 0.01 + i * 2) * GW * 0.35;
    const sy = GH * 0.72 + Math.sin(tick * 0.015 + i * 1.5) * GH * 0.08;
    ctx.globalAlpha = 0.12 + Math.sin(tick * 0.05 + i) * 0.08;
    ctx.fillStyle = '#FFD080';
    ctx.fillRect(sx, sy, 4 + Math.sin(tick * 0.03 + i) * 3, 1);
  }
  ctx.restore();
}

function drawFestivalPanorama(t, p, tick) {
  drawKenBurns('cutscene-festival-panorama', 1.10 + p * 0.06, p * 3, -p * 2);
  updateAndDrawFireworks(tick);
  drawStringLights(tick);
  ctx.save();
  ctx.globalAlpha = 0.03 + p * 0.07;
  ctx.fillStyle = '#FFD040';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();
}

// ════════════════════════════════════════════════════════════
// EASING
// ════════════════════════════════════════════════════════════
function easeInOutCubic(t) { return t < .5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3)/2; }

// ════════════════════════════════════════════════════════════
// COORDINATE CONVERSION
// ════════════════════════════════════════════════════════════
function screenToGame(sx, sy) {
  const rect = CVS.getBoundingClientRect();
  const scaleX = GW / rect.width;
  const scaleY = GH / rect.height;
  return { x: (sx - rect.left) * scaleX, y: (sy - rect.top) * scaleY };
}

// ════════════════════════════════════════════════════════════
// DUST PARTICLES (canvas-drawn)
// ════════════════════════════════════════════════════════════
const particles = [];
function initParticles() {
  particles.length = 0;
  const isExterior = (state.scene === 'exterior' || state.scene === 'terrace');
  const count = isExterior ? 30 : 20;
  for (let i = 0; i < count; i++) {
    if (isExterior) {
      // Golden motes drifting in the light shaft (upper-right to lower-left)
      const startX = GW * 0.4 + Math.random() * GW * 0.6;
      particles.push({
        x: startX,
        y: Math.random() * GH * 0.7,
        vx: -0.05 - Math.random() * 0.15,
        vy: 0.03 + Math.random() * 0.08,
        size: 0.6 + Math.random() * 1.5,
        alpha: 0,
        maxAlpha: 0.15 + Math.random() * 0.25,
        life: Math.random() * 700,
        maxLife: 600 + Math.random() * 500,
        glow: Math.random() < 0.3,
      });
    } else {
      particles.push({
        x: Math.random() * GW,
        y: 60 + Math.random() * 240,
        vx: 0.1 + Math.random() * 0.25,
        vy: -0.05 - Math.random() * 0.12,
        size: 0.8 + Math.random() * 1.8,
        alpha: 0,
        maxAlpha: 0.12 + Math.random() * 0.18,
        life: Math.random() * 700,
        maxLife: 500 + Math.random() * 400,
      });
    }
  }
}

function updateParticles() {
  for (const p of particles) {
    p.x += p.vx;
    p.y += p.vy;
    p.life++;
    const prog = p.life / p.maxLife;
    if (prog < 0.3) p.alpha = p.maxAlpha * (prog / 0.3) * (prog / 0.3); // quadratic fade-in
    else if (prog > 0.7) { const f = (prog - 0.7) / 0.3; p.alpha = p.maxAlpha * (1 - f * f); } // quadratic fade-out
    else p.alpha = p.maxAlpha;
    if (p.life >= p.maxLife || p.x > GW + 10 || p.x < -10 || p.y < -10 || p.y > GH + 10) {
      const isExterior = (state.scene === 'exterior' || state.scene === 'terrace');
      if (isExterior) {
        p.x = GW * 0.4 + Math.random() * GW * 0.6;
        p.y = -5 + Math.random() * 30;
      } else {
        p.x = -5 + Math.random() * 20;
        p.y = 80 + Math.random() * 200;
      }
      p.life = 0;
      p.alpha = 0;
    }
  }
}

function drawParticles() {
  const sp = state.seq.env.spectral;
  for (const p of particles) {
    if (p.alpha <= 0) continue;
    ctx.save();
    ctx.globalAlpha = p.alpha;
    if (sp > 0) {
      // Lerp particle colors from gold to blue-white based on spectral
      const gr = Math.round(255 * (1 - sp) + 130 * sp);
      const gg = Math.round(200 * (1 - sp) + 180 * sp);
      const gb = Math.round(60 * (1 - sp) + 255 * sp);
      ctx.shadowColor = `rgba(${gr},${gg},${gb},0.6)`;
      ctx.shadowBlur = 4;
      ctx.fillStyle = `rgb(${gr},${gg},${gb})`;
    } else if (p.glow) {
      ctx.shadowColor = 'rgba(255,200,60,0.6)';
      ctx.shadowBlur = 4;
      ctx.fillStyle = '#FFD860';
    } else {
      ctx.fillStyle = '#D4A03C';
    }
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

// ════════════════════════════════════════════════════════════
// SCENE AMBIENCE — per-scene visual & audio layers
// ════════════════════════════════════════════════════════════


// ── Bobbing Boats (extracted from background, redrawn with bob) ──
let boatCutout = null;
let boatWaterPatch = null;
const boatRegion = { x: 375, y: 96, w: 190, h: 80 };
let boatBobPhase = 0;

function initBoatBob() {
  boatBobPhase = Math.random() * Math.PI * 2;
  boatCutout = null;
  boatWaterPatch = null;
  const bgImg = images['bg-exterior'];
  if (!bgImg || !bgImg.complete) return;
  // Source coords — account for cover-fit crop (center-crop for aspect ratio)
  const imgW = bgImg.naturalWidth;
  const imgH = bgImg.naturalHeight;
  const canvasRatio = GW / GH;
  const imgRatio = imgW / imgH;
  let cropSx = 0, cropSy = 0, cropSw = imgW, cropSh = imgH;
  if (imgRatio < canvasRatio) {
    cropSh = imgW / canvasRatio;
    cropSy = (imgH - cropSh) / 2;
  } else if (imgRatio > canvasRatio) {
    cropSw = imgH * canvasRatio;
    cropSx = (imgW - cropSw) / 2;
  }
  const sx = cropSx + boatRegion.x / GW * cropSw;
  const sy = cropSy + boatRegion.y / GH * cropSh;
  const sw = boatRegion.w / GW * cropSw;
  const sh = boatRegion.h / GH * cropSh;
  // Extract boats
  const cut = document.createElement('canvas');
  cut.width = boatRegion.w;
  cut.height = boatRegion.h;
  const cctx = cut.getContext('2d');
  cctx.imageSmoothingEnabled = true;
  cctx.imageSmoothingQuality = 'high';
  cctx.drawImage(bgImg, sx, sy, sw, sh, 0, 0, boatRegion.w, boatRegion.h);
  boatCutout = cut;
  // Water patch from row just below boats
  const patch = document.createElement('canvas');
  patch.width = boatRegion.w;
  patch.height = boatRegion.h + 8;
  const pctx = patch.getContext('2d');
  pctx.imageSmoothingEnabled = true;
  pctx.imageSmoothingQuality = 'high';
  const waterSrcY = sy + sh;
  for (let row = 0; row < patch.height; row++) {
    pctx.drawImage(bgImg, sx, waterSrcY, sw, 1, 0, row, boatRegion.w, 1);
  }
  boatWaterPatch = patch;
}

function updateBoatBob(dt) {
  boatBobPhase += dt * 0.8;
}

function drawBoatBob() {
  if (!boatCutout || !boatWaterPatch) return;
  const bob = Math.sin(boatBobPhase) * 3;
  // Cover original boats with water
  ctx.drawImage(boatWaterPatch, boatRegion.x, boatRegion.y);
  // Redraw boats shifted by bob
  ctx.drawImage(boatCutout, boatRegion.x, boatRegion.y + bob);
}

// ── Sea Shimmer ──
function drawSeaShimmer(tick) {
  const t = tick * 0.02;
  ctx.save();
  // Water area on exterior scene (right side, harbor) — adjusted for cover-fit crop
  for (let ry = 0; ry < 104; ry += 2) {
    const d = ry / 104;
    // Golden reflections
    ctx.fillStyle = `rgba(230,180,60,${0.04 + d * 0.03})`;
    for (let rx = 360; rx < 580; rx += 4) {
      const shimmer = Math.sin(rx * 0.05 + ry * 0.08 + t * 1.8) * 0.5 + 0.5;
      if (shimmer > 0.55) {
        ctx.fillRect(rx, ry, 2 + Math.floor(shimmer * 3), 1);
      }
    }
    // Dark wave troughs
    ctx.fillStyle = `rgba(0,20,40,${0.03 + d * 0.02})`;
    for (let rx = 360; rx < 580; rx += 6) {
      if (Math.sin(rx * 0.07 + ry * 0.12 - t * 1.1) > 0.4) {
        ctx.fillRect(rx, ry + 1, 3, 1);
      }
    }
  }
  ctx.restore();
}

// ── Bougainvillea Petals ──
const petals = [];
function initPetals() {
  petals.length = 0;
  for (let i = 0; i < 12; i++) {
    petals.push(newPetal());
  }
}
function newPetal() {
  return {
    x: 175 + Math.random() * 150,
    y: -10 + Math.random() * 30,
    vx: 0.1 + Math.random() * 0.3,
    vy: 0.2 + Math.random() * 0.4,
    rot: Math.random() * Math.PI * 2,
    rotV: (Math.random() - 0.5) * 0.05,
    size: 1.5 + Math.random() * 1.5,
    wobble: Math.random() * Math.PI * 2,
    wobbleSpeed: 0.02 + Math.random() * 0.02,
    alpha: 0.5 + Math.random() * 0.4,
    color: Math.random() < 0.7 ? '#E0489A' : (Math.random() < 0.5 ? '#D03878' : '#C83068'),
  };
}
function updatePetals() {
  for (const p of petals) {
    p.wobble += p.wobbleSpeed;
    p.x += p.vx + Math.sin(p.wobble) * 0.3;
    p.y += p.vy;
    p.rot += p.rotV;
    if (p.y > 380 || p.x > GW + 10) {
      Object.assign(p, newPetal());
    }
  }
}
function drawPetals() {
  for (const p of petals) {
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(p.rot);
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.ellipse(0, 0, p.size, p.size * 0.5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}



// ── Golden Hour Light Shaft ──
function drawLightShaft(tick) {
  ctx.save();
  const t = tick * 0.005;
  // Diagonal warm light from upper-right
  const lg = ctx.createLinearGradient(GW, 0, GW * 0.3, GH * 0.6);
  lg.addColorStop(0, `rgba(255,200,80,${0.04 + Math.sin(t) * 0.01})`);
  lg.addColorStop(0.4, `rgba(255,180,60,${0.02 + Math.sin(t + 1) * 0.005})`);
  lg.addColorStop(1, 'rgba(255,180,60,0)');
  ctx.fillStyle = lg;
  ctx.fillRect(0, 0, GW, GH);
  // Light beam rays (subtle streaks)
  ctx.globalAlpha = 0.015 + Math.sin(t * 0.7) * 0.005;
  ctx.fillStyle = '#FFD060';
  ctx.beginPath();
  ctx.moveTo(GW, 0);
  ctx.lineTo(GW * 0.55, GH * 0.7);
  ctx.lineTo(GW * 0.65, GH * 0.7);
  ctx.lineTo(GW, 20);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(GW - 40, 0);
  ctx.lineTo(GW * 0.4, GH * 0.5);
  ctx.lineTo(GW * 0.48, GH * 0.5);
  ctx.lineTo(GW - 10, 0);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

// ── Heat Haze ──
function drawHeatHaze(tick) {
  ctx.save();
  const t = tick * 0.03;
  ctx.globalAlpha = 0.02;
  for (let x = 50; x < GW - 50; x += 8) {
    const shift = Math.sin(x * 0.05 + t) * 1.5;
    ctx.fillStyle = '#FFD090';
    ctx.fillRect(x, 360 + shift, 4, 1);
  }
  ctx.restore();
}

// ── Ambient Sound Manager (Web Audio API — procedural, no files) ──
let audioCtx = null;
const ambientSounds = {
  wavesNode: null, cicadasNode: null, windNode: null, dripsInterval: null,
  bellPlayed: false, gullTimer: 0, gullInterval: 10, bellTimer: 0, bellInterval: 20,
  tavernaNode: null, tavernaTimer: 0, tavernaInterval: 4,
  crowdNode: null, crowdTimer: 0, crowdInterval: 6,
  masterGain: null, active: false, currentScene: null,
};

// Per-scene ambient config: which layers play and at what volume
const sceneAmbientConfig = {
  exterior:  { waves: 0.12, wind: 0.04, gulls: true,  gullFreq: [8,7], cicadas: 0.03, bell: true, bellFreq: [25,20] },
  terrace:   { waves: 0.10, wind: 0.03, gulls: true,  gullFreq: [10,8], cicadas: 0.04, bell: true, bellFreq: [30,25] },
  kitchen:   { waves: 0.03, wind: 0.01 },
  port:      { waves: 0.18, wind: 0.06, gulls: true,  gullFreq: [5,4], bell: true, bellFreq: [35,30] },
  waterfront:{ waves: 0.14, wind: 0.04, gulls: true,  gullFreq: [8,6], bell: true, bellFreq: [30,25] },
  museum:    { waves: 0.02, wind: 0.01 },
  liotrivi:  { waves: 0.04, wind: 0.02, cicadas: 0.02, bell: true, bellFreq: [25,20], taverna: true, tavernaFreq: [3,4] },
  cave:      { drips: true,  wind: 0.02 },
  windmill:  { waves: 0.06, wind: 0.12, gulls: true,  gullFreq: [12,10], cicadas: 0.05, bell: true, bellFreq: [40,30] },
  graveyard: { waves: 0.04, wind: 0.08, cicadas: 0.02, bell: true, bellFreq: [20,15] },
  church:    { waves: 0.02, wind: 0.01, cicadas: 0.02, bell: true, bellFreq: [12,10] },
  church_interior: { waves: 0, wind: 0, bell: true, bellFreq: [15,12] },
  boat:      { waves: 0.22, wind: 0.10, gulls: true,  gullFreq: [6,5] },
  treasure:  { waves: 0.08, wind: 0.06 },
  new_era:   { waves: 0.14, wind: 0.04, crowd: true, crowdVol: 0.08, crowdFreq: [4,5] },
};

function getAudioCtx() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    ambientSounds.masterGain = audioCtx.createGain();
    ambientSounds.masterGain.gain.value = 1;
    ambientSounds.masterGain.connect(audioCtx.destination);
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}

function createWavesLoop() {
  const ctx = getAudioCtx();
  const bufferSize = ctx.sampleRate * 4;
  const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
  const data = buffer.getChannelData(0);
  let last = 0;
  for (let i = 0; i < bufferSize; i++) {
    const white = Math.random() * 2 - 1;
    last = (last + (0.02 * white)) / 1.02;
    const waveMod = 0.5 + 0.5 * Math.sin(i / ctx.sampleRate * Math.PI * 0.3);
    data[i] = last * 3.5 * waveMod;
  }
  const src = ctx.createBufferSource();
  src.buffer = buffer;
  src.loop = true;
  const lp = ctx.createBiquadFilter();
  lp.type = 'lowpass';
  lp.frequency.value = 400;
  const gain = ctx.createGain();
  gain.gain.value = 0.12;
  src.connect(lp);
  lp.connect(gain);
  gain.connect(ambientSounds.masterGain);
  src.start();
  return { src, gain };
}

function createCicadasLoop() {
  const ctx = getAudioCtx();
  const merger = ctx.createGain();
  merger.gain.value = 0;
  const oscs = [];
  const freqs = [4200, 4800, 5100, 5600, 6200];
  for (const f of freqs) {
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = f + (Math.random() - 0.5) * 200;
    const am = ctx.createGain();
    const lfo = ctx.createOscillator();
    lfo.frequency.value = 8 + Math.random() * 12;
    const lfoGain = ctx.createGain();
    lfoGain.gain.value = 0.5;
    lfo.connect(lfoGain);
    lfoGain.connect(am.gain);
    am.gain.value = 0.5;
    osc.connect(am);
    am.connect(merger);
    osc.start();
    lfo.start();
    oscs.push({ osc, lfo });
  }
  const bp = ctx.createBiquadFilter();
  bp.type = 'bandpass';
  bp.frequency.value = 5000;
  bp.Q.value = 2;
  const gain = ctx.createGain();
  gain.gain.value = 0.04;
  merger.connect(bp);
  bp.connect(gain);
  gain.connect(ambientSounds.masterGain);
  return { oscs, merger, gain };
}

function playSeagullCry() {
  const ctx = getAudioCtx();
  const now = ctx.currentTime;
  const osc = ctx.createOscillator();
  osc.type = 'sine';
  const baseF = 1800 + Math.random() * 600;
  osc.frequency.setValueAtTime(baseF, now);
  osc.frequency.linearRampToValueAtTime(baseF * 0.6, now + 0.15);
  osc.frequency.linearRampToValueAtTime(baseF * 1.1, now + 0.35);
  osc.frequency.linearRampToValueAtTime(baseF * 0.5, now + 0.6);
  const osc2 = ctx.createOscillator();
  osc2.type = 'sine';
  osc2.frequency.setValueAtTime(baseF * 1.5, now);
  osc2.frequency.linearRampToValueAtTime(baseF * 0.9, now + 0.15);
  osc2.frequency.linearRampToValueAtTime(baseF * 1.6, now + 0.35);
  osc2.frequency.linearRampToValueAtTime(baseF * 0.75, now + 0.6);
  const vib = ctx.createOscillator();
  vib.frequency.value = 20 + Math.random() * 15;
  const vibGain = ctx.createGain();
  vibGain.gain.value = 40;
  vib.connect(vibGain);
  vibGain.connect(osc.frequency);
  vibGain.connect(osc2.frequency);
  const env = ctx.createGain();
  env.gain.setValueAtTime(0, now);
  env.gain.linearRampToValueAtTime(0.06 + Math.random() * 0.04, now + 0.05);
  env.gain.setValueAtTime(0.06, now + 0.35);
  env.gain.linearRampToValueAtTime(0, now + 0.7);
  const noiseLen = ctx.sampleRate;
  const noiseBuf = ctx.createBuffer(1, noiseLen, ctx.sampleRate);
  const nd = noiseBuf.getChannelData(0);
  for (let i = 0; i < noiseLen; i++) nd[i] = Math.random() * 2 - 1;
  const noiseSrc = ctx.createBufferSource();
  noiseSrc.buffer = noiseBuf;
  const noiseBP = ctx.createBiquadFilter();
  noiseBP.type = 'bandpass';
  noiseBP.frequency.value = 2000;
  noiseBP.Q.value = 3;
  const noiseGain = ctx.createGain();
  noiseGain.gain.setValueAtTime(0, now);
  noiseGain.gain.linearRampToValueAtTime(0.015, now + 0.05);
  noiseGain.gain.linearRampToValueAtTime(0, now + 0.7);
  noiseSrc.connect(noiseBP);
  noiseBP.connect(noiseGain);
  noiseGain.connect(ambientSounds.masterGain);
  osc.connect(env);
  osc2.connect(env);
  env.connect(ambientSounds.masterGain);
  osc.start(now);
  osc2.start(now);
  vib.start(now);
  noiseSrc.start(now);
  osc.stop(now + 0.75);
  osc2.stop(now + 0.75);
  vib.stop(now + 0.75);
  noiseSrc.stop(now + 0.75);
}

function playChurchBell() {
  const ctx = getAudioCtx();
  const now = ctx.currentTime;
  const partials = [1, 2.0, 2.98, 4.07, 5.2, 6.5];
  const baseF = 280;
  const mix = ctx.createGain();
  mix.gain.value = 0.12;
  for (let i = 0; i < partials.length; i++) {
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = baseF * partials[i];
    const g = ctx.createGain();
    const amp = 1 / (i + 1);
    const decay = 3 - i * 0.3;
    g.gain.setValueAtTime(amp, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + Math.max(0.5, decay));
    osc.connect(g);
    g.connect(mix);
    osc.start(now);
    osc.stop(now + 4);
  }
  mix.connect(ambientSounds.masterGain);
}

function createWindLoop(volume) {
  const ctx = getAudioCtx();
  const bufferSize = ctx.sampleRate * 6;
  const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
  const data = buffer.getChannelData(0);
  let last = 0;
  for (let i = 0; i < bufferSize; i++) {
    const white = Math.random() * 2 - 1;
    last = (last + (0.01 * white)) / 1.01;
    // Slow modulation for gusting effect
    const gust = 0.4 + 0.6 * Math.sin(i / ctx.sampleRate * Math.PI * 0.15)
                          * Math.sin(i / ctx.sampleRate * Math.PI * 0.07 + 1.3);
    data[i] = last * 4 * Math.max(0, gust);
  }
  const src = ctx.createBufferSource();
  src.buffer = buffer;
  src.loop = true;
  const hp = ctx.createBiquadFilter();
  hp.type = 'highpass';
  hp.frequency.value = 200;
  const lp = ctx.createBiquadFilter();
  lp.type = 'lowpass';
  lp.frequency.value = 1200;
  const gain = ctx.createGain();
  gain.gain.value = volume;
  src.connect(hp);
  hp.connect(lp);
  lp.connect(gain);
  gain.connect(ambientSounds.masterGain);
  src.start();
  return { src, gain };
}

function playCaveDrip() {
  const ctx = getAudioCtx();
  const now = ctx.currentTime;
  const freq = 1200 + Math.random() * 2000;
  const osc = ctx.createOscillator();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(freq, now);
  osc.frequency.exponentialRampToValueAtTime(freq * 0.3, now + 0.15);
  const env = ctx.createGain();
  env.gain.setValueAtTime(0.08 + Math.random() * 0.04, now);
  env.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
  // Simple delay for echo
  const delay = ctx.createDelay();
  delay.delayTime.value = 0.12 + Math.random() * 0.08;
  const delayGain = ctx.createGain();
  delayGain.gain.value = 0.3;
  osc.connect(env);
  env.connect(ambientSounds.masterGain);
  env.connect(delay);
  delay.connect(delayGain);
  delayGain.connect(ambientSounds.masterGain);
  osc.start(now);
  osc.stop(now + 0.4);
}

// ── SFX — procedural sound effects ──────────────────────────
const sceneSurface = {
  exterior: 'stone', terrace: 'stone', kitchen: 'wood',
  port: 'stone', museum: 'wood', liotrivi: 'stone',
  cave: 'stone', church: 'stone', church_interior: 'stone',
  windmill: 'dirt', boat: 'wood', graveyard: 'dirt',
  treasure: 'sand', new_era: 'stone',
};
let sfxStepAcc = 0;   // accumulator for footstep timing
let sfxStepLR = 0;    // alternates L/R foot

function playSFX(type) {
  const ctx = getAudioCtx();
  if (!ctx || !state.musicOn) return;
  const now = ctx.currentTime;

  if (type === 'step') {
    // Short noise burst, LP-filtered — pitch varies by L/R and surface
    const surface = sceneSurface[state.scene] || 'stone';
    const cutoff = surface === 'wood' ? 1800 : surface === 'sand' ? 600 : surface === 'dirt' ? 800 : 1200;
    const vol = surface === 'sand' ? 0.04 : surface === 'wood' ? 0.06 : 0.05;
    const dur = surface === 'sand' ? 0.06 : 0.04;
    const len = Math.ceil(ctx.sampleRate * dur);
    const buf = ctx.createBuffer(1, len, ctx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < len; i++) d[i] = Math.random() * 2 - 1;
    const src = ctx.createBufferSource();
    src.buffer = buf;
    // Alternate pitch for L/R foot
    src.playbackRate.value = sfxStepLR ? 1.1 : 0.9;
    sfxStepLR ^= 1;
    const lp = ctx.createBiquadFilter();
    lp.type = 'lowpass';
    lp.frequency.value = cutoff + (Math.random() - 0.5) * 200;
    const g = ctx.createGain();
    g.gain.setValueAtTime(vol, now);
    g.gain.linearRampToValueAtTime(0, now + dur);
    src.connect(lp); lp.connect(g); g.connect(ambientSounds.masterGain);
    src.start(now); src.stop(now + dur);

  } else if (type === 'pickup') {
    // Rising two-tone chime C5→E5
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(523, now);         // C5
    osc.frequency.setValueAtTime(659, now + 0.08);  // E5
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.10, now);
    g.gain.linearRampToValueAtTime(0.12, now + 0.08);
    g.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
    osc.connect(g); g.connect(ambientSounds.masterGain);
    osc.start(now); osc.stop(now + 0.35);

  } else if (type === 'whoosh') {
    // Filtered noise sweep for scene transition
    const len = Math.ceil(ctx.sampleRate * 0.4);
    const buf = ctx.createBuffer(1, len, ctx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < len; i++) d[i] = Math.random() * 2 - 1;
    const src = ctx.createBufferSource();
    src.buffer = buf;
    const bp = ctx.createBiquadFilter();
    bp.type = 'bandpass';
    bp.frequency.setValueAtTime(400, now);
    bp.frequency.exponentialRampToValueAtTime(2000, now + 0.15);
    bp.frequency.exponentialRampToValueAtTime(300, now + 0.4);
    bp.Q.value = 1.5;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0, now);
    g.gain.linearRampToValueAtTime(0.08, now + 0.1);
    g.gain.linearRampToValueAtTime(0, now + 0.4);
    src.connect(bp); bp.connect(g); g.connect(ambientSounds.masterGain);
    src.start(now); src.stop(now + 0.4);

  } else if (type === 'tick') {
    // Tiny 1ms noise burst — typewriter click
    const len = Math.ceil(ctx.sampleRate * 0.003);
    const buf = ctx.createBuffer(1, len, ctx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < len; i++) d[i] = Math.random() * 2 - 1;
    const src = ctx.createBufferSource();
    src.buffer = buf;
    const hp = ctx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 2000;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.06, now);
    g.gain.linearRampToValueAtTime(0, now + 0.003);
    src.connect(hp); hp.connect(g); g.connect(ambientSounds.masterGain);
    src.start(now); src.stop(now + 0.005);

  } else if (type === 'click') {
    // Short square wave blip for UI verb click
    const osc = ctx.createOscillator();
    osc.type = 'square';
    osc.frequency.value = 800;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.05, now);
    g.gain.linearRampToValueAtTime(0, now + 0.03);
    osc.connect(g); g.connect(ambientSounds.masterGain);
    osc.start(now); osc.stop(now + 0.03);

  } else if (type === 'door') {
    // Wooden door creak — staggered sawtooth bursts + noise friction
    for (let i = 0; i < 5; i++) {
      const t0 = now + i * 0.05;
      const osc = ctx.createOscillator();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(120 + i * 30 + Math.random() * 50, t0);
      osc.frequency.linearRampToValueAtTime(80 + i * 20, t0 + 0.12);
      const g = ctx.createGain();
      g.gain.setValueAtTime(0.04, t0);
      g.gain.exponentialRampToValueAtTime(0.001, t0 + 0.12);
      osc.connect(g); g.connect(ambientSounds.masterGain);
      osc.start(t0); osc.stop(t0 + 0.12);
    }
    // Wood friction noise
    const nLen = Math.ceil(ctx.sampleRate * 0.25);
    const nBuf = ctx.createBuffer(1, nLen, ctx.sampleRate);
    const nd = nBuf.getChannelData(0);
    for (let i = 0; i < nLen; i++) nd[i] = Math.random() * 2 - 1;
    const nSrc = ctx.createBufferSource();
    nSrc.buffer = nBuf;
    const nLP = ctx.createBiquadFilter();
    nLP.type = 'lowpass'; nLP.frequency.value = 500;
    const nG = ctx.createGain();
    nG.gain.setValueAtTime(0.03, now);
    nG.gain.linearRampToValueAtTime(0.05, now + 0.1);
    nG.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
    nSrc.connect(nLP); nLP.connect(nG); nG.connect(ambientSounds.masterGain);
    nSrc.start(now); nSrc.stop(now + 0.25);

  } else if (type === 'drawer') {
    // Wooden drawer slide — noise burst + low thud at end
    const nLen = Math.ceil(ctx.sampleRate * 0.2);
    const nBuf = ctx.createBuffer(1, nLen, ctx.sampleRate);
    const nd = nBuf.getChannelData(0);
    for (let i = 0; i < nLen; i++) nd[i] = Math.random() * 2 - 1;
    const nSrc = ctx.createBufferSource();
    nSrc.buffer = nBuf;
    const nLP = ctx.createBiquadFilter();
    nLP.type = 'lowpass'; nLP.frequency.value = 400;
    const nG = ctx.createGain();
    nG.gain.setValueAtTime(0.06, now);
    nG.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
    nSrc.connect(nLP); nLP.connect(nG); nG.connect(ambientSounds.masterGain);
    nSrc.start(now); nSrc.stop(now + 0.2);
    // End thud
    const osc = ctx.createOscillator();
    osc.type = 'triangle'; osc.frequency.value = 80;
    const g2 = ctx.createGain();
    g2.gain.setValueAtTime(0, now + 0.15);
    g2.gain.linearRampToValueAtTime(0.05, now + 0.16);
    g2.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
    osc.connect(g2); g2.connect(ambientSounds.masterGain);
    osc.start(now + 0.15); osc.stop(now + 0.3);

  } else if (type === 'chest') {
    // Iron chest unlock — mechanical clicks + heavy creak
    // Click sequence (lock mechanism)
    const clicks = [0, 0.06, 0.12];
    const cFreqs = [800, 600, 400];
    clicks.forEach((dt, i) => {
      const osc = ctx.createOscillator();
      osc.type = 'square';
      osc.frequency.value = cFreqs[i];
      const g = ctx.createGain();
      g.gain.setValueAtTime(0.08 - i * 0.02, now + dt);
      g.gain.exponentialRampToValueAtTime(0.001, now + dt + 0.05);
      osc.connect(g); g.connect(ambientSounds.masterGain);
      osc.start(now + dt); osc.stop(now + dt + 0.05);
    });
    // Heavy hinge creak after clicks
    for (let i = 0; i < 4; i++) {
      const t0 = now + 0.2 + i * 0.06;
      const osc = ctx.createOscillator();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(150 + i * 20, t0);
      osc.frequency.linearRampToValueAtTime(100, t0 + 0.1);
      const g = ctx.createGain();
      g.gain.setValueAtTime(0.03, t0);
      g.gain.exponentialRampToValueAtTime(0.001, t0 + 0.1);
      osc.connect(g); g.connect(ambientSounds.masterGain);
      osc.start(t0); osc.stop(t0 + 0.1);
    }

  } else if (type === 'key') {
    // Key turning in lock — two metallic clicks
    const osc1 = ctx.createOscillator();
    osc1.type = 'square'; osc1.frequency.value = 1200;
    const g1 = ctx.createGain();
    g1.gain.setValueAtTime(0.07, now);
    g1.gain.exponentialRampToValueAtTime(0.001, now + 0.03);
    osc1.connect(g1); g1.connect(ambientSounds.masterGain);
    osc1.start(now); osc1.stop(now + 0.03);
    const osc2 = ctx.createOscillator();
    osc2.type = 'square'; osc2.frequency.value = 900;
    const g2 = ctx.createGain();
    g2.gain.setValueAtTime(0.06, now + 0.08);
    g2.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
    osc2.connect(g2); g2.connect(ambientSounds.masterGain);
    osc2.start(now + 0.08); osc2.stop(now + 0.12);

  } else if (type === 'ghost') {
    // Supernatural ghost appearance — low drone + high shimmer
    // Low eerie drone
    const drone = ctx.createOscillator();
    drone.type = 'sine'; drone.frequency.value = 65;
    const dG = ctx.createGain();
    dG.gain.setValueAtTime(0, now);
    dG.gain.linearRampToValueAtTime(0.08, now + 0.5);
    dG.gain.linearRampToValueAtTime(0.06, now + 1.5);
    dG.gain.exponentialRampToValueAtTime(0.001, now + 2.5);
    drone.connect(dG); dG.connect(ambientSounds.masterGain);
    drone.start(now); drone.stop(now + 2.5);
    // High ethereal shimmer
    const shim = ctx.createOscillator();
    shim.type = 'sine'; shim.frequency.value = 1800;
    const sLfo = ctx.createOscillator();
    sLfo.frequency.value = 4;
    const sLfoG = ctx.createGain();
    sLfoG.gain.value = 100;
    sLfo.connect(sLfoG); sLfoG.connect(shim.frequency);
    const sG = ctx.createGain();
    sG.gain.setValueAtTime(0, now + 0.3);
    sG.gain.linearRampToValueAtTime(0.04, now + 0.8);
    sG.gain.linearRampToValueAtTime(0.03, now + 1.8);
    sG.gain.exponentialRampToValueAtTime(0.001, now + 2.5);
    shim.connect(sG); sG.connect(ambientSounds.masterGain);
    shim.start(now + 0.3); shim.stop(now + 2.5);
    sLfo.start(now + 0.3); sLfo.stop(now + 2.5);
    // Breathy wind layer
    const wLen = Math.ceil(ctx.sampleRate * 2.5);
    const wBuf = ctx.createBuffer(1, wLen, ctx.sampleRate);
    const wd = wBuf.getChannelData(0);
    for (let i = 0; i < wLen; i++) wd[i] = Math.random() * 2 - 1;
    const wSrc = ctx.createBufferSource();
    wSrc.buffer = wBuf;
    const wBP = ctx.createBiquadFilter();
    wBP.type = 'bandpass'; wBP.frequency.value = 800; wBP.Q.value = 2;
    const wG = ctx.createGain();
    wG.gain.setValueAtTime(0, now);
    wG.gain.linearRampToValueAtTime(0.03, now + 0.5);
    wG.gain.exponentialRampToValueAtTime(0.001, now + 2.5);
    wSrc.connect(wBP); wBP.connect(wG); wG.connect(ambientSounds.masterGain);
    wSrc.start(now); wSrc.stop(now + 2.5);

  } else if (type === 'candle') {
    // Match strike + flame catch — soft whoosh + bright tone
    // Strike friction
    const nLen = Math.ceil(ctx.sampleRate * 0.08);
    const nBuf = ctx.createBuffer(1, nLen, ctx.sampleRate);
    const nd = nBuf.getChannelData(0);
    for (let i = 0; i < nLen; i++) nd[i] = Math.random() * 2 - 1;
    const nSrc = ctx.createBufferSource();
    nSrc.buffer = nBuf;
    const nHP = ctx.createBiquadFilter();
    nHP.type = 'highpass'; nHP.frequency.value = 3000;
    const nG = ctx.createGain();
    nG.gain.setValueAtTime(0.06, now);
    nG.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
    nSrc.connect(nHP); nHP.connect(nG); nG.connect(ambientSounds.masterGain);
    nSrc.start(now); nSrc.stop(now + 0.08);
    // Warm flame tone
    const osc = ctx.createOscillator();
    osc.type = 'sine'; osc.frequency.value = 440;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0, now + 0.06);
    g.gain.linearRampToValueAtTime(0.06, now + 0.12);
    g.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
    osc.connect(g); g.connect(ambientSounds.masterGain);
    osc.start(now + 0.06); osc.stop(now + 0.5);

  } else if (type === 'stone') {
    // Heavy stone placement — deep thud + resonance
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(120, now);
    osc.frequency.exponentialRampToValueAtTime(50, now + 0.3);
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.12, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
    osc.connect(g); g.connect(ambientSounds.masterGain);
    osc.start(now); osc.stop(now + 0.5);
    // Stone grinding noise
    const nLen = Math.ceil(ctx.sampleRate * 0.3);
    const nBuf = ctx.createBuffer(1, nLen, ctx.sampleRate);
    const nd = nBuf.getChannelData(0);
    for (let i = 0; i < nLen; i++) nd[i] = Math.random() * 2 - 1;
    const nSrc = ctx.createBufferSource();
    nSrc.buffer = nBuf;
    const nLP = ctx.createBiquadFilter();
    nLP.type = 'lowpass'; nLP.frequency.value = 300;
    const nG = ctx.createGain();
    nG.gain.setValueAtTime(0.05, now);
    nG.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
    nSrc.connect(nLP); nLP.connect(nG); nG.connect(ambientSounds.masterGain);
    nSrc.start(now); nSrc.stop(now + 0.3);

  } else if (type === 'fanfare') {
    // Treasure discovery — ascending C major fanfare
    const melody = [
      [392, 0.2], [440, 0.2], [523, 0.2], [659, 0.3],
      [523, 0.15], [659, 0.15], [784, 0.5],
      [659, 0.2], [784, 0.2], [1047, 0.6],
    ];
    let t = 0;
    melody.forEach(([freq, dur]) => {
      const t0 = now + t;
      // Main voice
      const osc = ctx.createOscillator();
      osc.type = 'sine'; osc.frequency.value = freq;
      const g = ctx.createGain();
      g.gain.setValueAtTime(0.12, t0);
      g.gain.exponentialRampToValueAtTime(0.001, t0 + dur + 0.1);
      osc.connect(g); g.connect(ambientSounds.masterGain);
      osc.start(t0); osc.stop(t0 + dur + 0.1);
      // Octave-below harmony
      const osc2 = ctx.createOscillator();
      osc2.type = 'triangle'; osc2.frequency.value = freq * 0.5;
      const g2 = ctx.createGain();
      g2.gain.setValueAtTime(0.05, t0);
      g2.gain.exponentialRampToValueAtTime(0.001, t0 + dur + 0.1);
      osc2.connect(g2); g2.connect(ambientSounds.masterGain);
      osc2.start(t0); osc2.stop(t0 + dur + 0.1);
      t += dur;
    });

  } else if (type === 'dig') {
    // Shovel hitting earth — noise + low thump
    const nLen = Math.ceil(ctx.sampleRate * 0.08);
    const nBuf = ctx.createBuffer(1, nLen, ctx.sampleRate);
    const nd = nBuf.getChannelData(0);
    for (let i = 0; i < nLen; i++) nd[i] = Math.random() * 2 - 1;
    const nSrc = ctx.createBufferSource();
    nSrc.buffer = nBuf;
    const nLP = ctx.createBiquadFilter();
    nLP.type = 'lowpass'; nLP.frequency.value = 500;
    const nG = ctx.createGain();
    nG.gain.setValueAtTime(0.08, now);
    nG.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
    nSrc.connect(nLP); nLP.connect(nG); nG.connect(ambientSounds.masterGain);
    nSrc.start(now); nSrc.stop(now + 0.08);
    // Earth thump
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(100, now);
    osc.frequency.exponentialRampToValueAtTime(40, now + 0.12);
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.07, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
    osc.connect(g); g.connect(ambientSounds.masterGain);
    osc.start(now); osc.stop(now + 0.15);

  } else if (type === 'metallic_hit') {
    // Shovel hitting iron — sharp metallic clang + resonance
    const mClang = ctx.createOscillator();
    mClang.type = 'square';
    mClang.frequency.setValueAtTime(800, now);
    mClang.frequency.exponentialRampToValueAtTime(200, now + 0.3);
    const mCG = ctx.createGain();
    mCG.gain.setValueAtTime(0.12, now);
    mCG.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
    mClang.connect(mCG); mCG.connect(ambientSounds.masterGain);
    mClang.start(now); mClang.stop(now + 0.4);
    // Metallic ring overtone
    const mRing = ctx.createOscillator();
    mRing.type = 'sine';
    mRing.frequency.value = 1200;
    const mRG = ctx.createGain();
    mRG.gain.setValueAtTime(0.06, now + 0.02);
    mRG.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
    mRing.connect(mRG); mRG.connect(ambientSounds.masterGain);
    mRing.start(now + 0.02); mRing.stop(now + 0.6);
    // Impact thud
    const mThud = ctx.createOscillator();
    mThud.type = 'sine';
    mThud.frequency.setValueAtTime(120, now);
    mThud.frequency.exponentialRampToValueAtTime(40, now + 0.1);
    const mTG = ctx.createGain();
    mTG.gain.setValueAtTime(0.08, now);
    mTG.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
    mThud.connect(mTG); mTG.connect(ambientSounds.masterGain);
    mThud.start(now); mThud.stop(now + 0.12);

  } else if (type === 'paper') {
    // Paper/letter unfolding — gentle crinkle
    const nLen = Math.ceil(ctx.sampleRate * 0.15);
    const nBuf = ctx.createBuffer(1, nLen, ctx.sampleRate);
    const nd = nBuf.getChannelData(0);
    for (let i = 0; i < nLen; i++) nd[i] = Math.random() * 2 - 1;
    const nSrc = ctx.createBufferSource();
    nSrc.buffer = nBuf;
    const nHP = ctx.createBiquadFilter();
    nHP.type = 'highpass'; nHP.frequency.value = 2500;
    const nG = ctx.createGain();
    nG.gain.setValueAtTime(0.04, now);
    nG.gain.linearRampToValueAtTime(0.06, now + 0.05);
    nG.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
    nSrc.connect(nHP); nHP.connect(nG); nG.connect(ambientSounds.masterGain);
    nSrc.start(now); nSrc.stop(now + 0.15);

  } else if (type === 'jade_reveal') {
    // Mystical jade discovery — singing bowl resonance + ascending crystal chimes
    // Deep resonance (singing bowl vibration)
    const bowl = ctx.createOscillator();
    bowl.type = 'sine'; bowl.frequency.value = 174;
    const bowlG = ctx.createGain();
    bowlG.gain.setValueAtTime(0, now);
    bowlG.gain.linearRampToValueAtTime(0.09, now + 0.8);
    bowlG.gain.setValueAtTime(0.09, now + 2.0);
    bowlG.gain.exponentialRampToValueAtTime(0.001, now + 4.0);
    bowl.connect(bowlG); bowlG.connect(ambientSounds.masterGain);
    bowl.start(now); bowl.stop(now + 4.0);
    // Harmonic overtone (perfect fifth)
    const harm = ctx.createOscillator();
    harm.type = 'sine'; harm.frequency.value = 261;
    const harmG = ctx.createGain();
    harmG.gain.setValueAtTime(0, now + 0.3);
    harmG.gain.linearRampToValueAtTime(0.05, now + 1.0);
    harmG.gain.exponentialRampToValueAtTime(0.001, now + 3.5);
    harm.connect(harmG); harmG.connect(ambientSounds.masterGain);
    harm.start(now + 0.3); harm.stop(now + 3.5);
    // Ascending crystal chimes (C5→E5→G5→C6)
    [523, 659, 784, 1047].forEach((freq, i) => {
      const t0 = now + 0.5 + i * 0.3;
      const osc = ctx.createOscillator();
      osc.type = 'sine'; osc.frequency.value = freq;
      const g = ctx.createGain();
      g.gain.setValueAtTime(0.07 - i * 0.01, t0);
      g.gain.exponentialRampToValueAtTime(0.001, t0 + 1.2);
      osc.connect(g); g.connect(ambientSounds.masterGain);
      osc.start(t0); osc.stop(t0 + 1.2);
    });
    // Cave resonance (stone vibrating — filtered noise)
    const rnLen = Math.ceil(ctx.sampleRate * 3.0);
    const rnBuf = ctx.createBuffer(1, rnLen, ctx.sampleRate);
    const rnd = rnBuf.getChannelData(0);
    for (let i = 0; i < rnLen; i++) rnd[i] = Math.random() * 2 - 1;
    const rnSrc = ctx.createBufferSource();
    rnSrc.buffer = rnBuf;
    const rnBP = ctx.createBiquadFilter();
    rnBP.type = 'bandpass'; rnBP.frequency.value = 200; rnBP.Q.value = 8;
    const rnG = ctx.createGain();
    rnG.gain.setValueAtTime(0, now);
    rnG.gain.linearRampToValueAtTime(0.025, now + 1.0);
    rnG.gain.setValueAtTime(0.025, now + 2.0);
    rnG.gain.exponentialRampToValueAtTime(0.001, now + 3.5);
    rnSrc.connect(rnBP); rnBP.connect(rnG); rnG.connect(ambientSounds.masterGain);
    rnSrc.start(now); rnSrc.stop(now + 3.5);
  }
}

// ── TAVERNA AMBIENT SOUNDS (glass clink, cutlery, crowd murmur) ──
function playTavernaGlassClink() {
  const ac = getAudioCtx();
  if (!ac || !state.musicOn) return;
  const now = ac.currentTime;
  const freq = 2800 + Math.random() * 1200;
  const osc = ac.createOscillator();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(freq, now);
  osc.frequency.exponentialRampToValueAtTime(freq * 0.7, now + 0.12);
  const g = ac.createGain();
  g.gain.setValueAtTime(0.04 + Math.random() * 0.02, now);
  g.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
  osc.connect(g); g.connect(ambientSounds.masterGain);
  osc.start(now); osc.stop(now + 0.15);
  const osc2 = ac.createOscillator();
  osc2.type = 'sine';
  osc2.frequency.setValueAtTime(freq * 1.5, now + 0.01);
  osc2.frequency.exponentialRampToValueAtTime(freq, now + 0.1);
  const g2 = ac.createGain();
  g2.gain.setValueAtTime(0.02, now + 0.01);
  g2.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
  osc2.connect(g2); g2.connect(ambientSounds.masterGain);
  osc2.start(now + 0.01); osc2.stop(now + 0.12);
}

function playTavernaCutlery() {
  const ac = getAudioCtx();
  if (!ac || !state.musicOn) return;
  const now = ac.currentTime;
  const freq = 1200 + Math.random() * 800;
  const osc = ac.createOscillator();
  osc.type = 'triangle';
  osc.frequency.setValueAtTime(freq, now);
  osc.frequency.exponentialRampToValueAtTime(freq * 0.5, now + 0.06);
  const g = ac.createGain();
  g.gain.setValueAtTime(0.03, now);
  g.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
  osc.connect(g); g.connect(ambientSounds.masterGain);
  osc.start(now); osc.stop(now + 0.08);
}

function createTavernaMurmurLoop() {
  const ac = getAudioCtx();
  if (!ac) return null;
  const len = ac.sampleRate * 2;
  const buf = ac.createBuffer(1, len, ac.sampleRate);
  const d = buf.getChannelData(0);
  let last = 0;
  for (let i = 0; i < len; i++) {
    const white = Math.random() * 2 - 1;
    last = (last + 0.02 * white) / 1.02;
    d[i] = last * 3.5;
  }
  const src = ac.createBufferSource();
  src.buffer = buf;
  src.loop = true;
  const bp = ac.createBiquadFilter();
  bp.type = 'bandpass';
  bp.frequency.value = 350;
  bp.Q.value = 0.8;
  const gain = ac.createGain();
  gain.gain.value = 0.035;
  src.connect(bp); bp.connect(gain); gain.connect(ambientSounds.masterGain);
  src.start();
  return { src, gain };
}

function playTavernaSound() {
  if (Math.random() < 0.5) playTavernaGlassClink();
  else playTavernaCutlery();
}

// ── Festival crowd ambient system ──
function createCrowdLoop() {
  const ac = getAudioCtx();
  if (!ac) return null;
  // Longer buffer for natural crowd variation
  const len = ac.sampleRate * 6;
  const buf = ac.createBuffer(2, len, ac.sampleRate); // stereo for width
  // Generate brownian noise base for each channel
  for (let ch = 0; ch < 2; ch++) {
    const d = buf.getChannelData(ch);
    let last = 0;
    for (let i = 0; i < len; i++) {
      const white = Math.random() * 2 - 1;
      last = (last + 0.02 * white) / 1.02;
      // Add slow volume swell to simulate crowd conversation ebb and flow
      const swell = 0.6 + 0.4 * Math.sin(i / ac.sampleRate * Math.PI * 0.25 + ch * 1.2);
      d[i] = last * 4 * swell;
    }
  }
  const src = ac.createBufferSource();
  src.buffer = buf;
  src.loop = true;
  // Layer 1: male voice range (200-500Hz)
  const bpLow = ac.createBiquadFilter();
  bpLow.type = 'bandpass';
  bpLow.frequency.value = 320;
  bpLow.Q.value = 0.6;
  const gainLow = ac.createGain();
  gainLow.gain.value = 1.0;
  // Layer 2: female voice range (400-900Hz)
  const bpMid = ac.createBiquadFilter();
  bpMid.type = 'bandpass';
  bpMid.frequency.value = 600;
  bpMid.Q.value = 0.5;
  const gainMid = ac.createGain();
  gainMid.gain.value = 0.7;
  // Layer 3: children/bright layer (800-1600Hz)
  const bpHi = ac.createBiquadFilter();
  bpHi.type = 'bandpass';
  bpHi.frequency.value = 1100;
  bpHi.Q.value = 0.7;
  const gainHi = ac.createGain();
  gainHi.gain.value = 0.3;
  // Slow LFO modulation — makes it "breathe" like a real crowd
  const lfo = ac.createOscillator();
  lfo.type = 'sine';
  lfo.frequency.value = 0.12; // very slow
  const lfoGain = ac.createGain();
  lfoGain.gain.value = 0.3;
  lfo.connect(lfoGain);
  lfoGain.connect(gainLow.gain);
  lfoGain.connect(gainMid.gain);
  // Master gain for the crowd
  const masterG = ac.createGain();
  masterG.gain.value = 0.08;
  // Wire up: src → three bandpass layers → merge → master
  src.connect(bpLow); bpLow.connect(gainLow); gainLow.connect(masterG);
  src.connect(bpMid); bpMid.connect(gainMid); gainMid.connect(masterG);
  src.connect(bpHi);  bpHi.connect(gainHi);  gainHi.connect(masterG);
  masterG.connect(ambientSounds.masterGain);
  src.start();
  lfo.start();
  return { src, gain: masterG, lfo };
}

function playCrowdCheer() {
  const ac = getAudioCtx();
  if (!ac) return;
  const now = ac.currentTime;
  // Short burst of crowd cheer — rising pitch noise + harmonic overtones
  const len = ac.sampleRate * 2;
  const buf = ac.createBuffer(2, len, ac.sampleRate);
  for (let ch = 0; ch < 2; ch++) {
    const d = buf.getChannelData(ch);
    let last = 0;
    for (let i = 0; i < len; i++) {
      const t = i / ac.sampleRate;
      const white = Math.random() * 2 - 1;
      last = (last + 0.03 * white) / 1.03;
      // Envelope: quick rise, sustain, decay
      let env = 0;
      if (t < 0.15) env = t / 0.15;
      else if (t < 1.2) env = 1.0;
      else env = Math.max(0, 1.0 - (t - 1.2) / 0.8);
      // Add some tonal content (excited voices)
      const vocal = Math.sin(t * 420 * Math.PI * 2 + ch) * 0.15
                   + Math.sin(t * 680 * Math.PI * 2 + ch * 0.5) * 0.1
                   + Math.sin(t * 900 * Math.PI * 2) * 0.05;
      d[i] = (last * 4 + vocal) * env;
    }
  }
  const src = ac.createBufferSource();
  src.buffer = buf;
  const bp = ac.createBiquadFilter();
  bp.type = 'bandpass';
  bp.frequency.value = 500 + Math.random() * 300;
  bp.Q.value = 0.4;
  const gain = ac.createGain();
  gain.gain.setValueAtTime(0, now);
  gain.gain.linearRampToValueAtTime(0.06 + Math.random() * 0.03, now + 0.15);
  gain.gain.setValueAtTime(0.06, now + 1.2);
  gain.gain.linearRampToValueAtTime(0, now + 2.0);
  src.connect(bp); bp.connect(gain); gain.connect(ambientSounds.masterGain);
  src.start(now);
  src.stop(now + 2.0);
}

function playCrowdClap() {
  const ac = getAudioCtx();
  if (!ac) return;
  const now = ac.currentTime;
  // Series of quick noise bursts simulating scattered clapping
  const clapCount = 5 + Math.floor(Math.random() * 8);
  for (let c = 0; c < clapCount; c++) {
    const t = now + c * (0.08 + Math.random() * 0.12);
    const len = Math.floor(ac.sampleRate * 0.04);
    const buf = ac.createBuffer(1, len, ac.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < len; i++) {
      const env = Math.exp(-i / (ac.sampleRate * 0.008));
      d[i] = (Math.random() * 2 - 1) * env;
    }
    const src = ac.createBufferSource();
    src.buffer = buf;
    const hp = ac.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 1200 + Math.random() * 800;
    const gain = ac.createGain();
    gain.gain.value = 0.025 + Math.random() * 0.02;
    src.connect(hp); hp.connect(gain); gain.connect(ambientSounds.masterGain);
    src.start(t);
    src.stop(t + 0.05);
  }
}

function playCrowdSound() {
  const r = Math.random();
  if (r < 0.5) playCrowdCheer();
  else playCrowdClap();
}

function initAmbientSound() {
  ambientSounds.gullTimer = 0;
  ambientSounds.gullInterval = 8 + Math.random() * 7;
}

function startSceneAmbience(sceneId) {
  stopSceneAmbience();
  const cfg = sceneAmbientConfig[sceneId];
  if (!cfg) return;
  ambientSounds.currentScene = sceneId;
  try {
    // Waves layer
    if (cfg.waves) {
      ambientSounds.wavesNode = createWavesLoop();
      ambientSounds.wavesNode.gain.gain.value = cfg.waves;
    }
    // Wind layer
    if (cfg.wind) {
      ambientSounds.windNode = createWindLoop(cfg.wind);
    }
    // Seagull timer
    if (cfg.gulls) {
      ambientSounds.gullTimer = 0;
      ambientSounds.gullInterval = cfg.gullFreq[0] + Math.random() * cfg.gullFreq[1];
    }
    // Cave drips — periodic random drips
    if (cfg.drips) {
      const dripFn = () => {
        playCaveDrip();
        ambientSounds.dripsInterval = setTimeout(dripFn, 1500 + Math.random() * 3000);
      };
      ambientSounds.dripsInterval = setTimeout(dripFn, 500 + Math.random() * 1000);
    }
    // Cicadas layer
    if (cfg.cicadas) {
      ambientSounds.cicadasNode = createCicadasLoop();
      ambientSounds.cicadasNode.gain.gain.value = cfg.cicadas;
    }
    // Church bell — plays on entry for bell-enabled scenes, then periodically
    if (cfg.bell) {
      ambientSounds.bellTimer = 0;
      ambientSounds.bellInterval = cfg.bellFreq[0] + Math.random() * cfg.bellFreq[1];
      // Bell on scene entry (with short delay)
      const entryDelay = (sceneId === 'church' || sceneId === 'church_interior' || sceneId === 'graveyard') ? 1500 : 3000;
      setTimeout(() => playChurchBell(), entryDelay);
    }
    // Taverna sounds — murmur loop + periodic glass/cutlery
    if (cfg.taverna) {
      ambientSounds.tavernaNode = createTavernaMurmurLoop();
      ambientSounds.tavernaTimer = 0;
      ambientSounds.tavernaInterval = cfg.tavernaFreq[0] + Math.random() * cfg.tavernaFreq[1];
      // Initial clink on entry
      setTimeout(() => playTavernaGlassClink(), 1500);
    }
    // Festival crowd — murmur loop + periodic cheers/claps
    if (cfg.crowd) {
      ambientSounds.crowdNode = createCrowdLoop();
      if (ambientSounds.crowdNode && cfg.crowdVol) {
        ambientSounds.crowdNode.gain.gain.value = cfg.crowdVol;
      }
      ambientSounds.crowdTimer = 0;
      ambientSounds.crowdInterval = cfg.crowdFreq[0] + Math.random() * cfg.crowdFreq[1];
      // Initial cheer on scene entry (delayed for dramatic effect)
      setTimeout(() => playCrowdCheer(), 2000);
    }
  } catch (e) { /* Web Audio not available */ }
  // Visual ambience
  if (sceneId === 'exterior' || sceneId === 'terrace') {
    initBoatBob();
    initPetals();
  }
  ambientSounds.active = true;
}

function stopSceneAmbience() {
  if (ambientSounds.wavesNode) {
    try { ambientSounds.wavesNode.src.stop(); } catch (e) {}
    ambientSounds.wavesNode = null;
  }
  if (ambientSounds.windNode) {
    try { ambientSounds.windNode.src.stop(); } catch (e) {}
    ambientSounds.windNode = null;
  }
  if (ambientSounds.cicadasNode) {
    try {
      for (const o of ambientSounds.cicadasNode.oscs) { o.osc.stop(); o.lfo.stop(); }
    } catch (e) {}
    ambientSounds.cicadasNode = null;
  }
  if (ambientSounds.dripsInterval) {
    clearTimeout(ambientSounds.dripsInterval);
    ambientSounds.dripsInterval = null;
  }
  if (ambientSounds.tavernaNode) {
    try { ambientSounds.tavernaNode.src.stop(); } catch (e) {}
    ambientSounds.tavernaNode = null;
  }
  if (ambientSounds.crowdNode) {
    try {
      ambientSounds.crowdNode.src.stop();
      if (ambientSounds.crowdNode.lfo) ambientSounds.crowdNode.lfo.stop();
    } catch (e) {}
    ambientSounds.crowdNode = null;
  }
  boatCutout = null;
  boatWaterPatch = null;
  petals.length = 0;
  ambientSounds.active = false;
  ambientSounds.currentScene = null;
}

function updateAmbientSound(dt) {
  if (!ambientSounds.active) return;
  const cfg = sceneAmbientConfig[state.scene];
  if (!cfg) return;
  // Seagull timer
  if (cfg.gulls) {
    ambientSounds.gullTimer += dt;
    if (ambientSounds.gullTimer >= ambientSounds.gullInterval) {
      ambientSounds.gullTimer = 0;
      ambientSounds.gullInterval = cfg.gullFreq[0] + Math.random() * cfg.gullFreq[1];
      playSeagullCry();
    }
  }
  // Church bell timer — periodic distant tolls
  if (cfg.bell) {
    ambientSounds.bellTimer += dt;
    if (ambientSounds.bellTimer >= ambientSounds.bellInterval) {
      ambientSounds.bellTimer = 0;
      ambientSounds.bellInterval = cfg.bellFreq[0] + Math.random() * cfg.bellFreq[1];
      playChurchBell();
    }
  }
  // Taverna sounds — periodic glass clinks & cutlery
  if (cfg.taverna) {
    ambientSounds.tavernaTimer += dt;
    if (ambientSounds.tavernaTimer >= ambientSounds.tavernaInterval) {
      ambientSounds.tavernaTimer = 0;
      ambientSounds.tavernaInterval = cfg.tavernaFreq[0] + Math.random() * cfg.tavernaFreq[1];
      playTavernaSound();
    }
  }
  // Festival crowd — periodic cheers & claps
  if (cfg.crowd) {
    ambientSounds.crowdTimer += dt;
    if (ambientSounds.crowdTimer >= ambientSounds.crowdInterval) {
      ambientSounds.crowdTimer = 0;
      ambientSounds.crowdInterval = cfg.crowdFreq[0] + Math.random() * cfg.crowdFreq[1];
      playCrowdSound();
    }
  }
}

// ── Master draw/update for scene ambience ──
function updateSceneAmbience(dt) {
  updateAmbientSound(dt);
  if (state.scene === 'exterior') {
    updateBoatBob(dt);
    updatePetals();
  }
}

function drawSceneAmbience(tick) {
  if (state.scene === 'exterior') {
    drawBoatBob();
    drawSeaShimmer(tick);
    drawLightShaft(tick);
    drawPetals();
    drawHeatHaze(tick);
  } else if (state.scene === 'terrace') {
    drawSeaShimmer(tick);
    drawLightShaft(tick);
  } else if (state.scene === 'cave') {
    drawCaveAmbience(tick);
  } else if (state.scene === 'kitchen') {
    drawKitchenAmbience(tick);
  } else if (state.scene === 'museum') {
    drawMuseumAmbience(tick);
  } else if (state.scene === 'liotrivi') {
    drawLiotriviAmbience(tick);
  } else if (state.scene === 'windmill') {
    drawWindmillAmbience(tick);
  } else if (state.scene === 'graveyard') {
    drawGraveyardAmbience(tick);
  } else if (state.scene === 'church') {
    drawChurchExteriorAmbience(tick);
  } else if (state.scene === 'church_interior') {
    drawChurchAmbience(tick);
  } else if (state.scene === 'boat') {
    drawBoatAmbience(tick);
  } else if (state.scene === 'treasure') {
    drawTreasureAmbience(tick);
  }
}

// Treasure island ambience: sea shimmer + warm light
function drawTreasureAmbience(tick) {
  ctx.save();
  for (let i = 0; i < 8; i++) {
    const ph = tick * 0.02 + i * 1.8;
    const a = 0.07 + Math.sin(ph * 1.3) * 0.05;
    if (a > 0) {
      ctx.globalAlpha = a;
      ctx.fillStyle = '#b8d4e8';
      ctx.fillRect(60 + Math.sin(ph * 0.7 + i) * 240, 160 + Math.sin(ph) * 12, 2, 1);
    }
  }
  ctx.restore();
}

// Kitchen ambience: steam, lamp flicker, dust in window light
function drawKitchenAmbience(tick) {
  ctx.save();
  // ── STEAM from pot area (left side, near fireplace) ──
  for (let i = 0; i < 4; i++) {
    const phase = tick * 0.015 + i * 1.7;
    const rise = (tick * 0.4 + i * 30) % 120;
    const sy = 140 - rise;
    if (sy > 20) {
      const sx = 45 + Math.sin(phase) * 8 + i * 12;
      const alpha = Math.max(0, 0.08 - rise * 0.0007);
      const size = 3 + rise * 0.03;
      ctx.fillStyle = `rgba(220,220,230,${alpha})`;
      ctx.beginPath();
      ctx.arc(sx, sy, size, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  // ── WARM LAMP FLICKER (golden glow near ceiling area) ──
  const lampFlicker = Math.sin(tick * 0.12) * 0.015 + Math.sin(tick * 0.19) * 0.008;
  ctx.fillStyle = `rgba(255,200,100,${0.03 + lampFlicker})`;
  ctx.fillRect(250, 40, 180, 120);
  // ── DUST MOTES in window light beam ──
  for (let d = 0; d < 6; d++) {
    const dx = 470 + Math.sin(tick * 0.008 + d * 2.1) * 40;
    const dy = 10 + Math.sin(tick * 0.006 + d * 1.8) * 80 + d * 15;
    const da = Math.sin(tick * 0.03 + d * 2.7);
    if (da > 0.3 && dx > 440 && dx < 560) {
      ctx.fillStyle = `rgba(255,220,140,${da * 0.12})`;
      ctx.fillRect(dx, dy, 1, 1);
    }
  }
  ctx.restore();
}

// Museum ambience: old nautical chart, dust motes, display case glow, subtle flicker
function drawMuseumAmbience(tick) {
  ctx.save();

  // ── OLD NAUTICAL MAP of Corinthian Gulf on the wall ──
  const mx = 478, my = 108, mw = 122, mh = 140;
  // Parchment background
  ctx.fillStyle = '#D4C4A0';
  ctx.fillRect(mx, my, mw, mh);
  // Aged border / frame
  ctx.strokeStyle = '#6B5332';
  ctx.lineWidth = 2;
  ctx.strokeRect(mx, my, mw, mh);
  ctx.strokeStyle = '#8B7352';
  ctx.lineWidth = 1;
  ctx.strokeRect(mx + 3, my + 3, mw - 6, mh - 6);
  // Parchment stain/aging
  ctx.fillStyle = 'rgba(139,115,82,0.12)';
  ctx.fillRect(mx + 20, my + 30, 60, 50);
  ctx.fillStyle = 'rgba(139,115,82,0.08)';
  ctx.fillRect(mx + 8, my + 70, 40, 35);
  // Coastline — simplified Corinthian Gulf
  ctx.strokeStyle = '#5A4228';
  ctx.lineWidth = 1;
  ctx.beginPath();
  // North coast (mainland)
  ctx.moveTo(mx + 5, my + 45);
  ctx.lineTo(mx + 25, my + 42);
  ctx.lineTo(mx + 45, my + 50);
  ctx.lineTo(mx + 65, my + 44);
  ctx.lineTo(mx + 90, my + 48);
  ctx.lineTo(mx + 117, my + 42);
  ctx.stroke();
  // South coast (Peloponnese)
  ctx.beginPath();
  ctx.moveTo(mx + 5, my + 85);
  ctx.lineTo(mx + 30, my + 90);
  ctx.lineTo(mx + 55, my + 82);
  ctx.lineTo(mx + 80, my + 88);
  ctx.lineTo(mx + 100, my + 82);
  ctx.lineTo(mx + 117, my + 86);
  ctx.stroke();
  // Gulf water (light blue wash)
  ctx.fillStyle = 'rgba(100,140,180,0.12)';
  ctx.fillRect(mx + 6, my + 48, mw - 12, 34);
  // Galaxidi marker — small red dot
  ctx.fillStyle = '#8B2020';
  ctx.beginPath();
  ctx.arc(mx + 50, my + 78, 2, 0, Math.PI * 2);
  ctx.fill();
  // "ΓΑΛΑΞΕΙΔΙ" label tiny
  ctx.fillStyle = '#5A3018';
  ctx.font = '4px serif';
  ctx.fillText('ΓΑΛΑΞΕΙΔΙ', mx + 37, my + 76);
  // Navigation routes (dotted lines in ink)
  ctx.strokeStyle = 'rgba(90,66,40,0.4)';
  ctx.setLineDash([2, 2]);
  ctx.beginPath();
  ctx.moveTo(mx + 50, my + 78); // from Galaxidi
  ctx.lineTo(mx + 20, my + 60); // west route
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(mx + 50, my + 78);
  ctx.lineTo(mx + 95, my + 60); // east route
  ctx.stroke();
  ctx.setLineDash([]);
  // Compass rose (simple)
  const cx = mx + 95, cy = my + 115;
  ctx.strokeStyle = '#6B5332';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(cx, cy - 8); ctx.lineTo(cx, cy + 8); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx - 8, cy); ctx.lineTo(cx + 8, cy); ctx.stroke();
  // N indicator
  ctx.fillStyle = '#5A3018';
  ctx.font = '5px serif';
  ctx.fillText('B', cx - 2, cy - 10); // Β = Βορράς (North in Greek)
  // Title at top
  ctx.fillStyle = '#4A3218';
  ctx.font = '5px serif';
  ctx.fillText('ΚΟΡΙΝΘΙΑΚΟΣ ΚΟΛΠΟΣ', mx + 15, my + 14);
  // Ink date
  ctx.fillStyle = 'rgba(90,66,40,0.5)';
  ctx.font = '4px serif';
  ctx.fillText('1858', mx + mw - 22, my + mh - 6);

  // ── FLOATING DUST MOTES (dim, slow) ──
  for (let d = 0; d < 10; d++) {
    const dx = 50 + Math.sin(tick * 0.005 + d * 3.2) * 280;
    const dy = 30 + Math.sin(tick * 0.004 + d * 2.5) * 160 + d * 18;
    const da = Math.sin(tick * 0.025 + d * 1.9);
    if (da > 0.2) {
      ctx.fillStyle = `rgba(200,180,140,${da * 0.08})`;
      ctx.fillRect(dx, dy, 1, 1);
    }
  }
  // ── WARM GLOW near display cases ──
  const glow1 = Math.sin(tick * 0.01) * 0.005 + 0.025;
  ctx.fillStyle = `rgba(255,210,120,${glow1})`;
  ctx.fillRect(30, 50, 160, 130);
  const glow2 = Math.sin(tick * 0.012 + 1.5) * 0.005 + 0.025;
  ctx.fillStyle = `rgba(255,210,120,${glow2})`;
  ctx.fillRect(390, 50, 160, 130);
  // ── SUBTLE WHOLE-SCENE FLICKER (very faint) ──
  const flicker = Math.sin(tick * 0.07) * 0.004;
  if (flicker > 0) {
    ctx.fillStyle = `rgba(255,240,200,${flicker})`;
    ctx.fillRect(0, 0, GW, GH);
  }
  ctx.restore();
}

// Liotrivi ambience: god-rays through windows, golden dust, wood glow
function drawLiotriviAmbience(tick) {
  ctx.save();
  // ── GOLDEN GOD-RAYS through window ──
  for (let r = 0; r < 3; r++) {
    const phase = tick * 0.006 + r * 1.5;
    const alpha = (Math.sin(phase) * 0.5 + 0.5) * 0.04 + 0.02;
    const ox = r * 35;
    ctx.fillStyle = `rgba(255,200,80,${alpha})`;
    ctx.beginPath();
    ctx.moveTo(440 + ox, 0);
    ctx.lineTo(420 + ox, 0);
    ctx.lineTo(350 + ox, 300);
    ctx.lineTo(380 + ox, 300);
    ctx.closePath();
    ctx.fill();
  }
  // ── GOLDEN DUST PARTICLES in light beams ──
  for (let d = 0; d < 8; d++) {
    const dx = 360 + Math.sin(tick * 0.009 + d * 2.3) * 80;
    const dy = 20 + Math.sin(tick * 0.007 + d * 1.6) * 140 + d * 15;
    const da = Math.sin(tick * 0.035 + d * 2.8);
    if (da > 0.25 && dx > 340 && dx < 520) {
      ctx.fillStyle = `rgba(220,180,80,${da * 0.12})`;
      ctx.fillRect(dx, dy, 1, 1);
    }
  }
  // ── WARM WOOD GLOW at edges ──
  const edgeGlow = Math.sin(tick * 0.008) * 0.008 + 0.025;
  const lg = ctx.createLinearGradient(0, 0, 80, 0);
  lg.addColorStop(0, `rgba(180,120,40,${edgeGlow})`);
  lg.addColorStop(1, 'rgba(180,120,40,0)');
  ctx.fillStyle = lg;
  ctx.fillRect(0, 0, 80, GH);
  const rg = ctx.createLinearGradient(GW, 0, GW - 80, 0);
  rg.addColorStop(0, `rgba(180,120,40,${edgeGlow})`);
  rg.addColorStop(1, 'rgba(180,120,40,0)');
  ctx.fillStyle = rg;
  ctx.fillRect(GW - 80, 0, 80, GH);
  ctx.restore();
}

// Windmill ambience: wind particles, mill shadow sweep, distant sea sparkle
function drawWindmillAmbience(tick) {
  ctx.save();
  // ── WIND PARTICLES (horizontal flowing specs) ──
  for (let w = 0; w < 10; w++) {
    const wx = (tick * 1.2 + w * 67) % (GW + 40) - 20;
    const wy = 60 + (w * 41) % 280 + Math.sin(tick * 0.02 + w) * 8;
    const wa = Math.sin(tick * 0.03 + w * 2.1) * 0.5 + 0.5;
    if (wa > 0.3) {
      ctx.fillStyle = `rgba(255,255,240,${wa * 0.06})`;
      ctx.fillRect(wx, wy, 3 + Math.floor(wa * 2), 1);
    }
  }
  // ── ROTATING MILL SHADOW (subtle sweeping band) ──
  const shadowAngle = tick * 0.003;
  const shadowX = GW * 0.5 + Math.cos(shadowAngle) * GW * 0.4;
  const shadowW = 40 + Math.sin(shadowAngle * 2) * 15;
  const shadowA = (Math.sin(shadowAngle + 0.5) * 0.5 + 0.5) * 0.03;
  ctx.fillStyle = `rgba(0,0,0,${shadowA})`;
  ctx.fillRect(shadowX - shadowW / 2, 0, shadowW, GH);
  // ── DISTANT SEA SPARKLE (lower portion of panorama) ──
  for (let s = 0; s < 6; s++) {
    const sx = 80 + (s * 97) % 480;
    const sy = 5 + (s * 23) % 30;
    const sparkle = Math.sin(tick * 0.06 + s * 3.3);
    if (sparkle > 0.6) {
      ctx.fillStyle = `rgba(255,255,220,${(sparkle - 0.6) * 0.3})`;
      ctx.fillRect(sx, sy, 2, 1);
    }
  }
  ctx.restore();
}

// Graveyard ambience: fireflies, mist, moonlight rays, cypress shadow sway
function drawGraveyardAmbience(tick) {
  ctx.save();
  // ── FIREFLIES (yellow-green pulsing dots) ──
  for (let f = 0; f < 8; f++) {
    const fx = 80 + Math.sin(tick * 0.006 + f * 2.7) * 200 + f * 50;
    const fy = 180 + Math.sin(tick * 0.005 + f * 1.9) * 80;
    const fa = Math.sin(tick * 0.08 + f * 2.3) * 0.5 + 0.5;
    if (fa > 0.3) {
      ctx.fillStyle = `rgba(180,220,80,${fa * 0.15})`;
      ctx.fillRect(fx, fy, 2, 2);
      // Soft glow around firefly
      ctx.fillStyle = `rgba(180,220,80,${fa * 0.04})`;
      ctx.fillRect(fx - 3, fy - 3, 8, 8);
    }
  }
  // ── GROUND MIST (low-alpha white undulating at ground level) ──
  for (let mx = 0; mx < GW; mx += 8) {
    const mistH = 15 + Math.sin(tick * 0.01 + mx * 0.02) * 5;
    const mistA = 0.03 + Math.sin(tick * 0.008 + mx * 0.03) * 0.015;
    ctx.fillStyle = `rgba(200,210,230,${mistA})`;
    ctx.fillRect(mx, GH - 60 - mistH, 8, mistH);
  }
  // ── MOONLIGHT RAYS (cold blue-white diagonal shafts) ──
  for (let r = 0; r < 3; r++) {
    const phase = tick * 0.005 + r * 2.0;
    const alpha = (Math.sin(phase) * 0.5 + 0.5) * 0.035 + 0.015;
    const ox = r * 80 + 100;
    ctx.fillStyle = `rgba(180,200,240,${alpha})`;
    ctx.beginPath();
    ctx.moveTo(ox, 0);
    ctx.lineTo(ox + 25, 0);
    ctx.lineTo(ox - 60, GH * 0.7);
    ctx.lineTo(ox - 85, GH * 0.7);
    ctx.closePath();
    ctx.fill();
  }
  // ── CYPRESS SHADOW SWAY ──
  const sway = Math.sin(tick * 0.01) * 3;
  ctx.fillStyle = 'rgba(0,0,20,0.03)';
  ctx.fillRect(5 + sway, 0, 40, 300);
  ctx.restore();
}

// Church ambience: candle flicker, incense wisps, stained glass light, dust
// Church EXTERIOR ambience: stone fountain with animated water, warm plaza light
function drawChurchExteriorAmbience(tick) {
  ctx.save();
  // ── STONE FOUNTAIN (centered ~x:130, base at y:345) ──
  const fx = 130, fy = 345;
  // Base platform
  ctx.fillStyle = '#7A6C5A';
  ctx.fillRect(fx - 22, fy, 44, 6);
  ctx.fillStyle = '#8B7D6B';
  ctx.fillRect(fx - 18, fy - 3, 36, 3);
  // Lower basin
  ctx.fillStyle = '#6A5C4A';
  ctx.fillRect(fx - 16, fy - 14, 32, 11);
  ctx.fillStyle = '#7A6C5A';
  ctx.fillRect(fx - 14, fy - 12, 28, 8);
  // Basin rim highlight
  ctx.fillStyle = '#9A8C7A';
  ctx.fillRect(fx - 16, fy - 15, 32, 2);
  // Central column
  ctx.fillStyle = '#8B7D6B';
  ctx.fillRect(fx - 3, fy - 30, 6, 16);
  ctx.fillStyle = '#9A8C7A';
  ctx.fillRect(fx - 2, fy - 28, 4, 14);
  // Upper small bowl
  ctx.fillStyle = '#7A6C5A';
  ctx.fillRect(fx - 8, fy - 34, 16, 4);
  ctx.fillStyle = '#9A8C7A';
  ctx.fillRect(fx - 7, fy - 35, 14, 2);
  // Finial knob
  ctx.fillStyle = '#8B7D6B';
  ctx.fillRect(fx - 2, fy - 38, 4, 3);
  ctx.fillRect(fx - 1, fy - 39, 2, 1);
  // Water in lower basin (shimmering)
  const wa = 0.35 + Math.sin(tick * 0.04) * 0.08;
  ctx.fillStyle = `rgba(100,160,210,${wa})`;
  ctx.fillRect(fx - 13, fy - 10, 26, 5);
  // Water shimmer highlight
  const ha = 0.15 + Math.sin(tick * 0.07 + 1) * 0.08;
  ctx.fillStyle = `rgba(180,220,255,${ha})`;
  ctx.fillRect(fx - 8 + Math.sin(tick * 0.02) * 3, fy - 9, 8, 1);
  // Water drops falling from upper bowl
  for (let d = 0; d < 4; d++) {
    const dp = (tick * 0.06 + d * 1.6) % 2.5;
    const dy = fy - 30 + dp * 7;
    const dx = fx - 3 + d * 2 + Math.sin(tick * 0.04 + d * 1.5) * 2;
    if (dy < fy - 14) {
      const da = 0.5 - dp * 0.15;
      ctx.fillStyle = `rgba(150,200,240,${Math.max(0, da)})`;
      ctx.fillRect(dx, dy, 1, 2);
    }
  }
  // Tiny splash sparkles at water surface
  for (let s = 0; s < 3; s++) {
    const sp = (tick * 0.08 + s * 1.3) % 2;
    if (sp < 0.3) {
      const sx = fx - 10 + Math.sin(tick * 0.12 + s * 2.7) * 10;
      ctx.fillStyle = `rgba(220,240,255,${0.4 - sp})`;
      ctx.fillRect(sx, fy - 11, 1, 1);
    }
  }
  // ── WARM PLAZA LIGHT (golden hour glow on cobblestones) ──
  const glow = 0.02 + Math.sin(tick * 0.003) * 0.005;
  ctx.fillStyle = `rgba(255,200,120,${glow})`;
  ctx.fillRect(50, 300, 200, 80);
  // ── LIGHT SHAFT from church door ──
  const la = 0.025 + Math.sin(tick * 0.005) * 0.008;
  ctx.fillStyle = `rgba(255,220,160,${la})`;
  ctx.beginPath();
  ctx.moveTo(270, 200);
  ctx.lineTo(220, 370);
  ctx.lineTo(350, 370);
  ctx.lineTo(340, 200);
  ctx.fill();
  ctx.restore();
}

// Church INTERIOR ambience: candle flicker, incense, stained glass
function drawChurchAmbience(tick) {
  ctx.save();
  // ── CANDLE FLAME FLICKER (warm glow points) ──
  const candles = [{x: 230, y: 200}, {x: 290, y: 195}, {x: 260, y: 210}];
  candles.forEach((c, i) => {
    const flicker = Math.sin(tick * 0.18 + i * 2.5) * 0.03
                  + Math.sin(tick * 0.27 + i * 3.8) * 0.015;
    ctx.fillStyle = `rgba(255,200,100,${0.04 + flicker})`;
    ctx.fillRect(c.x - 15, c.y - 12, 30, 24);
    ctx.fillStyle = `rgba(255,220,140,${0.07 + flicker * 1.5})`;
    ctx.fillRect(c.x - 4, c.y - 4, 8, 8);
  });
  // ── INCENSE SMOKE (translucent wisps rising) ──
  for (let s = 0; s < 3; s++) {
    const rise = (tick * 0.3 + s * 45) % 140;
    const sy = 200 - rise;
    if (sy > 30) {
      const sx = 260 + Math.sin(tick * 0.012 + s * 2.1) * 20 + s * 15;
      const alpha = Math.max(0, 0.04 - rise * 0.0003);
      ctx.fillStyle = `rgba(200,200,220,${alpha})`;
      ctx.beginPath();
      ctx.arc(sx, sy, 4 + rise * 0.02, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  // ── STAINED GLASS LIGHT PATCHES (warm colored patches on ground) ──
  const glassPhase = tick * 0.004;
  const ga = Math.sin(glassPhase) * 0.01 + 0.03;
  ctx.fillStyle = `rgba(255,160,80,${ga})`;
  ctx.fillRect(150 + Math.sin(glassPhase) * 5, 280, 60, 40);
  ctx.fillStyle = `rgba(200,100,100,${ga * 0.8})`;
  ctx.fillRect(330 + Math.sin(glassPhase + 1) * 5, 290, 50, 35);
  // ── DUST MOTES in light ──
  for (let d = 0; d < 5; d++) {
    const dx = 180 + Math.sin(tick * 0.007 + d * 2.6) * 100;
    const dy = 120 + Math.sin(tick * 0.005 + d * 1.7) * 100;
    const da = Math.sin(tick * 0.03 + d * 2.2);
    if (da > 0.35) {
      ctx.fillStyle = `rgba(255,230,180,${da * 0.08})`;
      ctx.fillRect(dx, dy, 1, 1);
    }
  }
  ctx.restore();
}

// Boat ambience: sea spray, gentle rocking, seagull silhouettes, wake foam
function drawBoatAmbience(tick) {
  ctx.save();
  // ── SEA SPRAY PARTICLES (white dots from sides) ──
  for (let s = 0; s < 5; s++) {
    const spray = (tick * 0.5 + s * 30) % 80;
    if (spray < 40) {
      const sx = (s % 2 === 0) ? 10 + s * 5 : GW - 20 - s * 5;
      const sy = GH - 60 - spray * 1.5;
      const sa = Math.max(0, 0.1 - spray * 0.0025);
      ctx.fillStyle = `rgba(255,255,255,${sa})`;
      ctx.fillRect(sx + Math.sin(tick * 0.05 + s) * 3, sy, 2, 1);
    }
  }
  // ── GENTLE ROCKING (subtle horizontal sway of ambient overlay) ──
  const rock = Math.sin(tick * 0.015) * 0.008;
  if (rock > 0) {
    ctx.fillStyle = `rgba(100,150,200,${rock})`;
    ctx.fillRect(0, GH - 40, GW, 40);
  }
  // ── SEAGULL SILHOUETTES (tiny V shapes drifting across sky) ──
  for (let g = 0; g < 3; g++) {
    const gx = (tick * 0.3 + g * 230) % (GW + 60) - 30;
    const gy = 15 + g * 18 + Math.sin(tick * 0.02 + g * 1.8) * 5;
    const ga = 0.12 - g * 0.03;
    ctx.strokeStyle = `rgba(40,40,60,${ga})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(gx - 4, gy + 2);
    ctx.lineTo(gx, gy);
    ctx.lineTo(gx + 4, gy + 2);
    ctx.stroke();
  }
  // ── WAKE FOAM (white shimmer line) ──
  for (let wx = 100; wx < GW - 100; wx += 5) {
    const waveY = GH - 50 + Math.sin(tick * 0.04 + wx * 0.06) * 2;
    const wa = Math.sin(tick * 0.05 + wx * 0.08) * 0.5 + 0.5;
    if (wa > 0.4) {
      ctx.fillStyle = `rgba(255,255,255,${(wa - 0.4) * 0.08})`;
      ctx.fillRect(wx, waveY, 3, 1);
    }
  }
  ctx.restore();
}

// Cave ambience: god-rays, lantern flicker, water shimmer, dripping water, glowing gem
function drawCaveAmbience(tick) {
  ctx.save();

  // ── GOD-RAYS from cave mouth (right side) ──
  const rayBase = 480;
  for (let r = 0; r < 5; r++) {
    const phase = tick * 0.008 + r * 1.3;
    const alpha = (Math.sin(phase) * 0.5 + 0.5) * 0.05 + 0.02;
    const spread = r * 24 - 48;
    ctx.fillStyle = `rgba(180,210,255,${alpha})`;
    ctx.beginPath();
    ctx.moveTo(rayBase + spread, 50 + r * 12);
    ctx.lineTo(rayBase + spread - 25, 50 + r * 12);
    ctx.lineTo(rayBase + spread - 100, 300);
    ctx.lineTo(rayBase + spread - 65, 300);
    ctx.closePath();
    ctx.fill();
  }
  const entrGlow = Math.sin(tick * 0.012) * 0.01 + 0.03;
  ctx.fillStyle = `rgba(160,200,255,${entrGlow})`;
  ctx.fillRect(400, 30, 240, 250);

  // ── LANTERN FLICKER (brass lantern on left side of cave floor) ──
  const lx = 60, ly = 260;
  const flicker = Math.sin(tick * 0.15) * 0.02 + Math.sin(tick * 0.23) * 0.01;
  // Wide warm glow
  ctx.fillStyle = `rgba(255,160,50,${0.03 + flicker})`;
  ctx.fillRect(lx - 60, ly - 80, 160, 140);
  // Inner glow
  ctx.fillStyle = `rgba(255,180,80,${0.05 + flicker})`;
  ctx.fillRect(lx - 25, ly - 40, 70, 60);
  // Bright core
  ctx.fillStyle = `rgba(255,220,140,${0.07 + flicker * 2})`;
  ctx.fillRect(lx - 4, ly - 6, 8, 10);

  // ── MYSTICAL JADE GEM (floating in cave alcove) ──
  // Jade is hidden until the player actively searches the crack (use verb)
  if (state.flags.jade_visible && !state.flags.jade_found) {
    const gemX = 210, gemY = 48;
    const pulse = Math.sin(tick * 0.04) * 0.5 + 0.5;
    const glow2 = Math.sin(tick * 0.025) * 0.3 + 0.7;
    const breathe = Math.sin(tick * 0.018) * 0.5 + 0.5;
    // Floating bob — gem hovers gently up and down
    const bobY = Math.sin(tick * 0.025) * 3;

    ctx.save();
    ctx.translate(gemX, gemY + bobY);

    // ═══ OUTER AURA: wide cave-illuminating glow ═══
    const auraR = 50 + pulse * 10;
    const aura = ctx.createRadialGradient(0, 0, 3, 0, 0, auraR);
    aura.addColorStop(0, `rgba(60,255,120,${0.20 + pulse * 0.08})`);
    aura.addColorStop(0.3, `rgba(40,200,90,${0.10 + breathe * 0.04})`);
    aura.addColorStop(0.6, `rgba(25,140,60,${0.04 + pulse * 0.02})`);
    aura.addColorStop(1, 'rgba(15,80,30,0)');
    ctx.fillStyle = aura;
    ctx.beginPath();
    ctx.ellipse(0, 2, auraR, auraR * 0.8, 0, 0, Math.PI * 2);
    ctx.fill();

    // ═══ PULSING RING — expanding mystical ripple ═══
    const ringPhase = (tick * 0.015) % 1;
    const ringR = 14 + ringPhase * 30;
    const ringAlpha = (1 - ringPhase) * 0.25;
    ctx.strokeStyle = `rgba(80,255,140,${ringAlpha})`;
    ctx.lineWidth = 1.5 * (1 - ringPhase);
    ctx.beginPath();
    ctx.ellipse(0, 0, ringR, ringR * 0.7, 0, 0, Math.PI * 2);
    ctx.stroke();
    // Second ring offset
    const ringPhase2 = (tick * 0.015 + 0.5) % 1;
    const ringR2 = 14 + ringPhase2 * 30;
    const ringAlpha2 = (1 - ringPhase2) * 0.15;
    ctx.strokeStyle = `rgba(100,255,160,${ringAlpha2})`;
    ctx.lineWidth = 1.2 * (1 - ringPhase2);
    ctx.beginPath();
    ctx.ellipse(0, 0, ringR2, ringR2 * 0.7, 0, 0, Math.PI * 2);
    ctx.stroke();

    // ═══ LIGHT RAYS — god-rays emanating from gem ═══
    for (let r = 0; r < 8; r++) {
      const angle = (r / 8) * Math.PI * 2 + tick * 0.006;
      const rayLen = 22 + Math.sin(tick * 0.035 + r * 1.4) * 10;
      const rayAlpha = 0.10 + Math.sin(tick * 0.05 + r * 2.1) * 0.06;
      ctx.strokeStyle = `rgba(80,255,140,${rayAlpha})`;
      ctx.lineWidth = 1.5 - (r % 2) * 0.5;
      ctx.beginPath();
      ctx.moveTo(Math.cos(angle) * 10, Math.sin(angle) * 8);
      ctx.lineTo(Math.cos(angle) * rayLen, Math.sin(angle) * rayLen * 0.8);
      ctx.stroke();
    }

    // Subtle slow rotation
    const rot = Math.sin(tick * 0.008) * 0.05;
    ctx.rotate(rot);

    // ═══ SHADOW beneath floating gem (grounds it) ═══
    ctx.fillStyle = `rgba(0,30,10,${0.12 + breathe * 0.04})`;
    ctx.beginPath();
    ctx.ellipse(0, 16 - bobY * 0.5, 12, 3, 0, 0, Math.PI * 2);
    ctx.fill();

    // ═══ GEM BODY — large brilliant-cut jade ═══
    const S = 1.6; // Scale factor — big and readable

    // Outer dark rim (border)
    ctx.fillStyle = '#0a2e1a';
    ctx.beginPath();
    ctx.moveTo(0 * S, -14 * S);
    ctx.lineTo(12 * S, -7 * S);
    ctx.lineTo(14 * S, 4 * S);
    ctx.lineTo(8 * S, 13 * S);
    ctx.lineTo(-8 * S, 13 * S);
    ctx.lineTo(-14 * S, 4 * S);
    ctx.lineTo(-12 * S, -7 * S);
    ctx.closePath();
    ctx.fill();

    // Main jade body — rich deep green
    const bR = 28 + breathe * 12, bG = 95 + breathe * 20, bB = 50 + breathe * 12;
    ctx.fillStyle = `rgb(${bR},${bG},${bB})`;
    ctx.beginPath();
    ctx.moveTo(0 * S, -12 * S);
    ctx.lineTo(10 * S, -6 * S);
    ctx.lineTo(12 * S, 3 * S);
    ctx.lineTo(7 * S, 11 * S);
    ctx.lineTo(-7 * S, 11 * S);
    ctx.lineTo(-12 * S, 3 * S);
    ctx.lineTo(-10 * S, -6 * S);
    ctx.closePath();
    ctx.fill();

    // ═══ FACETS — 4 distinct faces for cut-gem look ═══
    // Top crown facet (brightest — catches cave light)
    ctx.fillStyle = `rgba(${50 + pulse * 35},${150 + pulse * 45},${80 + pulse * 25},0.9)`;
    ctx.beginPath();
    ctx.moveTo(0 * S, -12 * S);
    ctx.lineTo(10 * S, -6 * S);
    ctx.lineTo(5 * S, -1 * S);
    ctx.lineTo(-5 * S, -1 * S);
    ctx.lineTo(-10 * S, -6 * S);
    ctx.closePath();
    ctx.fill();

    // Right facet (medium tone)
    ctx.fillStyle = `rgba(22,${70 + breathe * 18},${40 + breathe * 10},0.8)`;
    ctx.beginPath();
    ctx.moveTo(5 * S, -1 * S);
    ctx.lineTo(10 * S, -6 * S);
    ctx.lineTo(12 * S, 3 * S);
    ctx.lineTo(7 * S, 11 * S);
    ctx.lineTo(3 * S, 5 * S);
    ctx.closePath();
    ctx.fill();

    // Left facet (darker — in shadow)
    ctx.fillStyle = `rgba(18,${55 + breathe * 12},${32 + breathe * 8},0.8)`;
    ctx.beginPath();
    ctx.moveTo(-5 * S, -1 * S);
    ctx.lineTo(-10 * S, -6 * S);
    ctx.lineTo(-12 * S, 3 * S);
    ctx.lineTo(-7 * S, 11 * S);
    ctx.lineTo(-3 * S, 5 * S);
    ctx.closePath();
    ctx.fill();

    // Bottom pavilion facet (deepest)
    ctx.fillStyle = `rgba(15,${50 + breathe * 10},${30 + breathe * 6},0.85)`;
    ctx.beginPath();
    ctx.moveTo(-3 * S, 5 * S);
    ctx.lineTo(3 * S, 5 * S);
    ctx.lineTo(7 * S, 11 * S);
    ctx.lineTo(-7 * S, 11 * S);
    ctx.closePath();
    ctx.fill();

    // ═══ CENTER TABLE — the gem's heart, brightest face ═══
    const tG = 155 + glow2 * 60;
    ctx.fillStyle = `rgba(${55 + glow2 * 40},${tG},${75 + glow2 * 35},0.95)`;
    ctx.beginPath();
    ctx.moveTo(0 * S, -3 * S);
    ctx.lineTo(5 * S, -1 * S);
    ctx.lineTo(3 * S, 5 * S);
    ctx.lineTo(-3 * S, 5 * S);
    ctx.lineTo(-5 * S, -1 * S);
    ctx.closePath();
    ctx.fill();

    // ═══ FACET EDGE LINES — crisp gem-cut definition ═══
    ctx.strokeStyle = `rgba(8,35,15,${0.5 + pulse * 0.2})`;
    ctx.lineWidth = 1;
    // Crown edges
    ctx.beginPath(); ctx.moveTo(0 * S, -12 * S); ctx.lineTo(0 * S, -3 * S); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(5 * S, -1 * S); ctx.lineTo(10 * S, -6 * S); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-5 * S, -1 * S); ctx.lineTo(-10 * S, -6 * S); ctx.stroke();
    // Girdle line (horizontal belt)
    ctx.beginPath();
    ctx.moveTo(-12 * S, 3 * S); ctx.lineTo(-5 * S, -1 * S); ctx.lineTo(5 * S, -1 * S);
    ctx.lineTo(12 * S, 3 * S);
    ctx.stroke();
    // Pavilion edges
    ctx.beginPath(); ctx.moveTo(5 * S, -1 * S); ctx.lineTo(3 * S, 5 * S); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-5 * S, -1 * S); ctx.lineTo(-3 * S, 5 * S); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(3 * S, 5 * S); ctx.lineTo(7 * S, 11 * S); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-3 * S, 5 * S); ctx.lineTo(-7 * S, 11 * S); ctx.stroke();
    // Table outline (bright edge)
    ctx.strokeStyle = `rgba(100,220,140,${0.2 + glow2 * 0.15})`;
    ctx.lineWidth = 0.8;
    ctx.beginPath();
    ctx.moveTo(0 * S, -3 * S); ctx.lineTo(5 * S, -1 * S); ctx.lineTo(3 * S, 5 * S);
    ctx.lineTo(-3 * S, 5 * S); ctx.lineTo(-5 * S, -1 * S); ctx.closePath();
    ctx.stroke();

    // ═══ JADE VEINS — organic mineral inclusions ═══
    ctx.strokeStyle = `rgba(12,50,22,${0.30 + breathe * 0.1})`;
    ctx.lineWidth = 0.8;
    ctx.beginPath(); ctx.moveTo(-8 * S, -4 * S); ctx.quadraticCurveTo(-2 * S, 1 * S, 6 * S, -3 * S); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-4 * S, 8 * S); ctx.quadraticCurveTo(1 * S, 4 * S, 8 * S, 6 * S); ctx.stroke();

    // ═══ SPECULAR HIGHLIGHTS — polished gemstone gleam ═══
    // Main highlight — elongated bright slash
    ctx.fillStyle = `rgba(210,255,225,${0.40 + pulse * 0.25})`;
    ctx.beginPath();
    ctx.ellipse(-3 * S, -5 * S, 5 * S, 2.2 * S, -0.35, 0, Math.PI * 2);
    ctx.fill();
    // Hard bright core
    ctx.fillStyle = `rgba(255,255,255,${0.30 + pulse * 0.2})`;
    ctx.beginPath();
    ctx.ellipse(-2 * S, -5 * S, 2.5 * S, 1.2 * S, -0.35, 0, Math.PI * 2);
    ctx.fill();
    // Secondary lower highlight
    ctx.fillStyle = `rgba(180,255,210,${0.15 + glow2 * 0.12})`;
    ctx.beginPath();
    ctx.ellipse(3 * S, 3 * S, 2.5 * S, 1.5 * S, 0.3, 0, Math.PI * 2);
    ctx.fill();

    // ═══ INNER LUMINOUS HEART — mystical energy core ═══
    ctx.globalAlpha = 0.25 + breathe * 0.15;
    const innerGlow = ctx.createRadialGradient(0, 1 * S, 0, 0, 1 * S, 10 * S);
    innerGlow.addColorStop(0, `rgba(${120 + pulse * 80},255,${160 + pulse * 60},0.6)`);
    innerGlow.addColorStop(0.4, 'rgba(60,220,100,0.2)');
    innerGlow.addColorStop(1, 'rgba(30,120,50,0)');
    ctx.fillStyle = innerGlow;
    ctx.beginPath();
    ctx.ellipse(0, 1 * S, 10 * S, 8 * S, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // ═══ ANIMATED SPARKLE STAR — moving bright point on gem surface ═══
    const starAngle = tick * 0.03;
    const starX = Math.cos(starAngle) * 4 * S;
    const starY = Math.sin(starAngle * 0.7) * 3 * S;
    const starA = Math.sin(tick * 0.06) * 0.3 + 0.4;
    ctx.fillStyle = `rgba(255,255,255,${starA})`;
    // 4-point star
    ctx.beginPath();
    ctx.moveTo(starX, starY - 2); ctx.lineTo(starX + 1, starY);
    ctx.lineTo(starX, starY + 2); ctx.lineTo(starX - 1, starY);
    ctx.closePath();
    ctx.fill();
    ctx.fillRect(starX - 2, starY, 4, 1);
    ctx.fillRect(starX, starY - 2, 1, 4);

    ctx.restore(); // undo translate+rotate

    // ═══ ORBITING SPARKLES — magical particles circling the gem ═══
    for (let sp = 0; sp < 7; sp++) {
      const orbitAngle = tick * 0.018 + sp * (Math.PI * 2 / 7);
      const orbitR = 22 + Math.sin(tick * 0.012 + sp * 2.3) * 6;
      const spx = gemX + Math.cos(orbitAngle) * orbitR;
      const spy = gemY + bobY + Math.sin(orbitAngle) * orbitR * 0.6;
      const spa = Math.sin(tick * 0.045 + sp * 1.6) * 0.5 + 0.5;
      if (spa > 0.15) {
        // Cross sparkle
        ctx.fillStyle = `rgba(150,255,190,${spa * 0.35})`;
        ctx.fillRect(spx - 1, spy, 3, 1);
        ctx.fillRect(spx, spy - 1, 1, 3);
        // Bright core pixel
        ctx.fillStyle = `rgba(220,255,240,${spa * 0.5})`;
        ctx.fillRect(spx, spy, 1, 1);
      }
    }

    // ═══ RISING ENERGY MOTES — mystical particles floating upward ═══
    for (let m = 0; m < 6; m++) {
      const my = gemY + 25 - ((tick * 0.4 + m * 22) % 50);
      const mx = gemX + Math.sin(tick * 0.018 + m * 2.1) * 12;
      const mLife = ((tick * 0.4 + m * 22) % 50) / 50;
      const ma = Math.sin(mLife * Math.PI); // fade in and out
      if (ma > 0.1) {
        ctx.fillStyle = `rgba(100,255,150,${ma * 0.18})`;
        ctx.fillRect(mx, my, 1, 1);
        if (ma > 0.5) {
          ctx.fillStyle = `rgba(160,255,200,${(ma - 0.5) * 0.15})`;
          ctx.fillRect(mx - 1, my, 1, 1);
        }
      }
    }
  }

  // ── TIDAL POOL SHIMMER ──
  for (let wx = 100; wx < 500; wx += 5) {
    const wave = Math.sin(tick * 0.035 + wx * 0.06);
    if (wave > 0.1) {
      ctx.fillStyle = `rgba(60,180,190,${0.05 + wave * 0.06})`;
      ctx.fillRect(wx, 260 + wave * 3, 4, 1);
    }
    // Lantern reflections on water
    if (wx < 250 && Math.sin(tick * 0.05 + wx * 0.15) > 0.7) {
      ctx.fillStyle = `rgba(255,200,100,${0.06 + Math.sin(tick * 0.08 + wx) * 0.03})`;
      ctx.fillRect(wx + 2, 268 + Math.sin(wx * 0.3) * 2, 2, 1);
    }
    // Blue daylight reflections on water (right half)
    if (wx > 350 && Math.sin(tick * 0.04 + wx * 0.12) > 0.6) {
      ctx.fillStyle = `rgba(140,200,255,${0.05 + Math.sin(tick * 0.06 + wx) * 0.03})`;
      ctx.fillRect(wx, 265 + Math.sin(wx * 0.25) * 2, 3, 1);
    }
  }

  // ── DRIPPING WATER (from stalactites) ──
  const drip1 = tick % 110;
  if (drip1 < 22) {
    const dy = drip1 * 3.5 + 40;
    if (dy < 255) {
      ctx.fillStyle = 'rgba(100,200,220,0.5)';
      ctx.fillRect(250, dy, 1, 2);
      if (drip1 > 8) ctx.fillRect(250, dy + 2, 1, 1);
    }
  }
  if (drip1 >= 22 && drip1 < 27) {
    const sp = drip1 - 22;
    ctx.fillStyle = `rgba(100,200,220,${0.3 - sp * 0.06})`;
    ctx.fillRect(248 - sp * 2, 258, 1, 1);
    ctx.fillRect(252 + sp * 2, 258, 1, 1);
  }
  const drip2 = (tick + 55) % 140;
  if (drip2 < 18) {
    const dy2 = drip2 * 3.0 + 35;
    if (dy2 < 252) {
      ctx.fillStyle = 'rgba(80,180,200,0.4)';
      ctx.fillRect(160, dy2, 1, 2);
    }
  }

  // ── DUST MOTES in god-ray beams ──
  for (let d = 0; d < 8; d++) {
    const dx = 400 + Math.sin(tick * 0.012 + d * 1.9) * 80;
    const dy = 60 + Math.sin(tick * 0.009 + d * 2.4) * 100 + d * 18;
    const da = Math.sin(tick * 0.04 + d * 3.1);
    if (da > 0.2 && dx > 350) {
      ctx.fillStyle = `rgba(200,220,255,${da * 0.12})`;
      ctx.fillRect(dx, dy, 1, 1);
    }
  }

  ctx.restore();
}

// ════════════════════════════════════════════════════════════
// CHARACTER RENDERING (ported from Galaxidi Adventure)
// ════════════════════════════════════════════════════════════
const CHAR_HEIGHTS = { ntemis: 118, ajax: 84, clio: 92 };

// Scale factor: sprites are small relative to 640x400 canvas — scale up to MI2 proportions
const CHAR_SCALE = 1.5;
// Per-character scale multiplier: Ajax (12yo) must be taller than Clio (6yo)
const CHAR_SCALE_MULT = { ntemis: 1.0, ajax: 1.11, clio: 0.80 };

// Per-character anatomy: waist split ratio & max leg stride (pixels, in sprite space)
const WALK_ANATOMY = {
  ntemis:  { waist: 0.75, stride: 10 },
  ajax:    { waist: 0.71, stride: 8 },
  clio:    { waist: 0.73, stride: 8 },
  ghost:   { waist: 0.55, stride: 0 },
  athos:   { waist: 0.60, stride: 7 },
  stathis: { waist: 0.58, stride: 8 },
  akis:    { waist: 0.60, stride: 8 },
  giannis: { waist: 0.58, stride: 7 },
  curator: { waist: 0.62, stride: 6 },
};

function drawSprite(who, gx, gy, dir, walking, frame, tick, frameOffset) {
  const img = CHAR_IMGS[who];
  if (!img || !img.complete || !img.naturalWidth) {
    drawFallbackPerson(gx, gy, who);
    return;
  }
  const sprW = img.naturalWidth;
  const sprH = img.naturalHeight;
  const anat = WALK_ANATOMY[who] || { waist: 0.60, stride: 6 };
  const S = CHAR_SCALE * (CHAR_SCALE_MULT[who] || 1.0);

  if (walking) {
    // ── WALK PHASE (slower cycle for natural cadence) ──
    const walkPhase = frame * Math.PI * 2.4 + frameOffset * Math.PI / 3;
    const bob = -Math.abs(Math.sin(walkPhase)) * 2;
    const lean = dir * 0.02;
    const strideDir = Math.sin(walkPhase); // -1 to 1

    const waistY = Math.floor(sprH * anat.waist);
    const legH = sprH - waistY;
    const maxStride = anat.stride;

    // Ground shadow (scaled)
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = '#4A3A28';
    const sw = (sprW * 0.6 + Math.abs(strideDir) * 3) * S;
    ctx.beginPath();
    ctx.ellipse(gx, gy + 3, sw, 3.5 * S, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.translate(Math.round(gx), Math.round(gy + bob));
    // Apply character scale + horizontal flip
    if (dir < 0) ctx.scale(-S, S);
    else ctx.scale(S, S);
    ctx.rotate(lean);

    // ── UPPER BODY (slight counter-sway) ──
    const counterSway = Math.round(-strideDir * 1.5);
    ctx.drawImage(img,
      0, 0, sprW, waistY,
      -sprW/2 + counterSway, -sprH, sprW, waistY
    );

    // ── BACK LEG (drawn first, darker, shifted opposite, lifted) ──
    const bandH = 1;
    ctx.save();
    ctx.globalAlpha = 0.7;
    for (let y = 0; y < legH; y += bandH) {
      const progress = y / Math.max(1, legH - 1);
      const backOff = -strideDir * maxStride * 0.7 * (0.3 + 0.7 * progress);
      const lift = Math.abs(strideDir) * 3 * progress;
      const h = Math.min(bandH, legH - y);
      ctx.drawImage(img,
        0, waistY + y, sprW, h,
        -sprW/2 + backOff, -sprH + waistY + y - lift, sprW, h
      );
    }
    ctx.restore();

    // ── FRONT LEG (on top, full brightness, shifted forward) ──
    for (let y = 0; y < legH; y += bandH) {
      const progress = y / Math.max(1, legH - 1);
      const frontOff = strideDir * maxStride * (0.3 + 0.7 * progress);
      const h = Math.min(bandH, legH - y);
      ctx.drawImage(img,
        0, waistY + y, sprW, h,
        -sprW/2 + frontOff, -sprH + waistY + y, sprW, h
      );
    }

    ctx.restore();

  } else {
    // ── IDLE ANIMATION ──
    const bp = tick * 0.03 + frameOffset * 3;
    const breathe = Math.sin(bp) * 1.0 + Math.sin(bp * 0.6 + 0.5) * 0.4;
    const sway = Math.sin(tick * 0.01 + frameOffset * 2.5) * 0.008
               + Math.sin(tick * 0.023 + frameOffset) * 0.003;
    const bc = Math.sin(bp);
    const squashX = 1 + bc * 0.005;
    const squashY = 1 - bc * 0.005;

    // Ground shadow (scaled)
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = '#4A3A28';
    ctx.beginPath();
    ctx.ellipse(gx, gy + 3, sprW * S * 0.6, 4 * S, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.translate(Math.round(gx), Math.round(gy + breathe));
    // Apply character scale + horizontal flip
    if (dir < 0) ctx.scale(-S, S);
    else ctx.scale(S, S);
    ctx.rotate(sway);
    ctx.scale(squashX, squashY);
    ctx.drawImage(img, -sprW/2, -sprH);
    ctx.restore();
  }
}

function drawFallbackPerson(x, y, who) {
  const colors = {
    ntemis: { shirt: '#5A6B4A', pants: '#8B7355', skin: '#DDAA88' },
    ajax:   { shirt: '#C44040', pants: '#6A7A5A', skin: '#DDBB99' },
    clio:   { shirt: '#886688', pants: '#5A3A5A', skin: '#DDC0A0' },
  };
  const c = colors[who] || colors.ntemis;
  const h = who === 'ntemis' ? 40 : 32;
  // Simple rectangle person
  ctx.fillStyle = c.skin;
  ctx.fillRect(x - 4, y - h, 8, 10); // head
  ctx.fillStyle = c.shirt;
  ctx.fillRect(x - 6, y - h + 10, 12, 14); // body
  ctx.fillStyle = c.pants;
  ctx.fillRect(x - 5, y - h + 24, 10, h - 24); // legs
}

function drawCharacter(who, tick) {
  const c = chars[who];
  if (!c.visible) return;
  const offsets = { ntemis: 0, ajax: 1.05, clio: 2.1 };
  // Fade-in alpha with smoothstep
  let alpha = Math.min(1, c.fadeIn);
  if (alpha < 1) {
    alpha = alpha * alpha * (3 - 2 * alpha); // smoothstep
    ctx.save();
    ctx.globalAlpha = alpha;
  }
  drawSprite(who, c.x, c.y, c.dir, c.walking, c.frame, tick, offsets[who]);
  if (alpha < 1) ctx.restore();
}

function drawNPC(who, tick) {
  const npc = npcChars[who];
  if (!npc || npc.scene !== state.scene) return;
  // Allow ghost rendering during materialization even when not yet visible
  const isMaterializing = who === 'ghost' && state.seq.active && state.seq.ghostMat.active;
  if (!npc.visible && !isMaterializing) return;
  const img = CHAR_IMGS[who];
  if (!img || !img.complete || !img.naturalWidth) return;

  const sprW = img.naturalWidth;
  const sprH = img.naturalHeight;
  const gx = npc.x;
  const gy = npc.y;

  // Idle animation — subtle for stationary NPCs (reduced from family chars)
  const bp = tick * 0.02;
  const breathe = Math.sin(bp) * 0.3 + Math.sin(bp * 0.6 + 0.5) * 0.1;
  const sway = Math.sin(tick * 0.008) * 0.003 + Math.sin(tick * 0.018) * 0.001;
  const bc = Math.sin(bp);
  const squashX = 1 + bc * 0.005;
  const squashY = 1 - bc * 0.005;

  // Per-NPC scale (defaults to 1.0, multiplied with CHAR_SCALE)
  const npcScale = npc.scale || 1.0;
  const S = CHAR_SCALE * npcScale;

  // Ground shadow (scaled)
  ctx.save();
  ctx.globalAlpha = who === 'ghost' ? 0.06 : 0.18;
  ctx.fillStyle = '#4A3A28';
  ctx.beginPath();
  ctx.ellipse(gx, gy + 3, sprW * S * 0.6, 4 * S, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  ctx.save();
  ctx.imageSmoothingEnabled = false;

  // Ghost special effects
  if (who === 'ghost') {
    if (state.seq.active && state.seq.ghostMat.active) {
      // During sequence: use materialization alpha/glow
      ctx.globalAlpha = state.seq.ghostMat.alpha;
      ctx.shadowColor = 'rgba(100,180,255,0.5)';
      ctx.shadowBlur = state.seq.ghostMat.glowBlur;
    } else {
      ctx.globalAlpha = 0.45 + Math.sin(tick * 0.02) * 0.1;
      ctx.shadowColor = 'rgba(100,180,255,0.5)';
      ctx.shadowBlur = 12;
    }
  }

  // Wave vertical oscillation
  const waveOffset = (npc.wave || 0) > 0 ? Math.sin(tick * 0.1) * npc.wave : 0;

  ctx.translate(Math.round(gx), Math.round(gy + breathe + waveOffset));
  if (npc.dir < 0) ctx.scale(-S, S);
  else ctx.scale(S, S);
  ctx.rotate(sway + (npc.tilt || 0));
  ctx.scale(squashX, squashY);
  ctx.drawImage(img, -sprW / 2, -sprH);
  ctx.restore();
}

// ════════════════════════════════════════════════════════════
// WALKABLE AREA SYSTEM
// ════════════════════════════════════════════════════════════
// Each scene defines a walkLine: array of [x, y] points that define
// the ground level across the scene. Characters snap to this line.
function getGroundY(sceneId, x) {
  const sc = scenes[sceneId];
  if (!sc || !sc.walkLine) return 378; // fallback
  const pts = sc.walkLine;
  if (x <= pts[0][0]) return pts[0][1];
  if (x >= pts[pts.length - 1][0]) return pts[pts.length - 1][1];
  for (let i = 0; i < pts.length - 1; i++) {
    if (x >= pts[i][0] && x <= pts[i + 1][0]) {
      const t = (x - pts[i][0]) / (pts[i + 1][0] - pts[i][0]);
      return pts[i][1] + t * (pts[i + 1][1] - pts[i][1]);
    }
  }
  return pts[0][1];
}

// ════════════════════════════════════════════════════════════
// WALKING SYSTEM
// ════════════════════════════════════════════════════════════
// Returns [minX, maxX] walkable bounds for a scene.
// Uses explicit walkBounds if set, otherwise derives from walkLine endpoints.
function getWalkBounds(sceneId) {
  const sc = scenes[sceneId];
  if (!sc) return [30, GW - 30];
  if (sc.walkBounds) return sc.walkBounds;
  if (sc.walkLine && sc.walkLine.length >= 2) {
    return [sc.walkLine[0][0], sc.walkLine[sc.walkLine.length - 1][0]];
  }
  return [30, GW - 30];
}

function startWalk(who, targetX, cb) {
  const c = chars[who];
  const dist = Math.abs(targetX - c.x);
  if (dist < 5) { if (cb) cb(); return; }
  const bounds = getWalkBounds(state.scene);
  targetX = Math.max(bounds[0], Math.min(bounds[1], targetX));
  c.dir = targetX > c.x ? 1 : -1;
  c.walking = true;
  c.startX = c.x;
  c.startY = c.y;
  c.targetX = targetX;
  c.targetY = getGroundY(state.scene, targetX);
  c.walkT = 0;
  // Slower walk in graveyard after ghost — weight of the moment
  const walkMult = (state.scene === 'graveyard' && state.flags.ghost_summoned) ? 1.4 : 1.0;
  c.walkDur = Math.max(0.6, Math.min(3.5, (dist / GW) * 5.0 * walkMult));
  c.frame = 0;
  if (who === 'ntemis') sfxStepAcc = 0;
  if (who === 'ntemis') walkDoneCallback = cb;
}

function updateWalking(dt) {
  for (const who of ['ntemis','ajax','clio']) {
    const c = chars[who];
    if (!c.walking) continue;
    c.walkT += dt;
    const p = Math.min(1, c.walkT / c.walkDur);
    const ep = easeInOutCubic(p);
    c.x = c.startX + (c.targetX - c.startX) * ep;
    // Follow walkLine at every X position — prevents floating mid-walk
    c.y = getGroundY(state.scene, c.x);

    // Store raw walk time for smooth interpolation in drawSprite
    c.frame = c.walkT;

    // Footstep SFX — only for ntemis, every ~0.3s
    if (who === 'ntemis') {
      sfxStepAcc += dt;
      if (sfxStepAcc >= 0.3) {
        sfxStepAcc -= 0.3;
        playSFX('step');
      }
    }

    if (p >= 1) {
      c.x = c.targetX;
      c.y = c.targetY;
      c.walking = false;
      c.targetX = null;
      c.targetY = null;
      c.dir = 1;
      if (who === 'ntemis' && walkDoneCallback) {
        const cb = walkDoneCallback;
        walkDoneCallback = null;
        cb();
      }
    }
  }
}

// Family follow: Ajax and Clio follow Ntemis with offset
function familyFollow(targetX) {
  const bounds = getWalkBounds(state.scene);
  const nX = targetX;
  // Ajax follows to the right, Clio to the left — clamped to walk bounds
  const ajaxTarget = Math.min(bounds[1], nX + 70);
  const clioTarget = Math.max(bounds[0], nX - 70);
  setTimeout(() => startWalk('ajax', ajaxTarget), 150);
  setTimeout(() => startWalk('clio', clioTarget), 280);
}

// ════════════════════════════════════════════════════════════
// HOTSPOT HIT TESTING
// ════════════════════════════════════════════════════════════
const HOTSPOT_PAD = 10; // extra click margin around every object
function hitTestObj(gx, gy) {
  if (!state.scene) return null;
  const sc = scenes[state.scene];
  for (const obj of sc.objects) {
    if (obj._hidden) continue;
    if (gx >= obj.x - HOTSPOT_PAD && gx <= obj.x + obj.w + HOTSPOT_PAD &&
        gy >= obj.y - HOTSPOT_PAD && gy <= obj.y + obj.h + HOTSPOT_PAD) {
      return obj;
    }
  }
  return null;
}

function hitTestExit(gx, gy) {
  if (!state.scene) return null;
  const sc = scenes[state.scene];
  if (!sc.exits) return null;
  for (const exit of sc.exits) {
    if (exit.side === 'left' && gx < 35) return exit;
    if (exit.side === 'right' && gx > GW - 35) return exit;
  }
  return null;
}

// ════════════════════════════════════════════════════════════
// VOICE SYSTEM
// ════════════════════════════════════════════════════════════
const voiceAudio = new Audio();
voiceAudio.volume = 0.8;
voiceAudio.onerror = () => { voiceFinished = true; console.error('Failed to load voice:', voiceAudio.src); };

const VOICE_MAP = {
  'Ξύλινη πόρτα βαμμένη μπλε. Το χρώμα του Αιγαίου.': 'voice/narrator/001.mp3',
  'Ροζ μπουκαμβίλιες σκαρφαλώνουν στον τοίχο. Εδώ το καλοκαίρι αρνείται να φύγει.': 'voice/narrator/002.mp3',
  'Πήλινες γλάστρες με βασιλικό. Κάποιος τα περιποιείται ακόμα κι όταν το σπίτι μένει κλειστό.': 'voice/narrator/003.mp3',
  'Ένα παλιό ξύλινο βαρέλι. Μυρίζει κρασί και αλμύρα.': 'voice/narrator/004.mp3',
  'Χρωματιστά ψαροκάικα δεμένα στο λιμάνι. Κουνιούνται αργά στο απογευματινό φως.': 'voice/narrator/005.mp3',
  'Ο Κορινθιακός κόλπος λάμπει χρυσαφί στο ηλιοβασίλεμα. Μαγικό.': 'voice/narrator/006.mp3',
  'Ο ήλιος βάφει χρυσά τα καλντερίμια. Μυρωδιά πεύκου ανακατεμένη με θαλασσινό αλάτι.': 'voice/narrator/007.mp3',
  'Ο Κορινθιακός λάμπει σαν λιωμένο χρυσάφι. Ψαροκάικα κουνιούνται αργά στο λιμάνι.': 'voice/narrator/008.mp3',
  'Τρία δελφίνια κόβουν βόλτες στο λιμάνι.': 'voice/narrator/009.mp3',
  'Τα δελφίνια συνεχίζουν τους κύκλους τους. Σαν να φυλάνε κάτι.': 'voice/narrator/010.mp3',
  'Κεραμίδια, σκεπές, καμινάδες. Κάθε σπίτι κι ένας καπετάνιος κάποτε.': 'voice/narrator/011.mp3',
  'Ο Παρνασσός στο βάθος. Οι Δελφοί κάπου εκεί πάνω.': 'voice/narrator/012.mp3',
  'Πέτρινο κάγκελο με θέα ολόκληρο το Γαλαξίδι. Θα μπορούσες να κάτσεις εδώ ώρες.': 'voice/narrator/013.mp3',
  'Γεράνια σε πήλινη γλάστρα. Τα χρώματα λάμπουν στο ηλιοβασίλεμα.': 'voice/narrator/014.mp3',
  'Η θέα κόβει την ανάσα.': 'voice/narrator/015.mp3',
  'Φρέσκα σύκα σε πήλινο μπολ. Η μυρωδιά γεμίζει το δωμάτιο.': 'voice/narrator/016.mp3',
  'Τρως ένα σύκο. Γλυκό σαν μέλι.': 'voice/narrator/017.mp3',
  'Μια παλιά δερμάτινη τσάντα πάνω στην καρέκλα. Δεν είναι δική σας.': 'voice/narrator/018.mp3',
  'Η τσάντα είναι άδεια τώρα.': 'voice/narrator/019.mp3',
  'Ανοίγεις την τσάντα. Μέσα βρίσκεις ένα σημείωμα.': 'voice/narrator/020.mp3',
  '«Σας περιμέναμε. Ελάτε στο λιμάνι απόψε. Τραπέζι για τρεις. — Γ.»': 'voice/narrator/021.mp3',
  'Η τσάντα είναι πλέον άδεια.': 'voice/narrator/022.mp3',
  'Απογευματινό φως μέσα από γαλάζια πατζούρια. Σκιές χορεύουν στον τοίχο.': 'voice/narrator/023.mp3',
  'Ανοίγεις τα πατζούρια. Μυρωδιά θυμαριού και τζιτζίκια.': 'voice/narrator/024.mp3',
  'Χάλκινα σκεύη κρεμασμένα στον τοίχο. Κάποτε τάιζαν οικογένειες ναυτικών.': 'voice/narrator/025.mp3',
  'Πέτρινο τζάκι. Μέσα υπάρχουν ακόμα στάχτες από τον τελευταίο χειμώνα.': 'voice/narrator/026.mp3',
  'Η κουζίνα μυρίζει θυμάρι και παλιό ξύλο.': 'voice/narrator/027.mp3',
  'Χρωματιστά καΐκια δεμένα στα μπαλόνια. Η μπογιά ξεφλουδίζει — αλμύρα και χρόνια.': 'voice/narrator/028.mp3',
  'Μεταλλικές δέστρες ψηλότερες από την Κλειώ. Φτιαγμένες για τρικάταρτα, όχι για βαρκούλες.': 'voice/narrator/029.mp3',
  'Ένας ψαράς μπαλώνει τα δίχτυα του. Τα χέρια του κινούνται αυτόματα — πενήντα χρόνια πρακτική.': 'voice/narrator/030.mp3',
  'Ο ψαράς σηκώνει το βλέμμα. Τα μάτια του είναι γαλάζια σαν τον κόλπο.': 'voice/narrator/031.mp3',
  '«Ψάρι λίγο. Ιστορίες πολλές. Κάτσε να σου πω.»': 'voice/narrator/032.mp3',
  'Πέτρινες αποθήκες με σιδερένιες πόρτες. Κάποτε γεμάτες σταφίδα και λάδι για εξαγωγή. Τώρα σιωπή.': 'voice/narrator/033.mp3',
  'Γλάροι κράζουν πάνω από το λιμάνι. Αιώνιοι κάτοικοι.': 'voice/narrator/034.mp3',
  'Τρεις γάτες ξαπλωμένες στον ήλιο. Σε κοιτάνε με αδιαφορία.': 'voice/narrator/035.mp3',
  'Ο Στάθης με την κιθάρα του. Φίλος από τα παλιά.': 'voice/narrator/036.mp3',
  'Ο Άκης παίζει φλογέρα στο λιμάνι. Η μελωδία ταξιδεύει στο νερό.': 'voice/narrator/037.mp3',
  'Το λιμάνι του Γαλαξειδίου. Μισοφέγγαρο από πέτρα, κυμαρισμένο φως, μυρωδιά αλμύρας.': 'voice/narrator/038.mp3',
  'Ένα πανέμορφο μοντέλο τρικάταρτου μέσα σε γυάλινη βιτρίνα. Κάθε λεπτομέρεια τέλεια.': 'voice/narrator/039.mp3',
  'Η πινακίδα γράφει: «Σκούνα Χρυσούλα, 1904 — το τελευταίο ιστιοφόρο του Γαλαξειδίου.»': 'voice/narrator/040.mp3',
  'Μια γωνιά αφιερωμένη στα ατμόπλοια. Ένα σιδερένιο μοντέλο, μικρότερο, λιγότερο εντυπωσιακό.': 'voice/narrator/041.mp3',
  'Πορτρέτα σε χρυσές κορνίζες. Σοβαρά πρόσωπα, κομψά μουστάκια, μάτια που έχουν δει θάλασσα.': 'voice/narrator/042.mp3',
  'Πυξίδες, εξάντες, χάρτες. Τα εργαλεία που οδηγούσαν τα πλοία σε κάθε γωνιά της Μεσογείου.': 'voice/narrator/043.mp3',
  'Ναυτικές σημαίες κρέμονται από το ταβάνι. Ελληνική, γαλλική, ρωσική — τα λιμάνια που γνώριζαν.': 'voice/narrator/044.mp3',
  'Ένας παλιός χάρτης του Κορινθιακού κρεμασμένος στον τοίχο. Σημειώσεις με μελάνι — δρόμοι ναυσιπλοΐας.': 'voice/narrator/045.mp3',
  'Ο επιμελητής του μουσείου. Τα μάτια του λάμπουν πίσω από τα στρογγυλά γυαλιά.': 'voice/narrator/046.mp3',
  'Το Ναυτικό Μουσείο του Γαλαξειδίου. Μυρωδιά ξύλου και παλιού χαρτιού.': 'voice/narrator/047.mp3',
  'Το παλιό ελαιοτριβείο — πέτρα και ξύλο. Κάποτε έβγαζε λάδι, τώρα βγάζει ιστορίες.': 'voice/narrator/048.mp3',
  'Ξύλινο μπαρ γεμάτο μπουκάλια. Τσίπουρο, ρακή, κρασιά ντόπια. Φανάρια ρίχνουν ζεστό φως.': 'voice/narrator/049.mp3',
  'Γαλάζια πατζούρια ανοιχτά στο φεγγαρόφωτο. Το λιμάνι λάμπει ασημί.': 'voice/narrator/050.mp3',
  'Ασπρόμαυρες φωτογραφίες στον τοίχο. Ψαράδες, καπετάνιοι, γυναίκες που περίμεναν.': 'voice/narrator/051.mp3',
  'Ξύλινα σκαμπό τριγμένα από χρόνια. Πόσες κουβέντες έχουν ακούσει.': 'voice/narrator/052.mp3',
  'Πλακάκια σε σκακιέρα — κίτρινα και καφέ. Λαμπυρίζουν στο φως των φαναριών.': 'voice/narrator/053.mp3',
  'Ο Άθος. Δικηγόρος και ιδιοκτήτης του Λιοτριβιού. Τα μάτια του κρύβουν χίλια μυστικά.': 'voice/narrator/054.mp3',
  'Το Λιοτρίβι. Πέτρα, ξύλο, ζεστό φως. Μυρωδιά τσίπουρου και ελιάς.': 'voice/narrator/055.mp3',
  'Μια τεράστια πέτρινη πόρτα με δώδεκα κυκλικές εσοχές. Σχήμα τιμονιού.': 'voice/narrator/056.mp3',
  'Χαραγμένα σύμβολα στον βράχο. Νεκροκεφαλή, ψάρι, άγκυρα, μάτι.': 'voice/narrator/057.mp3',
  'Τυρκουάζ νερό λάμπει από το φως της εισόδου. Κρυστάλλινο.': 'voice/narrator/058.mp3',
  'Σταλακτίτες κρέμονται σαν δάχτυλα γίγαντα. Χιλιάδες χρόνια σε κάθε σταγόνα.': 'voice/narrator/059.mp3',
  'Ένα σάπιο βαρέλι. Μυρίζει θάλασσα και χρόνο.': 'voice/narrator/060.mp3',
  'Άδειο, εκτός από αλμύρα και σκόνη.': 'voice/narrator/061.mp3',
  'Χρυσό φως χύνεται μέσα από τη φυσική αψίδα. Σκόνη χορεύει στις ακτίνες.': 'voice/narrator/062.mp3',
  'Ο Κάρκαρος. Ο θόλος υψώνεται σαν καθεδρικός. Χρυσό φως χύνεται από την είσοδο.': 'voice/narrator/063.mp3',
  'Πέτρινο σιντριβάνι στην πλατεία. Το νερό τρέχει αθόρυβα.': 'voice/narrator/064.mp3',
  'Ο Άγιος Νικόλαος — προστάτης των ναυτικών. Ο τρούλος λάμπει κόκκινος στον ήλιο.': 'voice/narrator/065.mp3',
  'Φούξια μπουκαμβίλιες σκεπάζουν τον τοίχο. Χρώμα που αψηφά τον χρόνο.': 'voice/narrator/066.mp3',
  'Μια πορτοκαλί γάτα κοιμάται αράχτη στα πλακάκια.': 'voice/narrator/067.mp3',
  'Η γάτα νιαουρίζει απαλά.': 'voice/narrator/068.mp3',
  'Πέτρινα παγκάκια στη σκιά. Γέροι κάθονταν εδώ κάθε απόγευμα, εδώ και δεκαετίες.': 'voice/narrator/069.mp3',
  'Γλάστρες με γεράνια και λουλούδια. Κάποιος φροντίζει αυτή την πλατεία με αγάπη.': 'voice/narrator/070.mp3',
  'Η πλατεία του Αγίου Νικολάου. Ησυχία, λουλούδια, και ήχος νερού.': 'voice/narrator/071.mp3',
  'Ένα παλιό ορειχάλκινο τηλεσκόπιο. Κάποιος το άφησε εδώ;': 'voice/narrator/072.mp3',
  'Η θέα κόβει την ανάσα. Ολόκληρο το Γαλαξίδι, ο κόλπος, τα βουνά. Από εδώ βλέπεις τα πάντα.': 'voice/narrator/073.mp3',
  'Πέτρινα ερείπια — ίσως ο παλιός μύλος. Αψίδα ακόμα όρθια, αψηφώντας τον χρόνο.': 'voice/narrator/074.mp3',
  'Παπαρούνες, μαργαρίτες, θυμάρι. Ο λόφος μυρίζει μέλι και καλοκαίρι.': 'voice/narrator/075.mp3',
  'Πέτρινο καλντερίμι ανεβαίνει τον λόφο. Λειασμένο από πόδια αιώνων.': 'voice/narrator/076.mp3',
  'Ο Γιάννης Βελανής. Ιδιοκτήτης του παλιού μύλου. Ήσυχος, βλέπει τα πάντα από ψηλά.': 'voice/narrator/077.mp3',
  'Ο Γιάννης σου δίνει ένα φανάρι.': 'voice/narrator/078.mp3',
  'Η κορυφή του λόφου. Αέρας, φως, και θέα που δεν τελειώνει.': 'voice/narrator/079.mp3',
  '«ΕΛΠΙΔΑ» — χρυσά γράμματα σε ξεφλουδισμένο μπλε ξύλο.': 'voice/narrator/080.mp3',
  'Ένα μικρό λευκό παρεκκλήσι πάνω στον βράχο. Ελληνική σημαία κυματίζει.': 'voice/narrator/081.mp3',
  'Ο ήλιος βυθίζεται στον Κορινθιακό. Χρυσό, πορτοκαλί, ροζ. Τα βουνά γίνονται σκιές.': 'voice/narrator/082.mp3',
  'Κανείς δεν μιλάει. Δεν χρειάζεται.': 'voice/narrator/083.mp3',
  'Σχοινιά τυλιγμένα στο κατάστρωμα. Μυρίζουν θάλασσα και πεύκο.': 'voice/narrator/084.mp3',
  'Πορτοκαλί σωσίβιο. Λευκά γράμματα: ΕΛΠΙΔΑ — ΓΑΛΑΞΙΔΙ.': 'voice/narrator/085.mp3',
  'Το Γαλαξίδι λάμπει στον ήλιο του δειλινού. Σπίτια, εκκλησίες, το λιμάνι — σαν μακέτα.': 'voice/narrator/086.mp3',
  'Η Ελπίδα πλέει αργά στον Κορινθιακό. Ο κόσμος σταμάτησε.': 'voice/narrator/087.mp3',
  'Μαρμάρινη πλάκα, πιο μεγαλοπρεπής από τις άλλες. Χαραγμένο: «Πλοίαρχος Λ. Βισβίζης».': 'voice/narrator/088.mp3',
  'Η πέτρα ήδη τοποθετήθηκε. Η πλάκα λάμπει αχνά.': 'voice/narrator/089.mp3',
  'Ο Ντέμης τοποθετεί την πράσινη πέτρα τζέιντ στην εσοχή της πλάκας...': 'voice/narrator/090.mp3',
  'Μαρμάρινοι σταυροί και πλάκες. Ονόματα καπεταναίων: Τσώνης, Ρήγας, Μαμάς, Χρυσοβαλάντου.': 'voice/narrator/091.mp3',
  'Κυπαρίσσια ψηλά σαν κατάρτια. Φρουροί αιώνιοι.': 'voice/narrator/092.mp3',
  'Κόκκινες παπαρούνες ανάμεσα στους τάφους. Η ζωή εκεί που αναπαύεται ο θάνατος.': 'voice/narrator/093.mp3',
  'Η θάλασσα λάμπει χρυσή από το ηλιοβασίλεμα. Ακόμα και μετά θάνατον, οι καπετάνιοι βλέπουν τη θάλασσα.': 'voice/narrator/094.mp3',
  'Ένα ιστιοφόρο στον ορίζοντα. Σαν φάντασμα του παρελθόντος.': 'voice/narrator/095.mp3',
  'Πλακόστρωτο μονοπάτι ανάμεσα στους τάφους. Λειασμένο από χιλιάδες επισκέψεις.': 'voice/narrator/096.mp3',
  'Σκιές τρεμοπαίζουν ανάμεσα στα κυπαρίσσια. Σαν να κινείται κάτι...': 'voice/narrator/097.mp3',
  'Μια αχνή, ψηλή σιλουέτα κοντά στα κυπαρίσσια. Τρεμοπαίζει σαν φως σε νερό.': 'voice/narrator/098.mp3',
  'Δεν υπάρχει κανείς εδώ... ακόμα.': 'voice/narrator/099.mp3',
  'Το φάντασμα δεν μιλάει. Δείχνει προς την εκκλησία.': 'voice/narrator/100.mp3',
  'Το παλιό νεκροταφείο. Θέα στη θάλασσα, μυρωδιά θυμαριού, ησυχία.': 'voice/narrator/101.mp3',
  'Ο αέρας αλλάζει. Η θερμοκρασία πέφτει. Τα κυπαρίσσια σταματούν να κουνιούνται.': 'voice/narrator/102.mp3',
  'Μια φιγούρα υψώνεται πάνω από τον τάφο. Ψηλός, αυστηρός, με ναυτική στολή από άλλη εποχή.': 'voice/narrator/103.mp3',
  'Το φάντασμα σηκώνει αργά το χέρι. Δείχνει... προς τον Άγιο Νικόλαο.': 'voice/narrator/104.mp3',
  'Τίποτα ιδιαίτερο.': 'voice/narrator/105.mp3',
  'Το χαρτί μυρίζει θάλασσα. Παλιομοδίτικο γράψιμο.': 'voice/narrator/106.mp3',
  'Ο ήλιος βυθίζεται πίσω από τα βουνά. Το λιμάνι περιμένει.': 'voice/narrator/107.mp3',
  '— Τέλος Σκηνής 1 —': 'voice/narrator/108.mp3',
  'Συνέχεια στη Σκηνή 2: Το Γράμμα...': 'voice/narrator/109.mp3',
  'Λατσούδη! Περίμενα πότε θα φτάσεις.': 'voice/athos/001.mp3',
  'Ξέρω τον παππού σου. Ήξερα. Και ξέρω τι ψάχνεις.': 'voice/athos/002.mp3',
  'Ο Βισβίκης άφησε διαθήκη. Αν θέλεις απαντήσεις, ψάξε στο σπήλαιο του Κάρκαρου.': 'voice/athos/003.mp3',
  'Άδειο. Κρίμα!': 'voice/ajax/001.mp3',
  'Μπαμπά, θα πάμε βόλτα με βάρκα;': 'voice/ajax/002.mp3',
  'Τέλειο! Πάμε κατευθείαν στο λιμάνι;': 'voice/ajax/003.mp3',
  'Δελφίνια μέσα στο λιμάνι; Αυτό δεν είναι συνηθισμένο...': 'voice/ajax/004.mp3',
  'Μπαμπά, μπορώ να φάω ένα;': 'voice/ajax/005.mp3',
  'Ποιος είναι ο «Γ.»;': 'voice/ajax/006.mp3',
  'Και κάτι πάνω στην καρέκλα... μια τσάντα;': 'voice/ajax/007.mp3',
  'Μπαμπά, μπορώ να πηδήξω σε κάποιο;': 'voice/ajax/008.mp3',
  'Αυτό το λιμάνι φαίνεται τεράστιο για τόσο μικρό χωριό.': 'voice/ajax/009.mp3',
  'Γιατί; Ήταν χαζοί;': 'voice/ajax/010.mp3',
  'Ε, λίγο μόνο.': 'voice/ajax/011.mp3',
  'Εγώ θέλω να δω αν έχει κανόνια.': 'voice/ajax/012.mp3',
  'Εγώ μπορώ να πάρω λεμονάδα;': 'voice/ajax/013.mp3',
  'Αυτό μοιάζει σαν πειρατικό καπηλειό!': 'voice/ajax/014.mp3',
  'Ή σαν τιμόνι καραβιού!': 'voice/ajax/015.mp3',
  'Μπορώ να κολυμπήσω;': 'voice/ajax/016.mp3',
  'Μήπως είχε ρούμι;': 'voice/ajax/017.mp3',
  'Σαν εκκλησία!': 'voice/ajax/018.mp3',
  'Η πόρτα! Κοιτάξτε αυτή την τεράστια πόρτα!': 'voice/ajax/019.mp3',
  'Πάλι γάτα;': 'voice/ajax/020.mp3',
  'Τι; Τι βλέπεις;': 'voice/ajax/021.mp3',
  'Πού; Δείξε μου!': 'voice/ajax/113.mp3',
  'Πώς φτάνεις εκεί; Με βάρκα;': 'voice/ajax/114.mp3',
  'Μπαμπά, βλέπω μέχρι την Ιτέα!': 'voice/ajax/022.mp3',
  'ΤΕΛΕΙΟ! Βλέπω τα πάντα από εδώ!': 'voice/ajax/023.mp3',
  'Ξέρω κόμπους! Ο παππούς μου έμαθε.': 'voice/ajax/024.mp3',
  'Μπαμπά, μπορούμε να μείνουμε για πάντα εδώ;': 'voice/ajax/025.mp3',
  'Αυτός είναι ο καπετάνιος από το γράμμα!': 'voice/ajax/026.mp3',
  'Τους έβαλαν εδώ επίτηδες. Να βλέπουν.': 'voice/ajax/027.mp3',
  'Φάντασμα; Σοβαρά τώρα;': 'voice/ajax/028.mp3',
  'Κοίτα — βλέπεις τη θάλασσα από κάθε τάφο. Αυτό ήθελαν.': 'voice/ajax/029.mp3',
  'Τι γίνεται; Γιατί σκοτείνιασε;': 'voice/ajax/030.mp3',
  'Μπαμπά, βλέπω μέσα από αυτόν!': 'voice/ajax/031.mp3',
  'Αυτό... αυτό μόλις έγινε. Δεν ονειρεύομαι.': 'voice/ajax/032.mp3',
  'Πάμε στο λιμάνι!': 'voice/ajax/033.mp3',
  'Ε, Ντέμη! Τα παιδιά μεγάλωσαν!': 'voice/akis/001.mp3',
  'Ένα παλιό τραγούδι ναυτικό. Πήγαινε στο μουσείο — θα καταλάβεις.': 'voice/akis/002.mp3',
  '...': 'voice/giannis/001.mp3',
  'Το ξέρω. Σε βλέπω από εδώ πάνω.': 'voice/giannis/002.mp3',
  'Πάρε αυτό. Θα το χρειαστείς.': 'voice/giannis/003.mp3',
  'Καλώς ήρθατε! Βλέπω ξέρετε να εκτιμάτε την ιστορία.': 'voice/curator/001.mp3',
  'Τριακόσια πλοία! Η Χρυσούλα ήταν το τελευταίο. Τα ατμόπλοια τα σκότωσαν όλα.': 'voice/curator/002.mp3',
  'Ωραία ερώτηση, μικρή. Ήταν τόσο καλοί στα πανιά, που δεν φαντάζονταν κόσμο χωρίς αυτά.': 'voice/curator/003.mp3',
  'Μπαμπά, μην τις κόβεις! Είναι τέλειες έτσι.': 'voice/clio/001.mp3',
  'Πρώτα ας αφήσουμε τις βαλίτσες. Θέλω να δω τη βεράντα.': 'voice/clio/002.mp3',
  'Μπαμπά, κοίτα! Δελφίνια!': 'voice/clio/003.mp3',
  'Οι Αμφικτίονες ξεκινούσαν από τους Δελφούς... Το Γαλαξίδι ήταν λιμάνι τους.': 'voice/clio/004.mp3',
  'Μπαμπά, μην ακουμπάς, φαίνεται παλιό!': 'voice/clio/005.mp3',
  'Αυτό είναι το πιο όμορφο μέρος στον κόσμο.': 'voice/clio/006.mp3',
  'Μπαμπά, κοίτα — υπάρχει κάτι μέσα.': 'voice/clio/007.mp3',
  'Διάβασέ το!': 'voice/clio/008.mp3',
  'Κοιτάξτε — κάποιος μας άφησε σύκα!': 'voice/clio/009.mp3',
  'Γιατί είναι τόσο μεγάλες;': 'voice/clio/010.mp3',
  'Αυτοί ξέρουν τα πάντα. Αν μιλούσαν...': 'voice/clio/011.mp3',
  'Πόσο τέλεια! Αυτή η πορτοκαλί μου αρέσει πολύ.': 'voice/clio/012.mp3',
  'Θείε Άκη, τι παίζεις;': 'voice/clio/013.mp3',
  'Τριακόσια καράβια, μπαμπά. Το διάβασα.': 'voice/clio/014.mp3',
  'Κοιτάξτε τα πανιά! Ένα-ένα ραμμένα.': 'voice/clio/015.mp3',
  'Αυτός μοιάζει λίγο με τον μπαμπά.': 'voice/clio/016.mp3',
  'Χωρίς GPS; Πώς;': 'voice/clio/017.mp3',
  'Μπαμπά, σημείωσε αυτό. Μπορεί να μας χρειαστεί.': 'voice/clio/018.mp3',
  'Γιατί δεν έφτιαξαν κι αυτοί ατμόπλοια;': 'voice/clio/019.mp3',
  'Πόσα μοντέλα! Θέλω να τα δω ΟΛΑ.': 'voice/clio/020.mp3',
  'Φανταστείτε πόσα χέρια το γύρισαν.': 'voice/clio/021.mp3',
  'Μαγικό. Σαν πίνακας ζωγραφικής.': 'voice/clio/022.mp3',
  'Σπήλαιο; Θα πάμε σε σπήλαιο;!': 'voice/clio/023.mp3',
  'Μυρίζει ωραία. Σαν τη γιαγιά.': 'voice/clio/024.mp3',
  'Δώδεκα θέσεις. Σαν ρολόι.': 'voice/clio/025.mp3',
  'Αυτά δεν είναι πειρατικά. Είναι σημάδια καπεταναίων!': 'voice/clio/026.mp3',
  'Ο Κάρκαρος. Λέγανε ότι η φωνή σου γυρίζει πίσω τρεις φορές.': 'voice/clio/027.mp3',
  'Σαν να σε καλεί μέσα.': 'voice/clio/028.mp3',
  'Μπαμπά... αυτό δεν μοιάζει σπήλαιο. Μοιάζει σαν κάποιος να το έφτιαξε.': 'voice/clio/029.mp3',
  'Ρίχνω ένα νόμισμα;': 'voice/clio/030.mp3',
  'Την ξαναβρήκα! Αυτή είναι η ίδια από το λιμάνι.': 'voice/clio/031.mp3',
  'Γεια σου, μικρούλα. Με ακολουθείς;': 'voice/clio/032.mp3',
  'Τι ωραία πλατεία! Και γάτα!': 'voice/clio/033.mp3',
  'Αφήστε με να κοιτάξω!': 'voice/clio/034.mp3',
  'Βλέπω... ένα νησάκι! Με ένα λευκό εκκλησάκι πάνω στον βράχο!': 'voice/clio/035.mp3',
  'Εκεί, στη μέση του κόλπου. Λάμπει στον ήλιο!': 'voice/clio/036.mp3',
  'Κοίτα... ένα νησάκι με εκκλησάκι! Στη μέση του κόλπου!': 'voice/clio/113.mp3',
  'Και τους Δελφούς! Εκεί πάνω!': 'voice/clio/037.mp3',
  'Θέλω να ζωγραφίσω αυτά.': 'voice/clio/038.mp3',
  'Μπαμπά, κοίτα — ένα τηλεσκόπιο!': 'voice/clio/039.mp3',
  'Ποιος πάει εκεί πάνω για λειτουργία;': 'voice/clio/040.mp3',
  'Από εδώ φαίνεται σαν παραμύθι.': 'voice/clio/041.mp3',
  'Αυτό... αυτό είναι τέλειο.': 'voice/clio/042.mp3',
  'Κοίτα κάτω — «Η θάλασσα θυμάται».': 'voice/clio/043.mp3',
  'Κάθε πέτρα και ένα ταξίδι.': 'voice/clio/044.mp3',
  'Μπαμπά, δεν είναι τρομακτικό. Είναι... ωραίο.': 'voice/clio/045.mp3',
  'Μπαμπά... νιώθω κάτι εδώ.': 'voice/clio/046.mp3',
  'Μπαμπά... βλέπω κάτι εκεί.': 'voice/clio/047.mp3',
  'Θέλει να πάμε στον Άγιο Νικόλαο!': 'voice/clio/048.mp3',
  'Μπαμπά... δεν μου αρέσουν τα νεκροταφεία.': 'voice/clio/049.mp3',
  'Μπαμπά... η πέτρα λάμπει!': 'voice/clio/050.mp3',
  'Ο... ο Καπετάν Βισβίζης;': 'voice/clio/051.mp3',
  'Ο χάρτης. Θέλει να βρούμε τον χάρτη.': 'voice/clio/052.mp3',
  'Περίμενε 120 χρόνια. Για κάποιον σαν εμάς.': 'voice/clio/053.mp3',
  'Ο «Γ.» ξέρει ότι είμαστε τρεις. Πρέπει να πάμε.': 'voice/clio/054.mp3',
  'Ας μπούμε μέσα.': 'voice/ntemis/001.mp3',
  'Φτάσαμε, παιδιά. Αυτό είναι το σπίτι μας για το Σαββατοκύριακο.': 'voice/ntemis/002.mp3',
  'Καλωσορίσατε στο Γαλαξίδι.': 'voice/ntemis/003.mp3',
  'Φυσικά.': 'voice/ntemis/004.mp3',
  'Και πώς ξέρει ότι είμαστε τρεις;': 'voice/ntemis/005.mp3',
  'Δεν είναι δική μας. Ας κοιτάξω μέσα πρώτα.': 'voice/ntemis/006.mp3',
  'Μπορείς να κοιτάξεις. Από εδώ.': 'voice/ntemis/007.mp3',
  'Γιατί κάποτε εδώ δένανε ιστιοφόρα πενήντα μέτρων.': 'voice/ntemis/008.mp3',
  'Καλησπέρα! Πολύ ψάρι σήμερα;': 'voice/ntemis/009.mp3',
  'Στάθη! Πόσο καιρό!': 'voice/ntemis/010.mp3',
  'Γιατί κάποτε δεν ήταν μικρό χωριό. Ήταν ναυτική δύναμη.': 'voice/ntemis/011.mp3',
  'Αυτό ήταν το μέλλον. Και το Γαλαξίδι δεν το είδε.': 'voice/ntemis/012.mp3',
  'Όχι. Ήταν οι καλύτεροι στα πανιά. Γι\u0027 αυτό ακριβώς δεν άλλαξαν.': 'voice/ntemis/013.mp3',
  'Ευχαριστώ, νομίζω.': 'voice/ntemis/014.mp3',
  'Αστέρια, εμπειρία, και θάρρος.': 'voice/ntemis/015.mp3',
  'Τα παιδιά μου ήθελαν να δουν τα καράβια.': 'voice/ntemis/016.mp3',
  'Σσσ. Μουσείο, παιδιά. Ησυχία.': 'voice/ntemis/017.mp3',
  'Κάθε φωτογραφία και μια ιστορία. Κάθε πρόσωπο και μια ζωή.': 'voice/ntemis/018.mp3',
  'Κάτσε. Ξεκουράσου. Η νύχτα είναι μακριά.': 'voice/ntemis/019.mp3',
  'Με ξέρεις;': 'voice/ntemis/020.mp3',
  'Ελάτε, ας δούμε ποιος είναι εδώ.': 'voice/ntemis/021.mp3',
  'Κάτι πρέπει να μπει σε κάθε εσοχή. Αλλά τι;': 'voice/ntemis/022.mp3',
  'Δεν κουνιέται. Χρειαζόμαστε κάτι για τις εσοχές.': 'voice/ntemis/023.mp3',
  'Δεν έχουμε αρκετά ακόμα. Πρέπει να ψάξουμε περισσότερο.': 'voice/ntemis/024.mp3',
  'Σωστά. Κάθε καπετάνιος είχε το δικό του σήμα. Αυτοί οι τοίχοι θυμούνται.': 'voice/ntemis/025.mp3',
  'Όχι τώρα, Αία. Ποιος ξέρει πόσο βαθιά είναι.': 'voice/ntemis/026.mp3',
  'Πιθανόν, κάποτε.': 'voice/ntemis/027.mp3',
  'Δώδεκα εσοχές. Σαν τιμόνι πλοίου. Κάτι μας λείπει.': 'voice/ntemis/028.mp3',
  'Γιατί όχι; Κάνε μια ευχή.': 'voice/ntemis/029.mp3',
  'Κάθε καπετάνιος προσευχόταν εδώ πριν φύγει. Και η οικογένειά του μετά.': 'voice/ntemis/030.mp3',
  'Ο Άγιος Νικόλαος. Προστάτης των ναυτικών. Κατάλληλος για το Γαλαξίδι.': 'voice/ntemis/031.mp3',
  'Σημείωσέ το, Κλειώ.': 'voice/ntemis/032.mp3',
  'Ο Άγιος Γεώργιος. Σημείωσέ τον, Κλειώ.': 'voice/ntemis/130.mp3',
  'Ο Άγιος Γεώργιος. Λένε ότι οι ψαράδες πάνε εκεί πριν κάθε ταξίδι.': 'voice/ntemis/131.mp3',
  'Γεια σου. Ψάχνουμε το σπήλαιο του Κάρκαρου.': 'voice/ntemis/033.mp3',
  'Ένα σημείο παρατήρησης. Κάποιος παρακολουθούσε τα πλοία από εδώ.': 'voice/ntemis/034.mp3',
  'Ελπίδα. Πάντα υπάρχει ελπίδα.': 'voice/ntemis/035.mp3',
  'Οι ψαράδες. Πριν και μετά το ταξίδι.': 'voice/ntemis/036.mp3',
  'Δείξε μας.': 'voice/ntemis/037.mp3',
  'Για λίγο ακόμα. Κοιτάξτε τον ήλιο.': 'voice/ntemis/038.mp3',
  'Λείπει κάτι. Η εσοχή στην πλάκα... σαν να περιμένει κάτι.': 'voice/ntemis/039.mp3',
  'Κάθε πέτρα και μια οικογένεια που περίμενε.': 'voice/ntemis/040.mp3',
  'Μόλις μας έδωσε οδηγίες ένα φάντασμα.': 'voice/ntemis/041.mp3',
  'Αυτό δεν είναι τρομακτικό. Είναι γεμάτο ιστορίες.': 'voice/ntemis/042.mp3',
  'Στην εκκλησία; Τι κρύβεται εκεί;': 'voice/ntemis/043.mp3',
  'Στον Άγιο Νικόλαο. Τώρα.': 'voice/ntemis/044.mp3',
  'Δεν μπορώ να μιλήσω σε αυτό.': 'voice/ntemis/045.mp3',
  'Δεν ανοίγει.': 'voice/ntemis/046.mp3',
  'Δεν ξέρω πώς.': 'voice/ntemis/047.mp3',
  '«Σας περιμέναμε»... Ποιος μας περιμένει;': 'voice/ntemis/048.mp3',
  'Ντέμη! Τι κάνεις εδώ; Πάρε μια καρέκλα!': 'voice/stathis/001.mp3',
  'Ψάχνεις κάτι; Ρώτα τον Άθο στο Λιοτρίβι. Ξέρει τα πάντα για τις παλιές οικογένειες.': 'voice/stathis/002.mp3',
  'Ποιος είναι αυτός;': 'voice/clio/055.mp3',
  'Ο Καπετάν Βισβίκης. Ο προπάππους μου.': 'voice/ntemis/049.mp3',
  'Φέρε τη σε μένα... Είναι νεκρός εδώ και εκατό χρόνια.': 'voice/ajax/034.mp3',
  'Στο νεκροταφείο, βλάκα.': 'voice/clio/056.mp3',
  '...Κλειώ.': 'voice/ntemis/050.mp3',
  'Τι; Λογικό είναι.': 'voice/clio/057.mp3',
  'Ποιου παππού;': 'voice/ajax/035.mp3',
  'Του προπάππου μου. Κανένας δεν έχει μπει εδώ χρόνια. Κληρονομιά.': 'voice/ntemis/051.mp3',
  'Θα έχει φαντάσματα;': 'voice/clio/058.mp3',
  '...Όχι, Κλειώ. Θα έχει σκόνη.': 'voice/ntemis/052.mp3',
  'Μοντέλα πλοίων σε ράφια, ορειχάλκινα όργανα, χάρτες στους τοίχους. Μια ξεθωριασμένη φωτογραφία.': 'voice/narrator/110.mp3',
  'Ένα κλειδωμένο συρτάρι στο γραφείο. Χρειάζεται κλειδί.': 'voice/narrator/111.mp3',
  'Ένα χάλκινο δοχείο στο τζάκι. Κάτι κουδουνίζει μέσα.': 'voice/narrator/112.mp3',
  'Ένα παλιό γράμμα, σφραγισμένο με κερί. Η γραφή είναι σχολαστική, αρχαϊκή.': 'voice/narrator/113.mp3',
  'Πόσα χρόνια, ρε παιδιά;': 'voice/ntemis/053.mp3',
  'Αρκετά. Αλλά το Γαλαξίδι δε σ\' αφήνει να ξεχάσεις.': 'voice/akis/003.mp3',
  'Λυπημένο αλλά ωραίο.': 'voice/clio/059.mp3',
        'Αν θέλεις να καταλάβεις τον Βισβίκη, πρέπει να δεις πρώτα τι έχασε το Γαλαξίδι. Εκεί ζει η ιστορία.': 'voice/akis/006.mp3',
  'Και μίλα στον Άθο στο Λιοτρίβι. Ξέρει κάθε οικογένεια, κάθε μυστικό. Διάβασε και τη διαθήκη.': 'voice/stathis/004.mp3',
  'Σαν να παίζουν για τη θάλασσα.': 'voice/clio/060.mp3',
  'Γιατί αυτό κάνουμε, μικρή.': 'voice/akis/007.mp3',
      'Δηλαδή... ήταν οι καλύτεροι, κι αυτό τους έκανε χειρότερους;': 'voice/ajax/036.mp3',
    'Εκατόν τέσσερις υπογραφές. Σαν ομάδα.': 'voice/ajax/037.mp3',
  'Η πιο σημαντική ομάδα που είχε ποτέ αυτή η πόλη.': 'voice/curator/007.mp3',
    'Εμείς ξέρουμε! Εκεί που η γη μιλάει.': 'voice/ajax/038.mp3',
  'Μη με ρωτήσεις αν αξίζεις. Πήγαινε και δείξ\' το.': 'voice/athos/005.mp3',
  'Αλλά στο μουσείο είπαν ότι οι καπεταναίοι ήταν σπουδαίοι ΚΑΙ πεισματάρηδες.': 'voice/ajax/039.mp3',
  'Ήταν. Τα δύο πάνε μαζί πιο συχνά απ\' ό,τι νομίζεις.': 'voice/athos/006.mp3',
  'Ποιο είναι το ατμόπλοιο σήμερα; Ποιο είναι αυτό που έρχεται, και πρέπει να το πιάσουμε αυτή τη φορά;': 'voice/athos/007.mp3',
  'Μοιάζεις με δικαστή.': 'voice/clio/061.mp3',
  'Χειρότερα. Δικηγόρος.': 'voice/athos/008.mp3',
  'Ξέρεις γιατί αγόρασα τον μύλο; Γιατί από εδώ βλέπεις τα πάντα.': 'voice/giannis/004.mp3',
    'Ήταν του πατέρα μου. Ναυτικός. Πάρ\' το.': 'voice/giannis/005.mp3',
  'Βλέπω το νησάκι! Εκεί θα πάμε;': 'voice/ajax/040.mp3',
  'Αν βρούμε αυτό που ψάχνουμε στο σπήλαιο.': 'voice/ntemis/054.mp3',
  'Σαν τον Βισβίκη. Αυτός ήθελε να μείνει κάτι.': 'voice/clio/062.mp3',
  'Μπαμπά, κοίτα — ο Βισβίκης ήταν εδώ. Λ.Β. 1887.': 'voice/ajax/041.mp3',
  'Πρόταση για ατμόπλοιο. Απορρίφθηκε, 9 προς 3.': 'voice/ajax/042.mp3',
  'Τρεις ήξεραν. Και κανείς δεν τους άκουσε.': 'voice/ajax/043.mp3',
  'Νεφρίτης. Jade. Από την Ανατολή, σίγουρα.': 'voice/ntemis/055.mp3',
  'Αξίζει κάτι;': 'voice/ajax/044.mp3',
  'Αξίζει ό,τι ο Βισβίκης ήθελε να δείξει μ\' αυτό. Τώρα πρέπει... να του το πάμε.': 'voice/ntemis/056.mp3',
  'Σας το είπα.': 'voice/clio/063.mp3',
  '...Στο νεκροταφείο.': 'voice/ajax/045.mp3',
  'Σας. Το. Είπα.': 'voice/clio/064.mp3',
  'Ο Ντέμης σκύβει στη ρωγμή. Τα δάχτυλά του αγγίζουν κάτι λείο, ζεστό...': 'voice/narrator/219.mp3',
  'Κάτι αντηχεί βαθιά μέσα στον βράχο. Οι σταγόνες σταματούν. Σιωπή.': 'voice/narrator/220.mp3',
  'ΕΚΕΙ! Κάτι πράσινο — λάμπει!': 'voice/clio/114.mp3',
  'Αιωρείται! Μπαμπά, η πέτρα αιωρείται!': 'voice/ajax/115.mp3',
  'Η πέτρα αιωρείται στο κέντρο του σπηλαίου, τυλιγμένη σε πράσινο φως. Σκούρα πράσινη, λεία, ζεστή σαν να ζει.': 'voice/narrator/221.mp3',
  'Μόλις μας έδωσε οδηγίες ο προπάππους μου.': 'voice/ntemis/057.mp3',
  'Κουρασμένος αλλά χαρούμενος. Σαν κάποιος που τελικά μπορεί να κοιμηθεί.': 'voice/clio/065.mp3',
  'Πάτερ, ψάχνουμε κάτι που άφησε ο Καπετάν Βισβίκης.': 'voice/ntemis/058.mp3',
  'Ο Βισβίκης ήταν ο μεγαλύτερος ευεργέτης αυτής της εκκλησίας. Πλήρωσε τη στέγη, τις εικόνες, το τέμπλο.': 'voice/papas/001.mp3',
  'Κάθε ταξίδι ξεκινούσε με προσευχή εδώ. Κάθε ασφαλής επιστροφή τελείωνε με κερί ευχαριστίας.': 'voice/papas/002.mp3',
  'Για ποιον;': 'voice/papas/003.mp3',
  'Για τους καπεταναίους. Και τα πλοία τους.': 'voice/clio/066.mp3',
  'Αυτό, παιδί μου, είναι ακριβώς αυτό που έκαναν κι εκείνοι.': 'voice/papas/004.mp3',
  'ΟΧΙ στις εικόνες!': 'voice/papas/005.mp3',
  'Μπαμπά. Το πάτωμα.': 'voice/clio/067.mp3',
  'Ένα πλακάκι κοντά στο ιερό έχει το σημάδι του Βισβίκη — Λ.Β. Είναι χαλαρό.': 'voice/narrator/114.mp3',
  'Κάτω από το πλακάκι: ένας τυλιγμένος ναυτικός χάρτης, σφραγισμένος σε κηρόπανο.': 'voice/narrator/115.mp3',
  'Ξέρω αυτό το νησάκι! Μπορούμε να πάμε με βάρκα!': 'voice/ajax/046.mp3',
    'Παιδί μου, ο Θεός και η θάλασσα κανένα δεν σε ρωτάει αν είσαι έτοιμος.': 'voice/papas/007.mp3',
  'Ο πατέρας σου μου είπε ότι κάποια μέρα θα ερχόσουν. Δεν πίστευα ότι θα ζούσα να το δω.': 'voice/chrysostomos/001.mp3',
  'Ήταν ο τελευταίος ρομαντικός. Ταξίδεψε μέχρι την Ανατολή κι επέστρεψε. Κανείς δεν τον πίστεψε. Πέθανε μόνος. Αλλά δεν πέθανε χωρίς σχέδιο.': 'voice/chrysostomos/002.mp3',
  'Η θάλασσα δεν σε ρωτάει τι αγαπάς. Η θάλασσα αλλάζει κι εσύ αλλάζεις μαζί της, αλλιώς πνίγεσαι.': 'voice/chrysostomos/003.mp3',
  'Η Ελπίδα ξέρει τον δρόμο. Εγώ απλά κρατάω το τιμόνι.': 'voice/chrysostomos/004.mp3',
  'Η Ελπίδα πλέει αργά στον Κορινθιακό. Το Γαλαξίδι μικραίνει πίσω τους.': 'voice/narrator/116.mp3',
  'Ένα μικρό νησάκι με ένα λευκό παρεκκλήσι. Άγιος Γεώργιος.': 'voice/narrator/117.mp3',
  'Ο βράχος κοιτάει νοτιοδυτικά. Κάτω από τον σταυρό, πέντε βήματα.': 'voice/narrator/118.mp3',
  'Το φτυάρι χτυπάει ξύλο.': 'voice/narrator/119.mp3',
  'Ένα θαλασσινό σεντούκι. Παλιό, σιδερόδετο. Ο Βισβίκης έφτιαχνε πράγματα που αντέχουν.': 'voice/narrator/120.mp3',
  'Χρυσά νομίσματα — Οθωμανικά, Βενετσιάνικα, αρχαία Ελληνικά. Ένα κολιέ από νεφρίτη. Και ένα βιβλίο — το πρωτότυπο βιβλίο της αλληλασφάλειας.': 'voice/narrator/121.mp3',
  'Αυτός ο θησαυρός δεν είναι δικός μου. Είναι του Γαλαξειδίου.': 'voice/narrator/122.mp3',
  'Ταξίδεψα στην Ανατολή και γύρισα πλούσιος. Αλλά ο αληθινός πλούτος δεν είναι ο χρυσός. Είναι αυτό που χτίσαμε μαζί — η αλληλεγγύη. Κανείς δεν ταξιδεύει μόνος.': 'voice/narrator/123.mp3',
  'Κράτα την αλληλεγγύη. Άλλαξε το πλοίο.': 'voice/narrator/124.mp3',
  'Μπαμπά, τι θα κάνουμε;': 'voice/clio/068.mp3',
  'Αυτό που ήθελε ο Βισβίκης. Θα τα δώσουμε στο Γαλαξίδι.': 'voice/ntemis/059.mp3',
  'Εκατό τέσσερις. Εκατό τέσσερις άνθρωποι υπέγραψαν. Κανένας δεν ταξιδεύει μόνος.': 'voice/ajax/047.mp3',
  'Αν ο Βισβίκης μπορούσε να δει τώρα, θα χαμογελούσε;': 'voice/clio/069.mp3',
  'Ναι, μικρή μου. Νομίζω ότι τώρα, μπορεί επιτέλους να κοιμηθεί.': 'voice/ntemis/060.mp3',
  'Ο Βισβίκης δεν μας άφησε θησαυρό. Μας άφησε ερώτηση. Τι κάνεις όταν ο κόσμος αλλάζει κι εσύ αγαπάς αυτό που ήταν;': 'voice/ntemis/061.mp3',
  'Ο Άκης ξέρει να κρατάει ιστορίες ζωντανές. Το έκανε στην Άμφισσα. Θα το κάνει και για το Γαλαξίδι.': 'voice/ntemis/062.mp3',
  'Τριάντα χρόνια κινηματογραφώ τόπους που σβήνουν. Το Γαλαξίδι δεν θα σβήσει. Αυτή τη φορά δεν γράφω ελεγείο. Γράφω αρχή.': 'voice/akis/008.mp3',
  'Ο χρυσός θα χρηματοδοτήσει τρία πράγματα. Το ντοκιμαντέρ. Την αποκατάσταση του μουσείου. Και κάτι καινούριο.': 'voice/athos/009.mp3',
  'Οι καπεταναίοι αρνήθηκαν τον ατμό. Δεν θα κάνουμε το ίδιο λάθος. Το ατμόπλοιο σήμερα λέγεται τεχνητή νοημοσύνη.': 'voice/ntemis/063.mp3',
  'Και τι γίνεται με μέρη σαν εδώ;': 'voice/ajax/048.mp3',
  'Σε έναν κόσμο που τρέχει, τα μέρη που αναπνέουν γίνονται ο νέος παράδεισος. Το Γαλαξίδι δεν χρειάζεται να γίνει σαν την Αθήνα. Χρειάζεται να γίνει περισσότερο Γαλαξίδι.': 'voice/ntemis/064.mp3',
  'Η αλληλασφάλεια ήταν 104 υπογραφές. Σήμερα ζητάω τις δικές σας.': 'voice/ntemis/065.mp3',
  'Μπαμπά, πόσες υπογραφές;': 'voice/ajax/049.mp3',
  'Εκατόν τρεις. Λείπει μία.': 'voice/ntemis/066.mp3',
  'Εκατόν τέσσερις.': 'voice/ajax/050.mp3',
  'Ο Καπετάν Βισβίκης ταξίδεψε στην Ανατολή, γύρισε πλούσιος, κι έκρυψε τον θησαυρό του για κάποιον που θα αγαπούσε το Γαλαξίδι αρκετά για να τον βρει.': 'voice/narrator/125.mp3',
  'Εκατόν είκοσι χρόνια αργότερα, τρεις ταξιδιώτες τον βρήκαν.': 'voice/narrator/126.mp3',
  'Οι παλιοί καπεταναίοι αρνήθηκαν τον ατμό. Οι νέοι δεν θα κάνουν το ίδιο λάθος.': 'voice/narrator/127.mp3',
  'Εκατόν τέσσερις υπογραφές. Τότε και τώρα.': 'voice/narrator/128.mp3',
  'Η θάλασσα θυμάται. Κι εμείς τώρα, αλλάζουμε μαζί της.': 'voice/narrator/129.mp3',
  'Κράτα την αλληλεγγύη. Άλλαξε το πλοίο. Το Μυστήριο του Γαλαξειδίου.': 'voice/narrator/130.mp3',
  'Μοντέλα πλοίων σε ράφια — σκούνες, μπρίκια, τρικάταρτα. Μικρογραφίες μιας χαμένης αυτοκρατορίας.': 'voice/narrator/208.mp3',
  'Μια ξεθωριασμένη φωτογραφία σε χρυσή κορνίζα. Ένας άντρας με καπετάνιος στολή, λευκά μουστάκια, περήφανο βλέμμα.': 'voice/narrator/207.mp3',
  'Ο Καπετάν Λουκάς Βισβίκης. Τα μάτια του σε ακολουθούν.': 'voice/narrator/210.mp3',
  'Το συρτάρι είναι ανοιχτό. Άδειο πλέον.': 'voice/narrator/215.mp3',
  'Μπαμπά, είναι κλειδωμένο! Πού είναι το κλειδί;': 'voice/ajax/086.mp3',
  'Το συρτάρι είναι ήδη ανοιχτό.': 'voice/narrator/216.mp3',
  'Κλειδωμένο. Χρειάζεσαι κλειδί.': 'voice/narrator/205.mp3',
  'Ψάξτε γύρω! Πρέπει να είναι κάπου εδώ.': 'voice/clio/110.mp3',
  'Γυρίζεις το κλειδί. Κλικ. Το συρτάρι ανοίγει αργά...': 'voice/narrator/200.mp3',
  'Μέσα — ένα παλιό γράμμα, σφραγισμένο με κερί.': 'voice/narrator/206.mp3',
  'Μπαμπά, διάβασέ το!': 'voice/clio/105.mp3',
  'Ένα χάλκινο δοχείο στο τζάκι. Τώρα άδειο.': 'voice/narrator/202.mp3',
  'Το δοχείο είναι άδειο.': 'voice/narrator/214.mp3',
  'Ανοίγεις το δοχείο. Μέσα — ένα μικρό ορειχάλκινο κλειδί!': 'voice/narrator/199.mp3',
  'Εγώ το βρήκα! Εγώ κοίταξα πρώτη!': 'voice/clio/101.mp3',
  'Δοκίμασέ το στο συρτάρι!': 'voice/ajax/082.mp3',
  'Πέτρινο τζάκι με στάχτες. Πάνω του — ένα χάλκινο δοχείο.': 'voice/narrator/212.mp3',
  'Ορειχάλκινα ναυτικά όργανα: πυξίδα, εξάντας, τηλεσκόπιο. Γυαλισμένα σαν χθες.': 'voice/narrator/211.mp3',
  'Χάρτες στους τοίχους. Δρομολόγια προς Σμύρνη, Αλεξάνδρεια, Βηρυτό. Με μελάνι σημειωμένα.': 'voice/narrator/217.mp3',
  'Το γραφείο του καπετάνιου. Σκόνη και μνήμη.': 'voice/narrator/213.mp3',
  'Μοντέλα πλοίων σε ράφια, ορειχάλκινα όργανα, χάρτες στους τοίχους.': 'voice/narrator/209.mp3',
  'Ουάου! Κοιτάξτε όλα αυτά τα πλοία!': 'voice/ajax/090.mp3',
  'Μπαμπά, ποιος ζούσε εδώ;': 'voice/clio/106.mp3',
  'Ένα ξύλινο ιστιοφόρο δεμένο στην προβλήτα. «ΕΛΠΙΔΑ» γράφει στην πλώρη.': 'voice/narrator/201.mp3',
  'Ωραίο πλοίο! Πάμε βόλτα;': 'voice/ajax/093.mp3',
  'Ίσως αργότερα. Δεν ξέρουμε πού να πάμε ακόμα.': 'voice/ntemis/121.mp3',
  'Η Ελπίδα περιμένει. Ο Χρυσόστομος στο τιμόνι.': 'voice/narrator/203.mp3',
  'Ο χάρτης δείχνει τον Άγιο Γεώργιο. Πάμε.': 'voice/ntemis/125.mp3',
  'Δεν ξέρουμε πού να πάμε ακόμα. Χρειαζόμαστε χάρτη.': 'voice/ntemis/119.mp3',
  'Η επιγραφή στον βράχο: «Πρόταση για ατμόπλοιο. Απορρίφθηκε, 9 προς 3.»': 'voice/narrator/204.mp3',
  'Μπαμπά, κοίτα εκεί πάνω! Κάτι γράφει στον βράχο.': 'voice/ajax/088.mp3',
  'Είναι ψηλά. Μπορείς να σκαρφαλώσεις, Αία;': 'voice/ntemis/120.mp3',
  'Εύκολο!': 'voice/ajax/083.mp3',
  'Ο Αίαντας σκαρφαλώνει στον βράχο και διαβάζει δυνατά:': 'voice/narrator/131.mp3',
  '«Πρόταση για ατμόπλοιο. Απορρίφθηκε, 9 προς 3.»': 'voice/ajax/080.mp3',
  'Σιωπή.': 'voice/narrator/132.mp3',
  'Ψηφοφορία. Κάποιος πρότεινε να αγοράσουν ατμόπλοιο. Εννιά καπεταναίοι είπαν όχι. Τρεις είπαν ναι.': 'voice/ntemis/129.mp3',
  'Ο Βισβίκης ήταν ένας από τους τρεις.': 'voice/ntemis/124.mp3',
  'Χαραγμένα σύμβολα στον βράχο. Ονόματα πλοίων, αρχικά, ημερομηνίες.': 'voice/narrator/133.mp3',
  'Μπαμπά, κοίτα — ο Βισβίκης ήταν εδώ. «Λ.Β. 1887.»': 'voice/ajax/087.mp3',
  'Τυρκουάζ νερό λάμπει από το φως του φαναριού. Κρυστάλλινο.': 'voice/narrator/134.mp3',
  'Η ρωγμή στον βράχο. Εκεί βρήκε η Κλειώ την πράσινη πέτρα.': 'voice/narrator/135.mp3',
  'Η ρωγμή είναι άδεια τώρα.': 'voice/narrator/136.mp3',
  'Ψάξτε παντού. Η πέτρα πρέπει να είναι εδώ κάπου.': 'voice/ntemis/128.mp3',
  'Κοίταξα σε κάθε σχισμή. Τίποτα.': 'voice/ajax/084.mp3',
  'Περιμένετε...': 'voice/clio/108.mp3',
  'Η Κλειώ κοιτάζει ΠΑΝΩ — η γωνία που μόνο μια επτάχρονη θα δοκίμαζε.': 'voice/narrator/137.mp3',
  'ΕΚΕΙ! Κάτι πράσινο!': 'voice/clio/102.mp3',
  'Ήδη βρήκατε την πράσινη πέτρα.': 'voice/narrator/138.mp3',
  'Η Κλειώ δείχνει ψηλά. Σφηνωμένη σε μια ρωγμή πάνω από το ύψος των ματιών: μια πέτρα. Σκούρα πράσινη, λεία, ζεστή στο χέρι.': 'voice/narrator/139.mp3',
  'Νεφρίτης. Jade. Από την Ανατολή.': 'voice/ntemis/123.mp3',
  'Ο Κάρκαρος. Το φανάρι φωτίζει τοίχους γεμάτους αρχαία σημάδια. Σταγόνες ηχούν στο σκοτάδι.': 'voice/narrator/140.mp3',
  'Κοιτάξτε τους τοίχους! Παντού σημάδια!': 'voice/ajax/085.mp3',
  'Ονόματα πλοίων, αρχικά, ημερομηνίες. Αιώνες ιστορίας χαραγμένοι στον βράχο.': 'voice/ntemis/126.mp3',
  'Η πόρτα του Αγίου Νικολάου. Ξύλινη, βαριά, ανοιχτή.': 'voice/narrator/141.mp3',
  'Χρυσές εικόνες αγίων λάμπουν στο φως των κεριών. Αφιερώματα καπεταναίων και οικογενειών τους.': 'voice/narrator/142.mp3',
  'Κοίτα αυτή — ένα πλοίο στο φόντο πίσω από τον άγιο.': 'voice/clio/104.mp3',
  'Κάθε εικόνα ήταν ευχαριστία για ασφαλή επιστροφή.': 'voice/ntemis/122.mp3',
  'Σκαλιστό ξύλινο τέμπλο. Φύλλα αμπέλου, ρόδια, δελφίνια — ο καλλιτέχνης ήξερε τη θάλασσα.': 'voice/narrator/143.mp3',
  'Αριστούργημα λαϊκής τέχνης. Δεν υπάρχει σαν αυτό.': 'voice/ntemis/115.mp3',
  'Μπορώ να σκαρφαλώσω;': 'voice/ajax/089.mp3',
  '...εντάξει.': 'voice/ajax/094.mp3',
  'Χαχαχα!': 'voice/clio/111.mp3',
  'Μανουάλι με κεριά. Μερικά καίνε ακόμα — κάποιος πέρασε πρόσφατα.': 'voice/narrator/144.mp3',
  'Το κερί της Κλειώς καίει ήσυχα.': 'voice/narrator/145.mp3',
  'Θέλω να ανάψω ένα κερί.': 'voice/clio/103.mp3',
  'Για ποιον, αγάπη μου;': 'voice/ntemis/116.mp3',
  'Για τους καπεταναίους και τα πλοία τους.': 'voice/clio/112.mp3',
  'Η φλόγα τρεμοπαίζει. Σκιές χορεύουν στους τοίχους.': 'voice/narrator/146.mp3',
  'Τίποτα ιδιαίτερο στο πάτωμα.': 'voice/narrator/147.mp3',
  'Μπαμπά! Κοίτα αυτή την πλάκα — έχει γράμματα!': 'voice/clio/107.mp3',
  '«Λ.Β.» — Λουκάς Βισβίκης!': 'voice/ntemis/114.mp3',
  'Ανοίξτε την! Ανοίξτε την!': 'voice/ajax/081.mp3',
  'Δεν βλέπω τίποτα εδώ κάτω.': 'voice/ntemis/118.mp3',
  'Η κρυψώνα κάτω από την πλάκα είναι άδεια τώρα.': 'voice/narrator/148.mp3',
  'Κάτω από την πλάκα — ένα δερμάτινο κύλινδρο. Μέσα, ένας χειρόγραφος χάρτης.': 'voice/narrator/149.mp3',
  'Χειρόγραφος χάρτης του Κορινθιακού. X σημαδεύει τον Άγιο Γεώργιο.': 'voice/ntemis/127.mp3',
  'Υπάρχει σημείωμα: «Κάτω από τον σταυρό, πέντε βήματα. Σκάψε.»': 'voice/clio/109.mp3',
  'ΘΗΣΑΥΡΟΣ!': 'voice/ajax/051.mp3',
  'Πέτρινες πλάκες στο πάτωμα. Μια φαίνεται... διαφορετική. Με χαραγμένα γράμματα.': 'voice/narrator/150.mp3',
  'Πέτρινες πλάκες στο πάτωμα. Με περισσότερο φως ίσως φανεί κάτι...': 'voice/narrator/151.mp3',
  'Ας ανάψουμε ένα κερί!': 'voice/clio/070.mp3',
  'Ο Παπά Νικόλας. Εξήντα χρονών, ζεστό πρόσωπο, πονηρό χαμόγελο.': 'voice/narrator/152.mp3',
  'Καλώς ήρθατε στον Άγιο Νικόλαο, παιδιά μου.': 'voice/papas/011.mp3',
  'Γεια σας, πάτερ. Ψάχνουμε για τον Βισβίκη.': 'voice/ntemis/067.mp3',
  'Α, τον Λουκά! Ο μεγαλύτερος ευεργέτης αυτής της εκκλησίας.': 'voice/papas/009.mp3',
  'Αυτός έφτιαξε το τέμπλο, αυτός πλήρωνε τα κεριά, αυτός...': 'voice/papas/010.mp3',
  'Αυτός τα έκανε ΟΛΑ;': 'voice/ajax/052.mp3',
  'Σχεδόν, παιδί μου. Σχεδόν. Κοιτάξτε γύρω σας — βλέπετε τα ίχνη του παντού.': 'voice/papas/012.mp3',
  'Ημίφως και μυρωδιά λιβανιού. Χρυσές εικόνες λάμπουν στη σιωπή.': 'voice/narrator/153.mp3',
  'Τι ωραία... σαν να μπαίνεις σε άλλο κόσμο.': 'voice/clio/071.mp3',
  'Γιατί είναι σκοτεινά;': 'voice/ajax/053.mp3',
  'Γιατί εδώ μέσα ακούς καλύτερα. Ακόμα κι τη σιωπή.': 'voice/ntemis/068.mp3',
  'Προσοχή εκεί κάτω. Το σπήλαιο έχει μυστικά.': 'voice/giannis/008.mp3',
  'Ο Γιάννης σου δίνει ένα ορειχάλκινο φανάρι. Παλιό, ναυτικό, καλοσυντηρημένο.': 'voice/narrator/154.mp3',
  'Ο αέρας σφυρίζει στα ερείπια του μύλου.': 'voice/narrator/155.mp3',
  'Ο Γιάννης μας έδειξε τον δρόμο. Ώρα να ψάξουμε.': 'voice/ntemis/069.mp3',
  'Ένα παλιό παρατηρητήριο στην άκρη του λόφου. Βλέπει ολόκληρο τον κόλπο.': 'voice/narrator/222.mp3',
  'Πέτρινος ανεμόμυλος — φτερά ακόμα όρθια, αψηφώντας τον χρόνο. Κάποτε άλεθε σιτάρι για ολόκληρο το Γαλαξείδι.': 'voice/narrator/223.mp3',
  'Ο Χρυσόστομος στο τιμόνι. Εβδομήντα χρονών, μάτια σαν τη θάλασσα.': 'voice/narrator/156.mp3',
  'Ο πατέρας σου μου είπε ότι κάποια μέρα θα ερχόσουν.': 'voice/chrysostomos/010.mp3',
  'Η θάλασσα δεν σε ρωτάει τι αγαπάς. Αλλάζει κι εσύ αλλάζεις μαζί της.': 'voice/chrysostomos/008.mp3',
  'Γνώριζες τον Βισβίκη;': 'voice/ntemis/070.mp3',
  'Ήταν ο τελευταίος ρομαντικός. Κανείς δεν τον πίστεψε. Πέθανε μόνος. Αλλά δεν πέθανε χωρίς σχέδιο.': 'voice/chrysostomos/009.mp3',
  'Μαρμάρινη πλάκα, πιο μεγαλοπρεπής από τις άλλες. Χαραγμένο: «Πλοίαρχος Λ. Βισβίκης».': 'voice/narrator/157.mp3',
  'Μαρμάρινοι σταυροί και πλάκες. Χαραγμένα πλοία στις πέτρες. Ονόματα καπεταναίων: Τσώνης, Ρήγας, Μαμάς.': 'voice/narrator/158.mp3',
  'Κυπαρίσσια ψηλά σαν κατάρτια. Φρουροί αιώνιοι στο φεγγαρόφωτο.': 'voice/narrator/159.mp3',
  'Μαρμάρινος άγγελος με σκυμμένο κεφάλι. Προσεύχεται πάνω από τον τάφο του Βισβίκη.': 'voice/narrator/160.mp3',
  'Σαν να τον φυλάει ακόμα.': 'voice/clio/072.mp3',
  'Κόκκινες παπαρούνες ανάμεσα στους τάφους, ζωντανές ακόμα και στο σκοτάδι.': 'voice/narrator/161.mp3',
  'Το φεγγάρι ρίχνει ασημένιο δρόμο στη θάλασσα. Τα φώτα του Γαλαξειδίου αντανακλούν στο νερό.': 'voice/narrator/162.mp3',
  'Τους έβαλαν εδώ επίτηδες. Να βλέπουν τη θάλασσα για πάντα.': 'voice/ajax/054.mp3',
  'Ολόγιομο φεγγάρι πάνω από τον Κορινθιακό. Φωτίζει τους τάφους σαν ασημένιος φανός.': 'voice/narrator/163.mp3',
  'Σαν να ξέρει ότι ήρθαμε.': 'voice/clio/073.mp3',
  'Αναμμένα κεριά μπροστά στον τάφο. Κάποιος τα φροντίζει ακόμα.': 'voice/narrator/164.mp3',
  '120 χρόνια και κάποιος ανάβει ακόμα κεριά. Αυτό είναι αφοσίωση.': 'voice/ntemis/071.mp3',
  'Μια αχνή, ψηλή σιλουέτα πάνω από τον τάφο. Τρεμοπαίζει σαν φως σε νερό.': 'voice/narrator/165.mp3',
  'Το παλιό νεκροταφείο. Το φεγγάρι φωτίζει τους τάφους, μυρωδιά θυμαριού, ησυχία.': 'voice/narrator/166.mp3',
  'Μπαμπά... δεν μου αρέσουν τα νεκροταφεία τη νύχτα.': 'voice/clio/074.mp3',
  // Graveyard — green stone entry + USE grave + ghost sequence (generated)
  'Η εσοχή... αυτό ζητάει η πλάκα.': 'voice/ntemis/145.mp3',
  'Η πράσινη πέτρα ταιριάζει ακριβώς. Λάμπει αχνά...': 'voice/narrator/241.mp3',
  'Μπαμπά, νιώθω κάτι περίεργο με αυτή την πέτρα.': 'voice/clio/122.mp3',
  'Μη λες βλακείες.': 'voice/ajax/128.mp3',
  '...Βρείτε τον τάφο του Βισβίκη.': 'voice/ntemis/146.mp3',
  'Δεν φοβήθηκα. Ήταν... λυπημένος.': 'voice/clio/123.mp3',
  'Το κιβώτιο ανοιχτό. Ο θησαυρός του Βισβίκη αποκαλύφθηκε.': 'voice/narrator/167.mp3',
  'Σιδερόδετο ξύλινο κιβώτιο. Εκατόν είκοσι χρόνια κάτω από τη γη. Ο Βισβίκης έχτιζε πράγματα που αντέχουν.': 'voice/narrator/168.mp3',
  'Ανοίξτε το! ΑΝΟΙΞΤΕ ΤΟ!': 'voice/ajax/055.mp3',
  'Ήδη ανοιχτό.': 'voice/narrator/169.mp3',
  'Το σιδερένιο κλείδωμα υποχωρεί. Το καπάκι ανοίγει αργά...': 'voice/narrator/170.mp3',
  'Χρυσάφι!': 'voice/clio/075.mp3',
  'Νομίσματα — Οθωμανικά, Βενετικά, αρχαία Ελληνικά. Ένας θησαυρός αιώνων.': 'voice/narrator/171.mp3',
  'Ένα κολιέ από νεφρίτη. Ταιριάζει τέλεια με την πράσινη πέτρα.': 'voice/narrator/172.mp3',
  'Κοίτα! Ένα βιβλίο!': 'voice/ajax/056.mp3',
  'Το πρωτότυπο βιβλίο της αλληλασφάλειας. 104 υπογραφές καπεταναίων, 1860.': 'voice/narrator/173.mp3',
  'Εκατόν τέσσερις. Σαν ομάδα.': 'voice/ajax/057.mp3',
  'Και στον πάτο... ένα γράμμα. Σφραγισμένο με κερί.': 'voice/narrator/174.mp3',
  'Νομίσματα, ένα κολιέ νεφρίτη, ένα παλιό βιβλίο, και ένα γράμμα.': 'voice/narrator/175.mp3',
  'Δεν βλέπεις τίποτα ακόμα. Πρέπει να ανοίξεις το κιβώτιο.': 'voice/narrator/176.mp3',
  'Τα λόγια του Βισβίκη ηχούν ακόμα. «Κράτα την αλληλεγγύη. Άλλαξε το πλοίο.»': 'voice/narrator/177.mp3',
  '«Αυτός ο θησαυρός δεν είναι δικός μου. Είναι του Γαλαξειδίου.»': 'voice/ntemis/072.mp3',
  '«Ταξίδεψα στην Ανατολή και γύρισα πλούσιος. Αλλά ο αληθινός πλούτος δεν είναι ο χρυσός.»': 'voice/ntemis/073.mp3',
  '«Είναι αυτό που χτίσαμε μαζί — η αλληλεγγύη. Κανείς δεν ταξιδεύει μόνος.»': 'voice/ntemis/074.mp3',
  '«Κράτα την αλληλεγγύη. Άλλαξε το πλοίο.»': 'voice/ntemis/075.mp3',
  '«— Καπ. Λ. Βισβίκης»': 'voice/ntemis/076.mp3',
  'Σιωπή. Κύματα και γλάροι.': 'voice/narrator/178.mp3',
  'Εκατόν τέσσερις υπογραφές. Κανείς δεν ταξιδεύει μόνος.': 'voice/ajax/058.mp3',
  'Δεν βλέπεις τίποτα ακόμα.': 'voice/narrator/179.mp3',
  'Κοίταξέ το πρώτα.': 'voice/narrator/180.mp3',
  'Ο βράχος, ο σταυρός, τα πέντε βήματα. Ο Βισβίκης ήταν ακριβής μέχρι το τέλος.': 'voice/narrator/181.mp3',
  'Μύριζε θυμάρι. Σαν να μας περίμενε.': 'voice/clio/078.mp3',
  'Το Γαλαξίδι λάμπει στον πρωινό ήλιο. Σπίτια, εκκλησίες, το λιμάνι. Σπίτι.': 'voice/narrator/182.mp3',
  'Γυρνάμε πίσω πλουσιότεροι. Αλλά όχι όπως νόμιζα.': 'voice/ajax/059.mp3',
  'Η τρύπα στη γη. Πέντε βήματα νοτιοδυτικά από τον σταυρό, ακριβώς όπως έγραψε ο Βισβίκης.': 'voice/narrator/183.mp3',
  'Το φτυάρι χτυπάει ξύλο. Ένα κιβώτιο αναδύεται από τη γη.': 'voice/narrator/184.mp3',
  'ΒΡΗΚΑΜΕ! Μπαμπά, βρήκαμε!': 'voice/ajax/060.mp3',
  'Η θάλασσα θυμάται...': 'voice/clio/079.mp3',
  'Ας δούμε τι μας άφησε ο Βισβίκης.': 'voice/ntemis/079.mp3',
  'Ολόκληρο το Γαλαξίδι μαζεμένο στο λιμάνι. Ψαράδες, ταβερνιάρηδες, γριές με μαύρα, παιδιά.': 'voice/narrator/185.mp3',
  'Μπαμπά, είναι ΟΛΟΙ εδώ!': 'voice/clio/080.mp3',
  'Ένα απλό ξύλινο βήμα μπροστά στη θάλασσα. Πάνω του το κιβώτιο και το βιβλίο.': 'voice/narrator/186.mp3',
  'Η ομιλία τελείωσε. Τώρα είναι η σειρά τους.': 'voice/narrator/187.mp3',
  'Ο Βισβίκης δεν μας άφησε θησαυρό. Μας άφησε ερώτηση.': 'voice/ntemis/080.mp3',
  'Τι κάνεις όταν ο κόσμος αλλάζει κι εσύ αγαπάς αυτό που ήταν;': 'voice/ntemis/081.mp3',
  'Οι καπεταναίοι αρνήθηκαν τον ατμό. Δεν θα κάνουμε το ίδιο λάθος.': 'voice/ntemis/082.mp3',
  'Το Γαλαξίδι δεν χρειάζεται να γίνει σαν την Αθήνα. Χρειάζεται να γίνει περισσότερο Γαλαξίδι.': 'voice/ntemis/083.mp3',
  'Σιωπή. Μετά, η γριά με τα μαύρα σηκώνεται πρώτη. Πλησιάζει το βιβλίο και υπογράφει.': 'voice/narrator/188.mp3',
  'Ένας-ένας, οι Γαλαξειδιώτες ακολουθούν. Ψαράδες, ταβερνιάρηδες, νέοι, γέροι.': 'voice/narrator/189.mp3',
  'Ο Αίας αρπάζει το στυλό και υπογράφει.': 'voice/narrator/190.mp3',
  'Ο ίδιος αριθμός με το αρχικό σύμφωνο.': 'voice/narrator/191.mp3',
  'ΕΛΠΙΔΑ.': 'voice/clio/081.mp3',
  'Πρέπει να μιλήσω πρώτα.': 'voice/ntemis/085.mp3',
  'Δερματόδετο βιβλίο πάνω στο βήμα. Η σελίδα είναι ανοιχτή, περιμένει υπογραφές.': 'voice/narrator/192.mp3',
  '104 υπογραφές. Ο ίδιος αριθμός με το 1860. Η τελευταία — του Αίαντα.': 'voice/narrator/193.mp3',
  'Σαν να μην πέρασε μια μέρα.': 'voice/clio/082.mp3',
  'Πρώτα η ομιλία. Μετά οι υπογραφές.': 'voice/narrator/194.mp3',
  'Σελίδες γεμάτες ονόματα. Ψαράδες, δάσκαλοι, ταβερνιάρηδες. Γαλαξειδιώτες.': 'voice/narrator/195.mp3',
  'Ξέρεις τι σημαίνει αλληλασφάλεια; Ότι κανείς δεν βυθίζεται μόνος.': 'voice/ntemis/086.mp3',
  'Ο Άκης με την κάμερά του. Καταγράφει τα πάντα.': 'voice/narrator/196.mp3',
  'Τριάντα χρόνια κινηματογραφώ τόπους που σβήνουν. Αυτή τη φορά δεν γράφω ελεγείο. Γράφω αρχή.': 'voice/akis/009.mp3',
  'Ο ήλιος βυθίζεται στον Κορινθιακό. Χρυσό φως λούζει τα πρόσωπα. Η θάλασσα θυμάται.': 'voice/narrator/197.mp3',
  'Εβδομάδες αργότερα. Το λιμάνι του Γαλαξειδίου στο ηλιοβασίλεμα. Ολόκληρη η πόλη είναι εδώ.': 'voice/narrator/198.mp3',
  'Τι θα πεις;': 'voice/ajax/063.mp3',
  'Την αλήθεια.': 'voice/ntemis/087.mp3',
  'Ο... ο Καπετάν Βισβίκης;': 'voice/clio/083.mp3',
  'Είναι σκοτεινά εκεί μέσα. Χρειαζόμαστε φανάρι.': 'voice/ntemis/088.mp3',
  'Ο Γιάννης στον μύλο ίσως έχει κάτι.': 'voice/clio/084.mp3',
  'Χρειαζόμαστε τον χάρτη του Βισβίκη για να βρούμε το νησί.': 'voice/ntemis/089.mp3',
  'Πρέπει να δούμε τι μας άφησε ο Βισβίκης πρώτα.': 'voice/ntemis/090.mp3',
  'Πόσο ακόμα, μπαμπά;': 'voice/ajax/064.mp3',
  'Λίγο ακόμα. Σχεδόν φτάσαμε.': 'voice/ntemis/091.mp3',
  'Βλέπω τη θάλασσα! Κοίτα, καράβια!': 'voice/clio/085.mp3',
  'Θα κολυμπήσουμε;': 'voice/ajax/065.mp3',
  'Πρώτα θα βρούμε το σπίτι του παππού.': 'voice/ntemis/092.mp3',
  'Φτάσαμε. Γαλαξίδι.': 'voice/ntemis/093.mp3',
  'Μυρίζει αλάτι και πεύκο!': 'voice/clio/086.mp3',
  '«Σε όποιον βρει αυτό το γράμμα...»': 'voice/ntemis/094.mp3',
  '«...εγώ, Καπετάν Λουκάς Βισβίκης, αφήνω πίσω μου τον θησαυρό μιας ζωής στη θάλασσα.»': 'voice/ntemis/095.mp3',
  '«Βρες το πράσινο πέτρωμα, εκεί που η γη μιλάει — εκεί που τα βράχια γίνονται σπήλαιο.»': 'voice/ntemis/096.mp3',
  '«Φέρε τη σε μένα»... Είναι νεκρός εδώ και εκατό χρόνια.': 'voice/ajax/066.mp3',
  'Κάποιος στην πόλη θα ξέρει για τον Βισβίκη. Πάμε στο λιμάνι.': 'voice/ntemis/098.mp3',
    'Άκη! Στάθη! Δεν αλλάξατε καθόλου!': 'voice/ntemis/099.mp3',
    'Τι παίζουν; Είναι τέλειο!': 'voice/ajax/067.mp3',
  'Σσσ... Ζωγραφίζω τους.': 'voice/clio/089.mp3',
  'Η μελωδία των ναυτικών. Χρόνια δεν την άκουσα.': 'voice/ntemis/100.mp3',
      'Τριακόσια; Σαν ολόκληρο στόλο!': 'voice/ajax/068.mp3',
    'Ήταν οι καλύτεροι, κι αυτό τους έκανε χειρότερους;': 'voice/ajax/069.mp3',
  'Εκατόν τέσσερις υπέγραψαν. Αλληλασφάλεια.': 'voice/clio/090.mp3',
      'Θα βρούμε την απάντηση, Άθο. Υπόσχομαι.': 'voice/ntemis/101.mp3',
      'Ο Κάρκαρος...': 'voice/ntemis/102.mp3',
  'Βλέπω ένα νησάκι! Με ένα εκκλησάκι!': 'voice/ajax/070.mp3',
  'Αυτός ήθελε να μείνει κάτι.': 'voice/clio/092.mp3',
  'Πάρτε αυτό. Θα το χρειαστείτε εκεί κάτω.': 'voice/giannis/007.mp3',
  'Σκοτεινά... Μπαμπά, κράτα ψηλά το φανάρι!': 'voice/ajax/071.mp3',
  'Κοίτα στον τοίχο! Ονόματα πλοίων!': 'voice/clio/093.mp3',
  'Οι καπεταναίοι σημάδευαν το πέρασμά τους εδώ.': 'voice/ntemis/103.mp3',
  'Μπαμπά... κάποιος είναι εκεί. Στο φως.': 'voice/clio/094.mp3',
  'Καπετάν Βισβίκη... Εκατόν είκοσι χρόνια περίμενες.': 'voice/ntemis/104.mp3',
  'Μας κοιτάει. Δεν φοβάμαι. Μοιάζει... χαρούμενος.': 'voice/ajax/072.mp3',
  'Γεια σου, καπετάνιε! Γεια σου!': 'voice/clio/095.mp3',
  'Δείχνει προς την εκκλησία... Τον Άγιο Νικόλαο.': 'voice/ntemis/105.mp3',
  'Θέλω να ανάψω ένα κερί. Για τους καπεταναίους.': 'voice/clio/096.mp3',
    'Άναψέ το, κόρη μου.': 'voice/ntemis/106.mp3',
  'Μπαμπά! Κοίτα! Γράμματα στο πάτωμα! «Λ.Β.»!': 'voice/clio/097.mp3',
  'Λάμβδα Βήτα... Λουκάς Βισβίκης!': 'voice/ajax/074.mp3',
  'Ένας χάρτης... Δείχνει τον Άγιο Γεώργιο. Με ένα Χ.': 'voice/ntemis/107.mp3',
  'Δεν πίστευα ότι θα ζούσα να το δω. Η Ελπίδα ξαναταξιδεύει.': 'voice/chrysostomos/005.mp3',
  'Αυτό είναι το πλοίο του Βισβίκη; Είναι πανέμορφο!': 'voice/ajax/075.mp3',
  'Ήξερα τον πατέρα σου, Ντέμη. Θα ήταν περήφανος.': 'voice/chrysostomos/006.mp3',
  'Βλέπω το νησάκι! Με το εκκλησάκι!': 'voice/ajax/076.mp3',
  'Η θάλασσα αλλάζει κι εσύ αλλάζεις μαζί της. Αλλιώς πνίγεσαι.': 'voice/chrysostomos/007.mp3',
  'Σχεδόν φτάσαμε. Κάτω από τον σταυρό, πέντε βήματα.': 'voice/ntemis/108.mp3',
  'Χρυσάφι! Και ένα βιβλίο... Κοίτα, μπαμπά!': 'voice/ajax/077.mp3',
  'Ένα κολιέ! Πράσινο σαν το πέτρωμα... Μπορώ να το φορέσω;': 'voice/clio/098.mp3',
  'Η αλληλασφάλεια... 104 υπογραφές. Και ένα γράμμα.': 'voice/ntemis/109.mp3',
  'Τι εννοεί "άλλαξε το πλοίο";': 'voice/ajax/078.mp3',
  'Ότι δεν αρκεί να είσαι ο καλύτερος. Πρέπει να αλλάζεις.': 'voice/ntemis/110.mp3',
  'Ο Καπετάνιος... ήξερε.': 'voice/clio/099.mp3',
  'Ο Βισβίκης δεν μας άφησε χρυσάφι. Μας άφησε μια ιδέα.': 'voice/ntemis/111.mp3',
  'Την αλληλεγγύη. Κράτα τον διπλανό σου. Άλλαξε το πλοίο.': 'voice/ntemis/112.mp3',
    'Εκατόν τρεις... Μένει μία ακόμα υπογραφή.': 'voice/ajax/079.mp3',
  'Εγώ! Θέλω να υπογράψω εγώ!': 'voice/clio/100.mp3',
  'Η θάλασσα θυμάται. Κι εμείς τώρα, επίσης.': 'voice/ntemis/113.mp3',
  // ── SCENE 10: TREASURE ──
  'Ο Άγιος Γεώργιος. Ένα ξεχασμένο νησάκι στον κόλπο. Θυμάρι, πέτρα, κι ο ήχος του ανέμου.': 'voice/narrator/224.mp3',
  'Πού σκάβουμε;': 'voice/ajax/116.mp3',
  'Σιγά. Πρώτα βρίσκουμε τον σταυρό.': 'voice/ntemis/132.mp3',
  'Εκεί! Βλέπω σταυρό στα βράχια!': 'voice/clio/115.mp3',
  'Ένας χαμηλός πέτρινος σταυρός. Φαγωμένος από τον χρόνο και την αλμύρα.': 'voice/narrator/225.mp3',
  'Κοίτα — γράμματα!': 'voice/clio/116.mp3',
  'Λ... Β... 1860!': 'voice/ajax/117.mp3',
  'Λ.Β. — Λουκάς Βισβίκης. Ο χάρτης λέει: πέντε βήματα νοτιοδυτικά. Σκάψε.': 'voice/ntemis/133.mp3',
  'Πέντε βήματα! Ένα... δύο... τρία... τέσσερα... πέντε! ΕΔΏΣΚΑΒΟΥΜΕ!': 'voice/ajax/118.mp3',
  'Ο σταυρός του Βισβίκη. «Λ.Β. 1860». Πέντε βήματα νοτιοδυτικά.': 'voice/narrator/226.mp3',
  'Το Γαλαξίδι λάμπει στον πρωινό ήλιο απέναντι. Σπίτια, εκκλησίες, το λιμάνι.': 'voice/narrator/227.mp3',
  'Από εδώ τα έβλεπε όλα ο Βισβίκης.': 'voice/ntemis/134.mp3',
  'Λευκό εκκλησάκι με μπλε τρούλο. Ο Άγιος Γεώργιος φυλάει αυτόν τον βράχο εδώ και αιώνες.': 'voice/narrator/228.mp3',
  'Τι ωραίο... Σαν ζαχαρωτό!': 'voice/clio/117.mp3',
  'Χώμα και πέτρες. Κοίταξε πρώτα τον σταυρό.': 'voice/narrator/229.mp3',
  'Η τρύπα στη γη. Εδώ βρήκαμε τον θησαυρό.': 'voice/narrator/230.mp3',
  'Σκούρο χώμα, πατημένο. Πέντε βήματα νοτιοδυτικά από τον σταυρό.': 'voice/narrator/231.mp3',
  'ΣΚΑΒΟΥΜΕ!': 'voice/ajax/119.mp3',
  'Πρέπει να βρούμε το σωστό σημείο πρώτα. Κοίταξε τον σταυρό.': 'voice/ntemis/135.mp3',
  'Ο θησαυρός ήδη βγήκε στο φως.': 'voice/narrator/232.mp3',
  'Πώς θα σκάψουμε; Χρειαζόμαστε φτυάρι!': 'voice/ajax/120.mp3',
  'Ποιος θα είχε φτυάρι εδώ γύρω...': 'voice/ntemis/136.mp3',
  'Πατέρας κι γιος σκάβουν μαζί. Σκληρό χώμα, ρίζες θυμαριού, πέτρες.': 'voice/narrator/233.mp3',
  'Κι αν δεν υπάρχει τίποτα;': 'voice/clio/118.mp3',
  'Τότε ήρθαμε για τη θέα.': 'voice/ntemis/137.mp3',
  'ΚΛΑΝΓΚ! Το φτυάρι χτυπάει κάτι σκληρό.': 'voice/narrator/234.mp3',
  'ΧΤΥΠΗΣΕ! ΚΑΤΙ ΧΤΥΠΗΣΕ!': 'voice/ajax/121.mp3',
  'Βλέπω σίδερο... μαντάλια! Είναι κιβώτιο!': 'voice/clio/119.mp3',
  'ΒΡΗΚΑΜΕ! Μπαμπά, βρήκαμε!': 'voice/ajax/122.mp3',
  'Ένα σιδερόδετο ξύλινο κιβώτιο αναδύεται από τη γη. Εκατόν είκοσι χρόνια κάτω από τη γη.': 'voice/narrator/235.mp3',
  'Εκατόν είκοσι χρόνια περίμενε. Μπορεί να περιμένει κι ένα λεπτό ακόμα.': 'voice/ntemis/138.mp3',
  'Η θάλασσα θυμάται.': 'voice/clio/120.mp3',
  'Ας δούμε τι μας άφησε ο Βισβίκης.': 'voice/ntemis/139.mp3',
  'Το καπάκι ανοίγει αργά... Χρυσό φως ξεχύνεται.': 'voice/narrator/236.mp3',
  'Νομίσματα — Οθωμανικά, Βενετικά, αρχαία. Ένα κολιέ νεφρίτη. Ένα βιβλίο.': 'voice/narrator/237.mp3',
  'Εκατόν τέσσερις υπογραφές. Σαν ομάδα.': 'voice/ajax/123.mp3',
  'Και στον πάτο... ένα γράμμα. Σφραγισμένο με κερί.': 'voice/narrator/238.mp3',
  '«Αυτός ο θησαυρός δεν είναι δικός μου. Είναι του Γαλαξειδίου.»': 'voice/ntemis/140.mp3',
  '«Κράτα την αλληλεγγύη. Άλλαξε το πλοίο. — Καπ. Λ. Βισβίκης»': 'voice/ntemis/141.mp3',
  'Σιωπή. Κύματα και γλάροι.': 'voice/narrator/239.mp3',
  'Μπαμπά... τόσο χρυσάφι. ΕΜΕΙΣ το βρήκαμε.': 'voice/ajax/124.mp3',
  'Αίαντα. Τι έλεγε η αλληλασφάλεια;': 'voice/ntemis/142.mp3',
  '...Ότι κανείς δεν ταξιδεύει μόνος. Οκ. Το δίνουμε.': 'voice/ajax/125.mp3',
  'Όλο. Αλλά εσύ κράτα το κολιέ, Κλειώ.': 'voice/ntemis/143.mp3',
  'Η θάλασσα μου το χάρισε.': 'voice/clio/121.mp3',
  'Κι εγώ; Τι κρατάω;': 'voice/ajax/126.mp3',
  'Τη μνήμη. Κι αυτό αξίζει περισσότερο.': 'voice/ntemis/144.mp3',
  '...Ε ντάξει. Αλλά θα το πω σε ΟΛΟΥΣ στο σχολείο.': 'voice/ajax/127.mp3',
  'Ώρα να γυρίσουν στο Γαλαξίδι.': 'voice/narrator/240.mp3'
};

let voiceFinished = true;

function playVoice(text) {
  voiceAudio.pause();
  voiceAudio.onended = null;
  voiceFinished = true;
  const src = VOICE_MAP[text];
  if (src) {
    voiceFinished = false;
    voiceAudio.src = src;
    voiceAudio.onended = () => { voiceFinished = true; };
    voiceAudio.play().catch(() => { voiceFinished = true; });
  } else {
    voiceAudio.removeAttribute('src');
    voiceAudio.load();
  }
}

function stopVoice() {
  voiceAudio.pause();
  voiceAudio.removeAttribute('src');
  voiceAudio.load(); // fully reset audio element
  voiceFinished = true;
  if ('speechSynthesis' in window) speechSynthesis.cancel();
}

// ════════════════════════════════════════════════════════════
// DIALOGUE SYSTEM
// ════════════════════════════════════════════════════════════
function showDlg(lines, cb) {
  const filtered = lines.filter(l => l.t);
  if (!filtered.length) { if (cb) cb(); return; }
  stopVoice(); // kill any lingering voice from previous dialog
  state.dlg.queue = [...filtered];
  state.dlg.active = true;
  state.dlg.cb = cb || null;
  nextDlgLine();
}

function nextDlgLine() {
  if (!state.dlg.queue.length) { closeDlg(); return; }
  const l = state.dlg.queue.shift();
  state.dlg.speaker = l.s || '';
  state.dlg.text = l.t;
  state.dlg.displayed = '';
  state.dlg.charIdx = 0;
  state.dlg.timer = 0;
  state.dlg.autoDelay = l.auto || 0; // auto-advance delay in seconds (0 = manual)
  if (l.sfx) playSFX(l.sfx);
  playVoice(l.t);
}

function updateDlg(dt) {
  if (!state.dlg.active) return;
  if (state.dlg.charIdx < state.dlg.text.length) {
    state.dlg.timer += dt;
    while (state.dlg.timer >= 0.03 && state.dlg.charIdx < state.dlg.text.length) {
      state.dlg.timer -= 0.03;
      state.dlg.charIdx++;
      state.dlg.displayed = state.dlg.text.substring(0, state.dlg.charIdx);
      if (state.dlg.charIdx % 2 === 0) playSFX('tick');
    }
  } else if (state.dlg.autoDelay > 0) {
    // Auto-advance: count down after text is fully displayed
    state.dlg.autoDelay -= dt;
    if (state.dlg.autoDelay <= 0) {
      state.dlg.autoDelay = 0;
      nextDlgLine();
    }
  }
}

function advanceDlg() {
  if (!state.dlg.active) return;
  if (state.dlg.charIdx < state.dlg.text.length) {
    // Skip typewriter — show full text immediately
    state.dlg.charIdx = state.dlg.text.length;
    state.dlg.displayed = state.dlg.text;
  } else if (voiceFinished) {
    // Only advance to next line when voice is done
    nextDlgLine();
  } else {
    // Voice still playing — stop it and advance
    stopVoice();
    nextDlgLine();
  }
}

function closeDlg() {
  state.dlg.active = false;
  state.dlg.queue = [];
  stopVoice();
  if (state.dlg.cb) { const cb = state.dlg.cb; state.dlg.cb = null; cb(); }
  checkEnd();
}

// ════════════════════════════════════════════════════════════
// SCRIPTED SEQUENCE ENGINE
// ════════════════════════════════════════════════════════════
function startSequence(steps) {
  if (clioTimer) { clearTimeout(clioTimer); clioTimer = null; }
  state.seq.active = true;
  state.seq.steps = steps;
  state.seq.stepIdx = 0;
  state.seq.stepTimer = 0;
  executeStep();
}

function executeStep() {
  const seq = state.seq;
  if (seq.stepIdx >= seq.steps.length) { endSequence(); return; }
  const step = seq.steps[seq.stepIdx];
  seq.stepTimer = 0;

  switch (step.type) {
    case 'wait':
      break;
    case 'dialog':
      showDlg(step.lines, () => advanceSeqStep());
      break;
    case 'env':
      step._start = { darken: seq.env.darken, vignette: seq.env.vignette, spectral: seq.env.spectral };
      break;
    case 'move': {
      const target = npcChars[step.who] || chars[step.who];
      if (target) {
        step._startX = target.x;
        step._targetX = target.x + step.dx;
      }
      break;
    }
    case 'npc': {
      const npc = npcChars[step.who];
      if (npc) {
        if (step.dir !== undefined) npc.dir = step.dir;
        if (step.tilt !== undefined) npc.tilt = step.tilt;
        if (step.wave !== undefined) npc.wave = step.wave;
        if (step.visible !== undefined) npc.visible = step.visible;
      }
      advanceSeqStep();
      break;
    }
    case 'effect':
      if (step.effect === 'materialize') {
        seq.ghostMat.active = true;
        seq.ghostMat.progress = 0;
        seq.ghostMat.alpha = 0;
        seq.ghostMat.glowBlur = 30;
        initSwirlParticles();
      } else if (step.effect === 'fade_out') {
        seq.ghostMat.active = true;
        step._startAlpha = seq.ghostMat.alpha;
      } else if (step.effect === 'stone_glow') {
        seq.stoneGlow.active = true;
        seq.stoneGlow.progress = 0;
      } else if (step.effect === 'arm_raise') {
        // Arm raise is timer-based, handled in updateGhostEffect
      } else if (step.effect === 'jade_reveal') {
        seq.jadeReveal.active = true;
        seq.jadeReveal.progress = 0;
      }
      break;
    case 'callback':
      if (step.fn) step.fn();
      advanceSeqStep();
      break;
  }
}

function advanceSeqStep() {
  state.seq.stepIdx++;
  if (state.seq.stepIdx < state.seq.steps.length) {
    executeStep();
  } else {
    endSequence();
  }
}

function endSequence() {
  state.seq.active = false;
  state.seq.steps = [];
  state.seq.stepIdx = 0;
  state.seq.ghostMat.active = false;
  state.seq.stoneGlow.active = false;
  state.seq.jadeReveal.active = false;
}

function updateSequence(dt) {
  if (!state.seq.active) return;
  const seq = state.seq;
  if (seq.stepIdx >= seq.steps.length) return;
  const step = seq.steps[seq.stepIdx];
  seq.stepTimer += dt;

  switch (step.type) {
    case 'wait':
      if (seq.stepTimer >= step.duration) advanceSeqStep();
      break;
    case 'env': {
      const t = Math.min(1, seq.stepTimer / step.duration);
      const e = easeInOutCubic(t);
      seq.env.darken = step._start.darken + (step.darken - step._start.darken) * e;
      seq.env.vignette = step._start.vignette + (step.vignette - step._start.vignette) * e;
      seq.env.spectral = step._start.spectral + (step.spectral - step._start.spectral) * e;
      if (t >= 1) advanceSeqStep();
      break;
    }
    case 'move': {
      const target = npcChars[step.who] || chars[step.who];
      if (target && step._startX !== undefined) {
        const t = Math.min(1, seq.stepTimer / step.duration);
        target.x = step._startX + (step._targetX - step._startX) * easeInOutCubic(t);
        if (step.dx > 0) target.dir = 1;
        else if (step.dx < 0) target.dir = -1;
        if (t >= 1) advanceSeqStep();
      } else {
        advanceSeqStep();
      }
      break;
    }
    case 'effect':
      updateGhostEffect(dt, step);
      break;
  }

  // Keep swirl particles animating between steps
  if (seq.ghostMat.active && step.type !== 'effect') {
    updateSwirlParticles(dt);
  }
}

// ════════════════════════════════════════════════════════════
// GHOST MATERIALIZATION EFFECTS
// ════════════════════════════════════════════════════════════
function initSwirlParticles() {
  const sp = state.seq.swirlParticles;
  sp.length = 0;
  const ghost = npcChars.ghost;
  for (let i = 0; i < 40; i++) {
    const angle = Math.random() * Math.PI * 2;
    const dist = 80 + Math.random() * 120;
    sp.push({
      angle, dist, startDist: dist,
      x: ghost.x + Math.cos(angle) * dist,
      y: ghost.y - 50 + Math.sin(angle) * dist * 0.5,
      size: 1 + Math.random() * 2.5,
      alpha: 0, maxAlpha: 0.4 + Math.random() * 0.4,
      speed: 0.5 + Math.random() * 1.5,
      phase: Math.random() * Math.PI * 2,
    });
  }
}

function updateSwirlParticles(dt) {
  const sp = state.seq.swirlParticles;
  const ghost = npcChars.ghost;
  for (const p of sp) {
    p.angle += dt * p.speed;
    p.x = ghost.x + Math.cos(p.angle) * p.dist;
    p.y = (ghost.y - 50) + Math.sin(p.angle) * p.dist * 0.5;
  }
}

function updateGhostEffect(dt, step) {
  const seq = state.seq;
  const t = Math.min(1, seq.stepTimer / step.duration);

  if (step.effect === 'materialize') {
    seq.ghostMat.progress = t;
    if (t < 0.6) {
      const ct = t / 0.6;
      for (const p of seq.swirlParticles) {
        p.dist = p.startDist * (1 - easeInOutCubic(ct) * 0.85);
        p.alpha = p.maxAlpha * Math.min(1, ct * 2);
      }
    }
    if (t >= 0.4) {
      const ft = (t - 0.4) / 0.6;
      seq.ghostMat.alpha = easeInOutCubic(ft) * 0.55;
      seq.ghostMat.glowBlur = 30 - easeInOutCubic(ft) * 18;
    }
    if (t >= 0.5) {
      const ft = (t - 0.5) / 0.5;
      for (const p of seq.swirlParticles) {
        p.alpha = p.maxAlpha * (1 - ft);
      }
    }
    updateSwirlParticles(dt);
    if (t >= 1) advanceSeqStep();
  } else if (step.effect === 'fade_out') {
    const startA = step._startAlpha || 0.55;
    seq.ghostMat.alpha = startA * (1 - easeInOutCubic(t));
    seq.ghostMat.glowBlur = 12 + easeInOutCubic(t) * 18;
    for (const p of seq.swirlParticles) {
      const fadeT = t < 0.3 ? t / 0.3 : 1 - (t - 0.3) / 0.7;
      p.alpha = p.maxAlpha * 0.5 * Math.max(0, fadeT);
    }
    updateSwirlParticles(dt);
    if (t >= 1) {
      seq.ghostMat.active = false;
      seq.ghostMat.alpha = 0;
      advanceSeqStep();
    }
  } else if (step.effect === 'stone_glow') {
    seq.stoneGlow.progress = t;
    if (t >= 1) {
      seq.stoneGlow.active = false;
      advanceSeqStep();
    }
  } else if (step.effect === 'arm_raise') {
    // Lerp ghost arm from 0 (down) to 1 (raised and pointing)
    npcChars.ghost.arm = easeInOutCubic(t);
    if (t >= 1) advanceSeqStep();
  } else if (step.effect === 'jade_reveal') {
    seq.jadeReveal.progress = t;
    if (t >= 1) {
      seq.jadeReveal.active = false;
      advanceSeqStep();
    }
  }
}

function drawSwirlParticles() {
  const sp = state.seq.swirlParticles;
  for (const p of sp) {
    if (p.alpha <= 0) continue;
    ctx.save();
    ctx.globalAlpha = p.alpha;
    ctx.shadowColor = 'rgba(100,180,255,0.6)';
    ctx.shadowBlur = 4;
    const r = 150 + Math.sin(p.phase) * 50;
    ctx.fillStyle = `rgb(${r},${180 + Math.sin(p.phase + 1) * 40},255)`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

function drawStoneGlow() {
  if (!state.seq.stoneGlow.active) return;
  const t = state.seq.stoneGlow.progress;
  const pulse = Math.sin(t * Math.PI * 3) * 0.3 + 0.7;
  const alpha = Math.sin(t * Math.PI) * 0.5 * pulse;
  if (alpha <= 0) return;
  ctx.save();
  ctx.globalAlpha = alpha;
  const grad = ctx.createRadialGradient(460, 270, 0, 460, 270, 60);
  grad.addColorStop(0, 'rgba(80,220,100,0.6)');
  grad.addColorStop(0.5, 'rgba(50,180,80,0.3)');
  grad.addColorStop(1, 'rgba(30,100,50,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(400, 210, 120, 120);
  ctx.restore();
}

function drawJadeReveal() {
  if (!state.seq.jadeReveal || !state.seq.jadeReveal.active) return;
  const t = state.seq.jadeReveal.progress;
  const tick = state.tick;

  // Stone floats from crack (210,48) to screen center (320,150)
  const startX = 210, startY = 48;
  const endX = GW / 2, endY = GH * 0.38;

  // Float trajectory: stone lifts out at t=0.1, arrives center at t=0.7
  const floatStart = 0.1, floatEnd = 0.7;
  const floatT = Math.max(0, Math.min(1, (t - floatStart) / (floatEnd - floatStart)));
  const eased = easeInOutCubic(floatT);
  const stoneX = startX + (endX - startX) * eased;
  const stoneY = startY + (endY - startY) * eased;
  // Gentle bobbing once it starts moving
  const bob = floatT > 0 ? Math.sin(tick * 0.06) * 3 * floatT : 0;
  const stoneDrawX = stoneX;
  const stoneDrawY = stoneY + bob;

  // Phase 1 (0–0.4): Green glow builds — follows the stone
  if (t > 0) {
    const buildT = Math.min(1, t / 0.4);
    const pulse = Math.sin(t * Math.PI * 8) * 0.08;
    ctx.save();
    const radius = 20 + buildT * 200;
    ctx.globalAlpha = (0.2 + pulse) * buildT;
    const glow = ctx.createRadialGradient(stoneDrawX, stoneDrawY, 0, stoneDrawX, stoneDrawY, radius);
    glow.addColorStop(0, 'rgba(100,255,140,0.9)');
    glow.addColorStop(0.2, 'rgba(60,230,100,0.5)');
    glow.addColorStop(0.5, 'rgba(40,180,80,0.2)');
    glow.addColorStop(1, 'rgba(20,120,50,0)');
    ctx.fillStyle = glow;
    ctx.fillRect(0, 0, GW, GH);
    ctx.restore();
  }

  // Phase 2 (0.15–0.8): Light rays radiate from stone as it descends
  if (t > 0.15) {
    const rayT = Math.min(1, (t - 0.15) / 0.65);
    ctx.save();
    for (let r = 0; r < 12; r++) {
      const baseAngle = (r / 12) * Math.PI * 2;
      const angle = baseAngle + Math.sin(tick * 0.02 + r * 0.8) * 0.15;
      const rayLen = rayT * (120 + Math.sin(tick * 0.03 + r * 1.3) * 40);
      const rx = stoneDrawX + Math.cos(angle) * rayLen;
      const ry = stoneDrawY + Math.sin(angle) * rayLen;
      ctx.globalAlpha = rayT * (0.08 + Math.sin(tick * 0.04 + r * 2.1) * 0.03);
      ctx.strokeStyle = 'rgba(120,255,170,0.8)';
      ctx.lineWidth = 1.5 + Math.sin(tick * 0.05 + r) * 0.5;
      ctx.beginPath();
      ctx.moveTo(stoneDrawX, stoneDrawY);
      ctx.lineTo(rx, ry);
      ctx.stroke();
    }
    ctx.restore();
  }

  // Phase 3 (0.1–1.0): Trailing sparkle particles along the float path
  if (t > 0.1) {
    ctx.save();
    for (let s = 0; s < 24; s++) {
      // Particles trail behind the stone and orbit around it
      const pDelay = s * 0.03;
      const pT = Math.max(0, Math.min(1, (t - floatStart - pDelay) / (floatEnd - floatStart)));
      if (pT <= 0) continue;
      const pe = easeInOutCubic(pT);
      const baseX = startX + (endX - startX) * pe;
      const baseY = startY + (endY - startY) * pe;
      // Orbit offset from path
      const orbitR = 15 + Math.sin(s * 1.7) * 10;
      const orbitAngle = tick * 0.04 + s * (Math.PI * 2 / 24);
      const px = baseX + Math.cos(orbitAngle) * orbitR;
      const py = baseY + Math.sin(orbitAngle) * orbitR * 0.6 + Math.sin(tick * 0.06 + s) * 2;
      const pa = Math.max(0, Math.sin(tick * 0.05 + s * 2.3)) * 0.5 * Math.min(1, pT * 3);
      if (pa > 0.05 && px > 0 && px < GW && py > 0 && py < GH) {
        ctx.globalAlpha = pa;
        ctx.fillStyle = s % 3 === 0 ? 'rgba(220,255,230,1)' : 'rgba(100,255,160,1)';
        ctx.fillRect(px, py, s % 4 === 0 ? 2 : 1, s % 4 === 0 ? 2 : 1);
      }
    }
    ctx.restore();
  }

  // Phase 4 (0.5–1.0): Green ambient wash over cave
  if (t > 0.5) {
    const washT = Math.min(1, (t - 0.5) / 0.5);
    ctx.save();
    ctx.globalAlpha = washT * 0.08;
    ctx.fillStyle = 'rgba(80,220,120,1)';
    ctx.fillRect(0, 0, GW, GH);
    ctx.restore();
  }

  // Phase 5 (0.1–1.0): The floating jade stone itself
  if (t > 0.1) {
    const stoneAlpha = Math.min(1, (t - 0.1) / 0.2);
    // Scale grows slightly as it approaches center
    const sc = 1.0 + eased * 0.6;
    // Slow rotation
    const rot = Math.sin(tick * 0.015) * 0.12;

    ctx.save();
    ctx.translate(stoneDrawX, stoneDrawY);
    ctx.rotate(rot);
    ctx.scale(sc, sc);

    // Outer aura glow
    ctx.globalAlpha = stoneAlpha * (0.4 + Math.sin(tick * 0.04) * 0.1);
    const aura = ctx.createRadialGradient(0, 0, 4, 0, 0, 28);
    aura.addColorStop(0, 'rgba(100,255,150,0.6)');
    aura.addColorStop(0.5, 'rgba(60,200,100,0.2)');
    aura.addColorStop(1, 'rgba(30,150,60,0)');
    ctx.fillStyle = aura;
    ctx.fillRect(-28, -28, 56, 56);

    // The jade stone — faceted gem
    ctx.globalAlpha = stoneAlpha;
    // Dark base
    ctx.fillStyle = '#1a4a2a';
    ctx.beginPath();
    ctx.moveTo(0, -12); ctx.lineTo(14, 0); ctx.lineTo(12, 14);
    ctx.lineTo(-12, 14); ctx.lineTo(-14, 0); ctx.closePath();
    ctx.fill();
    // Mid tone
    ctx.fillStyle = '#2a7a3a';
    ctx.beginPath();
    ctx.moveTo(0, -10); ctx.lineTo(12, 1); ctx.lineTo(10, 12);
    ctx.lineTo(-10, 12); ctx.lineTo(-12, 1); ctx.closePath();
    ctx.fill();
    // Lighter face
    ctx.fillStyle = '#3a9a4a';
    ctx.beginPath();
    ctx.moveTo(0, -6); ctx.lineTo(8, 2); ctx.lineTo(6, 10);
    ctx.lineTo(-6, 10); ctx.lineTo(-8, 2); ctx.closePath();
    ctx.fill();
    // Highlight
    ctx.fillStyle = 'rgba(180,255,200,0.5)';
    ctx.beginPath();
    ctx.ellipse(-2, 0, 5, 3, -0.3, 0, Math.PI * 2);
    ctx.fill();
    // Veins
    ctx.strokeStyle = 'rgba(20,80,30,0.3)';
    ctx.lineWidth = 0.6;
    ctx.beginPath(); ctx.moveTo(-6, -2); ctx.quadraticCurveTo(0, 4, 6, 0); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-4, 8); ctx.quadraticCurveTo(2, 5, 8, 8); ctx.stroke();
    // Inner luminous glow
    ctx.fillStyle = 'rgba(100,255,150,0.2)';
    ctx.beginPath();
    ctx.ellipse(0, 4, 8, 6, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  // Phase 6 (0.7–1.0): Bright flash as stone reaches center
  if (t > 0.7) {
    const coreT = (t - 0.7) / 0.3;
    const flash = Math.sin(coreT * Math.PI);
    ctx.save();
    ctx.globalAlpha = flash * 0.5;
    const coreGlow = ctx.createRadialGradient(stoneDrawX, stoneDrawY, 0, stoneDrawX, stoneDrawY, 60);
    coreGlow.addColorStop(0, 'rgba(220,255,230,1)');
    coreGlow.addColorStop(0.3, 'rgba(140,255,170,0.6)');
    coreGlow.addColorStop(0.7, 'rgba(80,220,120,0.2)');
    coreGlow.addColorStop(1, 'rgba(40,180,80,0)');
    ctx.fillStyle = coreGlow;
    ctx.fillRect(stoneDrawX - 60, stoneDrawY - 60, 120, 120);
    ctx.restore();
  }
}

function drawGhostArm() {
  const ghost = npcChars.ghost;
  if (ghost.arm === undefined || ghost.arm < 0) return;
  if (ghost.scene !== state.scene) return;
  const arm = ghost.arm; // 0 = down, 1 = raised pointing
  const gx = ghost.x;
  const gy = ghost.y;

  const shoulderX = gx + ghost.dir * 10;
  const shoulderY = gy - 60;
  // Canvas: PI/2 = down, -PI/3 = up-right ~60°
  const elbowAngle = Math.PI * 0.5 - arm * (Math.PI * 0.5 + Math.PI / 3);
  const elbowX = shoulderX + Math.cos(elbowAngle) * 22 * ghost.dir;
  const elbowY = shoulderY + Math.sin(elbowAngle) * 22;
  const handAngle = elbowAngle - arm * 0.3;
  const handX = elbowX + Math.cos(handAngle) * 24 * ghost.dir;
  const handY = elbowY + Math.sin(handAngle) * 24;

  const alpha = state.seq.ghostMat.alpha || (ghost.visible ? 0.5 : 0);
  if (alpha <= 0) return;

  ctx.save();
  ctx.globalAlpha = alpha * 0.7;
  ctx.strokeStyle = 'rgba(170,210,240,0.8)';
  ctx.shadowColor = 'rgba(100,180,255,0.5)';
  ctx.shadowBlur = 10;
  ctx.lineWidth = 4;
  ctx.lineCap = 'round';
  // Arm as smooth curve
  ctx.beginPath();
  ctx.moveTo(shoulderX, shoulderY);
  ctx.quadraticCurveTo(elbowX, elbowY, handX, handY);
  ctx.stroke();

  // Subtle fingertip glow when mostly raised
  if (arm > 0.7) {
    const glowT = (arm - 0.7) / 0.3;
    ctx.globalAlpha = alpha * glowT * 0.5;
    const fg = ctx.createRadialGradient(handX, handY, 0, handX, handY, 10);
    fg.addColorStop(0, 'rgba(150,200,255,0.7)');
    fg.addColorStop(1, 'rgba(100,160,255,0)');
    ctx.fillStyle = fg;
    ctx.fillRect(handX - 10, handY - 10, 20, 20);
  }
  ctx.restore();
}

// ════════════════════════════════════════════════════════════
// JADE DISCOVERY SEQUENCE
// ════════════════════════════════════════════════════════════
function startJadeSequence() {
  startSequence([
    // Phase 0: Make jade gem visible for the reveal animation
    { type: 'callback', fn: () => { state.flags.jade_visible = true; } },
    // Phase 1: Something responds — cave goes quiet, resonance builds
    { type: 'callback', fn: () => playSFX('jade_reveal') },
    { type: 'env', duration: 1.5, darken: 0.15, vignette: 0.3, spectral: 0 },
    { type: 'dialog', lines: [{s:'',t:'Κάτι αντηχεί βαθιά μέσα στον βράχο. Οι σταγόνες σταματούν. Σιωπή.'}] },

    // Phase 2: Clio reacts, looks up
    { type: 'move', who: 'clio', dx: -15, duration: 0.6 },
    { type: 'dialog', lines: [
      {s:'ΚΛΕΙΩ',t:'Περιμένετε...'},
      {s:'',t:'Η Κλειώ κοιτάζει ΠΑΝΩ — η γωνία που μόνο μια επτάχρονη θα δοκίμαζε.'},
    ]},

    // Phase 3: Green light floods the cave, stone floats to center
    { type: 'callback', fn: () => changeSceneMusic('_jade') },
    { type: 'effect', effect: 'jade_reveal', duration: 4.0 },
    { type: 'dialog', lines: [
      {s:'ΚΛΕΙΩ',t:'ΕΚΕΙ! Κάτι πράσινο — λάμπει!'},
      {s:'ΑΙΑΣ',t:'Αιωρείται! Μπαμπά, η πέτρα αιωρείται!'},
    ]},

    // Phase 4: Stone arrives at center
    { type: 'dialog', lines: [
      {s:'',t:'Η πέτρα αιωρείται στο κέντρο του σπηλαίου, τυλιγμένη σε πράσινο φως. Σκούρα πράσινη, λεία, ζεστή σαν να ζει.'},
      {s:'ΚΛΕΙΩ',t:'Σας. Το. Είπα.'},
    ]},

    // Phase 5: Take the stone + identify it
    { type: 'callback', fn: () => {
      state.flags.jade_found = true;
      addInv({ id: 'green_stone', label: 'Πράσινη Πέτρα', desc: 'Μια λεία πράσινη πέτρα από νεφρίτη. Λάμπει αχνά στο φως. Ανήκε στον Καπετάν Βισβίκη.' });
    }},
    { type: 'dialog', lines: [
      {s:'ΝΤΕΜΗΣ',t:'Νεφρίτης. Jade. Από την Ανατολή.'},
      {s:'ΑΙΑΣ',t:'Αξίζει κάτι;'},
      {s:'ΝΤΕΜΗΣ',t:'Αξίζει ό,τι ο Βισβίκης ήθελε να δείξει μ\' αυτό. Τώρα πρέπει... να του το πάμε.'},
      {s:'ΑΙΑΣ',t:'...Στο νεκροταφείο.'},
      {s:'ΚΛΕΙΩ',t:'Σας. Το. Είπα.'},
    ]},

    // Phase 6: Return to normal
    { type: 'env', duration: 2.0, darken: 0, vignette: 0, spectral: 0 },
    { type: 'callback', fn: () => changeSceneMusic('cave') },
  ]);
}

// ════════════════════════════════════════════════════════════
// GHOST SUMMONING SEQUENCE
// ════════════════════════════════════════════════════════════
function startGhostSequence() {
  startSequence([
    // SILENCE POCKET — fade ALL audio to zero before ghost appears
    { type: 'callback', fn: () => {
      fadeAllAudio(0, 1500);
    }},
    { type: 'env', duration: 1.5, darken: 0.35, vignette: 0.6, spectral: 0.8 },
    { type: 'dialog', lines: [{s:'',t:'Ο αέρας αλλάζει. Η θερμοκρασία πέφτει. Τα κυπαρίσσια σταματούν να κουνιούνται.'}] },
    { type: 'move', who: 'clio', dx: 25, duration: 0.8 },
    { type: 'move', who: 'ajax', dx: 20, duration: 0.8 },
    { type: 'dialog', lines: [{s:'ΚΛΕΙΩ',t:'Μπαμπά... κάποιος είναι εκεί. Στο φως.'}] },
    // Total silence — the absence of sound IS the effect
    { type: 'wait', duration: 1.5 },
    // Ghost SFX breaks the silence
    { type: 'callback', fn: () => playSFX('ghost') },
    { type: 'wait', duration: 1.0 },
    { type: 'effect', effect: 'materialize', duration: 3.0 },
    // Ghost music enters AFTER the ghost materializes — earned
    { type: 'callback', fn: () => {
      changeSceneMusic('_ghost');
      fadeAllAudio(1, 2000);
    }},
    { type: 'npc', who: 'ghost', visible: true },
    { type: 'dialog', lines: [
      {s:'',t:'Μια φιγούρα υψώνεται πάνω από τον τάφο. Ψηλός, αυστηρός, με ναυτική στολή από άλλη εποχή.'},
      {s:'ΝΤΕΜΗΣ',t:'Καπετάν Βισβίκη... Εκατόν είκοσι χρόνια περίμενες.'},
      {s:'ΑΙΑΣ',t:'Μας κοιτάει. Δεν φοβάμαι. Μοιάζει... χαρούμενος.'},
    ]},
    { type: 'npc', who: 'ghost', dir: -1 },
    { type: 'wait', duration: 0.8 },
    { type: 'npc', who: 'ghost', dir: 1 },
    { type: 'wait', duration: 0.6 },
    // Ghost raises arm and points to church
    { type: 'callback', fn: () => { npcChars.ghost.arm = 0; }},
    { type: 'npc', who: 'ghost', dir: 1, tilt: -0.1 },
    { type: 'effect', effect: 'arm_raise', duration: 1.2 },
    { type: 'dialog', lines: [{s:'',t:'Το φάντασμα σηκώνει αργά το χέρι. Δείχνει... προς τον Άγιο Νικόλαο.'}] },
    { type: 'dialog', lines: [
      {s:'ΝΤΕΜΗΣ',t:'Δείχνει προς την εκκλησία... Τον Άγιο Νικόλαο.'},
    ]},
    // Clio waves at the ghost — storyboard iconic moment
    { type: 'npc', who: 'ghost', tilt: 0, wave: 3 },
    { type: 'dialog', lines: [{s:'ΚΛΕΙΩ',t:'Γεια σου, καπετάνιε! Γεια σου!'}] },
    { type: 'wait', duration: 1.0 },
    { type: 'npc', who: 'ghost', wave: 0 },
    { type: 'callback', fn: () => { npcChars.ghost.arm = -1; }},
    { type: 'effect', effect: 'fade_out', duration: 2.5 },
    { type: 'effect', effect: 'stone_glow', duration: 1.5 },
    { type: 'env', duration: 2.0, darken: 0, vignette: 0, spectral: 0 },
    // Crossfade back to graveyard music
    { type: 'callback', fn: () => {
      changeSceneMusic('graveyard');
    }},
    // Clio processes the experience — the compass validates the emotion
    { type: 'wait', duration: 2.0 },
    { type: 'dialog', lines: [
      {s:'ΚΛΕΙΩ',t:'Δεν φοβήθηκα. Ήταν... λυπημένος.'},
    ]},
    { type: 'wait', duration: 1.5 },
    { type: 'dialog', lines: [
      {s:'ΚΛΕΙΩ',t:'Η θάλασσα θυμάται...'},
      {s:'ΝΤΕΜΗΣ',t:'Στον Άγιο Νικόλαο. Τώρα.'},
    ]},
    { type: 'callback', fn: () => {
      const sc = scenes.graveyard;
      if (!sc.exits.find(e => e.target === 'church')) {
        sc.exits.push({ side: 'right', target: 'church', label: 'Αγ. Νικόλαος →' });
      }
      npcChars.ghost.visible = false;
      // Hide ghost hotspot — ghost has departed, should not reappear
      const ghostObj = sc.objects.find(o => o.id === 'ghost_npc');
      if (ghostObj) ghostObj._hidden = true;
    }},
  ]);
}

function drawDialogue() {
  if (!state.dlg.active) return;
  const boxH = 100;
  const boxY = GH - boxH;

  // Background
  ctx.save();
  ctx.globalAlpha = 0.92;
  ctx.fillStyle = '#0a0806';
  ctx.fillRect(0, boxY, GW, boxH);
  ctx.restore();

  // Top border
  ctx.fillStyle = '#D4A03C';
  ctx.fillRect(0, boxY, GW, 2);

  // Portrait — only show for named speakers
  const portSize = 80;
  const portX = 12;
  const portY = boxY + 8;
  const hasSpeaker = !!state.dlg.speaker;

  let textX;
  if (hasSpeaker) {
    ctx.strokeStyle = '#D4A03C';
    ctx.lineWidth = 2;
    ctx.strokeRect(portX, portY, portSize, portSize);
    ctx.fillStyle = '#1a1714';
    ctx.fillRect(portX + 1, portY + 1, portSize - 2, portSize - 2);

    const portImg = PORTRAITS[state.dlg.speaker];
    if (portImg && portImg.complete) {
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(portImg, portX + 2, portY + 2, portSize - 4, portSize - 4);
      ctx.imageSmoothingEnabled = false;
    } else {
      ctx.fillStyle = '#4a4a4a';
      ctx.font = '16px serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('?', portX + portSize/2, portY + portSize/2);
    }

    textX = portX + portSize + 12;

    ctx.fillStyle = '#D4A03C';
    ctx.font = '9px "Press Start 2P", monospace';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText(state.dlg.speaker, textX, portY + 2);
  } else {
    // Narration — no portrait box, full width
    textX = 16;
  }

  // Dialogue text with word wrapping
  ctx.fillStyle = hasSpeaker ? '#e8dcc8' : '#D4A03C';
  ctx.font = '8px "Press Start 2P", monospace';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  const maxW = GW - textX - 16;
  const lineH = 16;
  const startY = portY + (state.dlg.speaker ? 18 : 6);
  wrapText(state.dlg.displayed, textX, startY, maxW, lineH);

  // Continue indicator
  if (state.dlg.charIdx >= state.dlg.text.length) {
    const blink = Math.sin(state.tick * 0.12) > 0;
    if (blink) {
      ctx.fillStyle = '#4a4a4a';
      ctx.font = '8px "Press Start 2P", monospace';
      ctx.textAlign = 'right';
      ctx.fillText('▶', GW - 12, boxY + boxH - 14);
    }
  }
}

function wrapText(text, x, y, maxW, lineH) {
  const words = text.split(' ');
  let line = '';
  let curY = y;
  for (const word of words) {
    const test = line ? line + ' ' + word : word;
    const m = ctx.measureText(test);
    if (m.width > maxW && line) {
      ctx.fillText(line, x, curY);
      line = word;
      curY += lineH;
    } else {
      line = test;
    }
  }
  if (line) ctx.fillText(line, x, curY);
}

// ════════════════════════════════════════════════════════════
// VERB SYSTEM
// ════════════════════════════════════════════════════════════
const verbLabels = { look:'Κοίταξε', talk:'Μίλησε', open:'Άνοιξε', use:'Χρησιμοποίησε' };
// Verb fallbacks: "use" tries pick/push/close; "open" tries use
const verbFallbacks = { use: ['pick','push','close','open'], open: ['use'] };

function setVerb(v) {
  state.verb = v;
  playSFX('click');
  document.querySelectorAll('.vb').forEach(b => b.classList.remove('on'));
  document.querySelector(`[data-v="${v}"]`)?.classList.add('on');
  updateActionLine();
}

function updateActionLine() {
  const al = document.getElementById('action-line');
  const obj = state.hoverObj;
  al.textContent = obj ? `${verbLabels[state.verb]} ${obj.label}` : (verbLabels[state.verb] || '');
}

function objClick(obj) {
  if (state.dlg.active) return;
  const objCenterX = obj.x + obj.w / 2;

  // Walk Ntemis to object, then execute verb
  startWalk('ntemis', objCenterX, () => {
    let d = obj.verbs[state.verb];
    // Verb fallback: "use" tries open/push/close if no direct match
    if (!d && verbFallbacks[state.verb]) {
      for (const fb of verbFallbacks[state.verb]) {
        if (obj.verbs[fb]) { d = obj.verbs[fb]; break; }
      }
    }
    if (!d) {
      const defs = {
        look:[{s:'',t:'Τίποτα ιδιαίτερο.'}],
        talk:[{s:'ΝΤΕΜΗΣ',t:'Δεν μπορώ να μιλήσω σε αυτό.'}],
        open:[{s:'ΝΤΕΜΗΣ',t:'Δεν ανοίγει.'}],
        use:[{s:'ΝΤΕΜΗΣ',t:'Δεν ξέρω πώς.'}],
      };
      if (defs[state.verb]?.length) showDlg(defs[state.verb]);
      return;
    }
    if (typeof d === 'function') d = d();
    if (typeof d === 'string') { playSFX('door'); changeScene(d); return; }
    if (Array.isArray(d) && d.length) showDlg(d);
  });
  familyFollow(objCenterX);
}

// ════════════════════════════════════════════════════════════
// INVENTORY
// ════════════════════════════════════════════════════════════
function addInv(item) {
  if (state.inv.find(i => i.id === item.id)) return;
  state.inv.push(item);
  playSFX('pickup');
  renderInvUI();
}

function removeInv(id) {
  state.inv = state.inv.filter(i => i.id !== id);
  renderInvUI();
}

// Inventory item icons — pixel art drawn on mini canvases (52x52)
const INV_ICONS = {
  note: (c) => {
    // Rolled scroll with wax seal
    c.fillStyle='#c4a870'; c.fillRect(12,4,28,40);
    c.fillStyle='#d8c490'; c.fillRect(14,6,24,36);
    // Roll top
    c.fillStyle='#b09058'; c.fillRect(10,4,32,5);
    c.fillStyle='#c4a870';
    c.beginPath(); c.ellipse(10,7,3,4,0,0,Math.PI*2); c.fill();
    c.beginPath(); c.ellipse(42,7,3,4,0,0,Math.PI*2); c.fill();
    // Text lines
    c.fillStyle='#8a7a58';
    for(let y=14;y<38;y+=5) c.fillRect(18,y,18,2);
    // Wax seal
    c.fillStyle='#b03030'; c.beginPath(); c.arc(36,38,5,0,Math.PI*2); c.fill();
    c.fillStyle='#d04040'; c.beginPath(); c.arc(35,37,3,0,Math.PI*2); c.fill();
    // "Γ" on seal
    c.fillStyle='#e8c8c8'; c.font='bold 5px sans-serif'; c.textAlign='center'; c.textBaseline='middle';
    c.fillText('Γ',36,38);
  },
  compass: (c) => {
    // Brass compass body
    c.fillStyle='#8a6a30'; c.beginPath(); c.arc(26,26,18,0,Math.PI*2); c.fill();
    c.fillStyle='#b08838'; c.beginPath(); c.arc(26,26,16,0,Math.PI*2); c.fill();
    c.fillStyle='#1a1810'; c.beginPath(); c.arc(26,26,14,0,Math.PI*2); c.fill();
    // Compass rose
    c.fillStyle='#c03030'; c.beginPath(); c.moveTo(26,12); c.lineTo(28,26); c.lineTo(24,26); c.fill();
    c.fillStyle='#e0d0c0'; c.beginPath(); c.moveTo(26,40); c.lineTo(28,26); c.lineTo(24,26); c.fill();
    c.fillStyle='#607090'; c.beginPath(); c.moveTo(12,26); c.lineTo(26,24); c.lineTo(26,28); c.fill();
    c.fillStyle='#607090'; c.beginPath(); c.moveTo(40,26); c.lineTo(26,24); c.lineTo(26,28); c.fill();
    // Center pin
    c.fillStyle='#d4a03c'; c.beginPath(); c.arc(26,26,2,0,Math.PI*2); c.fill();
    // N marker
    c.fillStyle='#c03030'; c.font='bold 5px sans-serif'; c.textAlign='center'; c.fillText('N',26,11);
  },
  shell: (c) => {
    // Scallop shell
    c.fillStyle='#e8d0b0'; c.beginPath(); c.ellipse(26,28,16,12,0,0,Math.PI*2); c.fill();
    c.fillStyle='#d4b89c'; c.beginPath(); c.ellipse(26,30,14,10,0,0,Math.PI); c.fill();
    // Ridges
    c.strokeStyle='#a08060'; c.lineWidth=1.5;
    for(let i=0;i<7;i++){c.beginPath();c.moveTo(26,16);c.lineTo(12+i*5,40);c.stroke();}
    // Highlight
    c.fillStyle='rgba(255,255,255,0.2)'; c.beginPath(); c.ellipse(22,24,6,4,-.3,0,Math.PI*2); c.fill();
  },
  candle: (c) => {
    // Candlestick with flame
    c.fillStyle='#8a6a30'; c.fillRect(20,36,12,8); // base
    c.fillStyle='#a08038'; c.fillRect(22,34,8,4); // holder
    c.fillStyle='#e8dcc0'; c.fillRect(24,16,4,20); // wax body
    c.fillStyle='#d4c8a0'; c.fillRect(23,16,6,3); // wax top
    // Wick
    c.fillStyle='#2a2a2a'; c.fillRect(25,12,2,5);
    // Flame
    c.fillStyle='#d4a03c'; c.beginPath(); c.ellipse(26,10,5,8,0,0,Math.PI*2); c.fill();
    c.fillStyle='#f0d060'; c.beginPath(); c.ellipse(26,10,3,5,0,0,Math.PI*2); c.fill();
    c.fillStyle='#fff8e0'; c.beginPath(); c.ellipse(26,11,1,3,0,0,Math.PI*2); c.fill();
  },
  green_stone: (c) => {
    // Jade stone — smooth green gem with veins
    c.fillStyle='#1a4a2a'; c.beginPath(); c.moveTo(26,8); c.lineTo(40,20); c.lineTo(38,36);
    c.lineTo(14,36); c.lineTo(12,20); c.closePath(); c.fill();
    c.fillStyle='#2a7a3a'; c.beginPath(); c.moveTo(26,10); c.lineTo(38,21); c.lineTo(36,34);
    c.lineTo(16,34); c.lineTo(14,21); c.closePath(); c.fill();
    // Lighter face
    c.fillStyle='#3a9a4a'; c.beginPath(); c.moveTo(26,14); c.lineTo(34,22); c.lineTo(32,30);
    c.lineTo(20,30); c.lineTo(18,22); c.closePath(); c.fill();
    // Highlight
    c.fillStyle='rgba(180,255,200,0.4)'; c.beginPath(); c.ellipse(24,20,5,3,-0.3,0,Math.PI*2); c.fill();
    // Veins
    c.strokeStyle='rgba(20,80,30,0.3)'; c.lineWidth=0.8;
    c.beginPath(); c.moveTo(20,18); c.quadraticCurveTo(26,24,32,20); c.stroke();
    c.beginPath(); c.moveTo(22,28); c.quadraticCurveTo(28,25,34,28); c.stroke();
    // Inner glow
    c.fillStyle='rgba(100,255,150,0.15)'; c.beginPath(); c.ellipse(26,24,8,6,0,0,Math.PI*2); c.fill();
  },
  key: (c) => {
    // Ornate brass key
    c.fillStyle='#c49030'; c.strokeStyle='#8a6020'; c.lineWidth=1;
    // Bow (head)
    c.beginPath(); c.arc(16,20,8,0,Math.PI*2); c.fill(); c.stroke();
    c.fillStyle='#1a1208'; c.beginPath(); c.arc(16,20,4,0,Math.PI*2); c.fill();
    // Shaft
    c.fillStyle='#c49030'; c.fillRect(23,18,20,4);
    c.strokeStyle='#8a6020'; c.strokeRect(23,18,20,4);
    // Teeth
    c.fillStyle='#c49030';
    c.fillRect(38,22,3,6); c.fillRect(34,22,2,4); c.fillRect(42,18,2,4);
    c.strokeStyle='#8a6020';
    c.strokeRect(38,22,3,6); c.strokeRect(34,22,2,4);
  },
  visvikis_letter: (c) => {
    // Old sealed letter with wax seal
    c.fillStyle='#c4a870'; c.fillRect(10,6,32,36);
    c.fillStyle='#d8c490'; c.fillRect(12,8,28,32);
    // Aged paper texture (dark spots)
    c.fillStyle='rgba(120,90,40,0.15)';
    c.fillRect(14,12,8,3); c.fillRect(28,22,6,2); c.fillRect(18,30,10,2);
    // Handwritten text lines
    c.fillStyle='#5a4a30';
    for(let y=14;y<36;y+=4) c.fillRect(16,y,20,1.5);
    // Wax seal (red, with anchor symbol)
    c.fillStyle='#8a2020'; c.beginPath(); c.arc(34,36,6,0,Math.PI*2); c.fill();
    c.fillStyle='#b03030'; c.beginPath(); c.arc(33,35,4,0,Math.PI*2); c.fill();
    // Anchor on seal
    c.strokeStyle='#e8c8c8'; c.lineWidth=1;
    c.beginPath(); c.moveTo(33,32); c.lineTo(33,38); c.stroke();
    c.beginPath(); c.arc(33,38,2,0,Math.PI); c.stroke();
    c.beginPath(); c.moveTo(31,34); c.lineTo(35,34); c.stroke();
    // Fold crease
    c.strokeStyle='rgba(100,80,40,0.2)'; c.lineWidth=0.5;
    c.beginPath(); c.moveTo(10,24); c.lineTo(42,24); c.stroke();
  },
  brass_key: (c) => {
    // Small ornate brass key
    c.fillStyle='#c49030'; c.strokeStyle='#8a6020'; c.lineWidth=1;
    // Bow (oval head)
    c.beginPath(); c.ellipse(18,22,8,9,0,0,Math.PI*2); c.fill(); c.stroke();
    c.fillStyle='#1a1208'; c.beginPath(); c.ellipse(18,22,4,5,0,0,Math.PI*2); c.fill();
    // Shaft
    c.fillStyle='#c49030'; c.fillRect(25,20,16,3);
    c.strokeStyle='#8a6020'; c.strokeRect(25,20,16,3);
    // Teeth
    c.fillStyle='#c49030';
    c.fillRect(38,23,3,5); c.fillRect(35,23,2,3);
    c.strokeStyle='#8a6020';
    c.strokeRect(38,23,3,5); c.strokeRect(35,23,2,3);
    // Highlight on bow
    c.fillStyle='rgba(255,220,160,0.3)';
    c.beginPath(); c.ellipse(16,19,4,3,-0.4,0,Math.PI*2); c.fill();
  },
  lantern: (c) => {
    // Brass nautical lantern
    c.fillStyle='#8a6a30'; c.fillRect(20,6,12,4); // top cap
    c.fillStyle='#a08038'; c.fillRect(24,2,4,5); // handle base
    c.beginPath(); c.arc(26,2,4,Math.PI,0); c.strokeStyle='#8a6a30'; c.lineWidth=2; c.stroke(); // handle arc
    // Glass body
    c.fillStyle='#1a3040'; c.fillRect(18,10,16,22);
    c.fillStyle='rgba(255,200,80,0.3)'; c.fillRect(20,12,12,18); // warm glow
    // Brass frame
    c.strokeStyle='#8a6a30'; c.lineWidth=1.5;
    c.strokeRect(18,10,16,22);
    c.beginPath(); c.moveTo(18,21); c.lineTo(34,21); c.stroke(); // mid band
    // Flame inside
    c.fillStyle='#d4a03c'; c.beginPath(); c.ellipse(26,18,3,5,0,0,Math.PI*2); c.fill();
    c.fillStyle='#f0d060'; c.beginPath(); c.ellipse(26,18,2,3,0,0,Math.PI*2); c.fill();
    c.fillStyle='#fff8e0'; c.beginPath(); c.ellipse(26,19,1,2,0,0,Math.PI*2); c.fill();
    // Base
    c.fillStyle='#8a6a30'; c.fillRect(16,32,20,5);
    c.fillStyle='#6a5020'; c.fillRect(18,37,16,3);
    // Light rays
    c.strokeStyle='rgba(255,200,80,0.2)'; c.lineWidth=0.5;
    c.beginPath(); c.moveTo(20,16); c.lineTo(12,12); c.stroke();
    c.beginPath(); c.moveTo(32,16); c.lineTo(40,12); c.stroke();
    c.beginPath(); c.moveTo(20,22); c.lineTo(12,26); c.stroke();
    c.beginPath(); c.moveTo(32,22); c.lineTo(40,26); c.stroke();
  },
  nautical_chart: (c) => {
    // Rolled nautical chart with X mark
    c.fillStyle='#c4a870'; c.fillRect(8,6,36,36);
    c.fillStyle='#d8c490'; c.fillRect(10,8,32,32);
    // Map lines (coastline)
    c.strokeStyle='#8a7a58'; c.lineWidth=1;
    c.beginPath(); c.moveTo(14,20); c.quadraticCurveTo(22,16,30,22); c.quadraticCurveTo(36,26,38,20); c.stroke();
    c.beginPath(); c.moveTo(12,30); c.quadraticCurveTo(20,28,28,32); c.quadraticCurveTo(34,34,40,30); c.stroke();
    // X mark
    c.strokeStyle='#c03030'; c.lineWidth=2;
    c.beginPath(); c.moveTo(22,22); c.lineTo(30,30); c.stroke();
    c.beginPath(); c.moveTo(30,22); c.lineTo(22,30); c.stroke();
    // Compass rose (tiny)
    c.fillStyle='#c03030'; c.beginPath(); c.moveTo(36,10); c.lineTo(37,14); c.lineTo(35,14); c.fill();
    c.fillStyle='#607090'; c.beginPath(); c.moveTo(36,18); c.lineTo(37,14); c.lineTo(35,14); c.fill();
    // Roll edges
    c.fillStyle='#b09058'; c.fillRect(6,6,38,3); c.fillRect(6,39,38,3);
  },
  shovel: (c) => {
    // Small rusty iron shovel — gift from Giannis
    // Wooden handle
    c.fillStyle='#8a6a3a'; c.fillRect(24,4,4,26);
    c.fillStyle='#7a5a2a'; c.fillRect(25,4,2,26);
    // Handle grip top
    c.fillStyle='#6a4a20'; c.fillRect(22,3,8,3);
    c.fillStyle='#7a5a2a'; c.fillRect(23,4,6,1);
    // Metal collar
    c.fillStyle='#606060'; c.fillRect(22,28,8,3);
    c.fillStyle='#787878'; c.fillRect(23,29,6,1);
    // Iron blade (spade shape)
    c.fillStyle='#6a6a6a';
    c.beginPath();
    c.moveTo(18,31); c.lineTo(34,31);
    c.lineTo(36,36); c.quadraticCurveTo(36,48,26,50);
    c.quadraticCurveTo(16,48,16,36); c.lineTo(18,31);
    c.fill();
    // Blade highlight
    c.fillStyle='#888888';
    c.beginPath();
    c.moveTo(19,32); c.lineTo(26,32);
    c.lineTo(26,48); c.quadraticCurveTo(18,46,17,36);
    c.lineTo(19,32);
    c.fill();
    // Rust spots
    c.fillStyle='#8a5530'; c.fillRect(22,35,3,2);
    c.fillStyle='#7a4a28'; c.fillRect(28,40,2,2);
    c.fillStyle='#8a5530'; c.fillRect(20,43,2,1);
    // Edge shine
    c.strokeStyle='rgba(200,200,200,0.3)'; c.lineWidth=0.5;
    c.beginPath();
    c.moveTo(18,32); c.quadraticCurveTo(16,40,26,50);
    c.stroke();
  },
};

function renderInvUI() {
  const grid = document.getElementById('inv-grid');
  grid.innerHTML = '';
  for (const item of state.inv) {
    const slot = document.createElement('div');
    slot.className = 'inv-slot';
    slot.dataset.id = item.id;
    slot.onclick = () => invClick(item.id);
    if (INV_ICONS[item.id]) {
      const cvs = document.createElement('canvas');
      cvs.width = 52; cvs.height = 52;
      cvs.style.cssText = 'width:52px;height:52px;image-rendering:pixelated';
      INV_ICONS[item.id](cvs.getContext('2d'));
      slot.appendChild(cvs);
    } else {
      const txt = document.createElement('span');
      txt.className = 'inv-text';
      txt.textContent = item.label;
      slot.appendChild(txt);
    }
    slot.title = item.label;
    grid.appendChild(slot);
  }
}

function scrollInv(dir) {
  const grid = document.getElementById('inv-grid');
  grid.scrollLeft += dir * 50;
}

function invClick(id) {
  const item = state.inv.find(i => i.id === id);
  if (item && item.desc) {
    showDlg([{s:'',t:item.desc}]);
  }
  document.querySelectorAll('.inv-slot').forEach(s => s.classList.remove('on'));
  document.querySelector(`[data-id="${id}"]`)?.classList.add('on');
}

// ════════════════════════════════════════════════════════════
// SAVE / LOAD SYSTEM
// ════════════════════════════════════════════════════════════
function saveGame(slot = 'auto') {
  const saveData = {
    scene: state.scene,
    inventory: state.inv,
    flags: state.flags,
    visited: [...state.visited],
    timestamp: new Date().toISOString(),
    version: GAME_VERSION,
  };
  try {
    localStorage.setItem('galaxidi-save-' + slot, JSON.stringify(saveData));
    if (slot === 'manual') showSaveIndicator();
  } catch(e) { console.warn('Save failed:', e); }
}

function loadGame(slot = 'auto') {
  try {
    const raw = localStorage.getItem('galaxidi-save-' + slot);
    if (!raw) return false;
    const data = JSON.parse(raw);
    state.inv = data.inventory || [];
    state.flags = data.flags || {};
    state.scene = data.scene;
    state.visited = new Set(data.visited || []);
    return true;
  } catch(e) { console.warn('Load failed:', e); return false; }
}

function hasSave(slot = 'auto') {
  return !!localStorage.getItem('galaxidi-save-' + slot);
}

function showSaveIndicator() {
  state.saveIndicator = { text: 'Αποθηκεύτηκε!', until: performance.now() + 1500 };
}

// ════════════════════════════════════════════════════════════
// FAST-TRAVEL MAP
// ════════════════════════════════════════════════════════════
function getMapHoverLocation(gx, gy) {
  for (let i = 0; i < MAP_LOCATIONS.length; i++) {
    const loc = MAP_LOCATIONS[i];
    const dx = gx - loc.x, dy = gy - loc.y;
    if (dx * dx + dy * dy < 625) return i; // 25px radius
  }
  return null;
}

function drawMap() {
  if (!state.mapOpen) return;
  const mx = 30, my = 20, mw = GW - 60, mh = GH - 40;

  // Dark backdrop
  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = '#0a0806';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();

  // Draw real map background image
  const mapImg = images['map-bg'];
  if (mapImg && mapImg.complete) {
    ctx.drawImage(mapImg, mx, my, mw, mh);
  } else {
    // Fallback: dark parchment fill
    ctx.fillStyle = '#1a1610';
    ctx.fillRect(mx, my, mw, mh);
  }

  // Gold border frame on top of map
  ctx.strokeStyle = '#D4A03C';
  ctx.lineWidth = 2;
  ctx.strokeRect(mx, my, mw, mh);
  ctx.strokeStyle = '#6a5a3a';
  ctx.lineWidth = 1;
  ctx.strokeRect(mx + 3, my + 3, mw - 6, mh - 6);

  // Title banner with dark background for readability
  ctx.save();
  ctx.fillStyle = 'rgba(20, 16, 8, 0.7)';
  ctx.fillRect(mx + 4, my + 4, mw - 8, 18);
  ctx.fillStyle = '#D4A03C';
  ctx.font = '9px "Press Start 2P", monospace';
  ctx.textAlign = 'center';
  ctx.shadowColor = '#000'; ctx.shadowBlur = 4;
  ctx.fillText('ΧΑΡΤΗΣ ΓΑΛΑΞΕΙΔΙΟΥ', GW / 2, my + 16);
  ctx.restore();

  // Path connections (dotted lines between locations)
  ctx.save();
  ctx.strokeStyle = 'rgba(212, 160, 60, 0.4)';
  ctx.lineWidth = 1;
  ctx.setLineDash([3, 3]);
  for (const [a, b] of MAP_PATHS) {
    const la = MAP_LOCATIONS.find(l => l.id === a);
    const lb = MAP_LOCATIONS.find(l => l.id === b);
    if (la && lb) {
      ctx.beginPath();
      ctx.moveTo(la.x, la.y);
      ctx.lineTo(lb.x, lb.y);
      ctx.stroke();
    }
  }
  ctx.setLineDash([]);
  ctx.restore();

  // Compass rose (bottom-right)
  const crx = mx + mw - 30, cry = my + mh - 30;
  ctx.save();
  ctx.strokeStyle = '#8a7a4a';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(crx, cry - 12); ctx.lineTo(crx, cry + 12);
  ctx.moveTo(crx - 12, cry); ctx.lineTo(crx + 12, cry);
  ctx.stroke();
  // Diagonal arms
  ctx.beginPath();
  ctx.moveTo(crx - 7, cry - 7); ctx.lineTo(crx + 7, cry + 7);
  ctx.moveTo(crx + 7, cry - 7); ctx.lineTo(crx - 7, cry + 7);
  ctx.stroke();
  // North arrow
  ctx.fillStyle = '#D4A03C';
  ctx.beginPath();
  ctx.moveTo(crx, cry - 12); ctx.lineTo(crx - 3, cry - 6); ctx.lineTo(crx + 3, cry - 6);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = '#8a7a4a';
  ctx.font = '5px "Press Start 2P", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('B', crx, cry - 15);
  ctx.restore();

  // Location markers
  for (let i = 0; i < MAP_LOCATIONS.length; i++) {
    const loc = MAP_LOCATIONS[i];
    const isVisited = loc.sceneIds.some(s => state.visited.has(s));
    const isCurrent = loc.sceneIds.includes(state.scene);
    const isHover = state.mapHover === i;

    ctx.save();
    if (isCurrent) {
      // Current: pulsing gold with dark outline for contrast
      const pulse = 6 + Math.sin(state.tick * 0.08) * 2;
      ctx.shadowColor = '#D4A03C';
      ctx.shadowBlur = pulse;
      ctx.strokeStyle = '#1a1200';
      ctx.lineWidth = 2;
      ctx.fillStyle = '#D4A03C';
      ctx.beginPath();
      ctx.arc(loc.x, loc.y, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = '#FFE8A0';
      ctx.beginPath();
      ctx.arc(loc.x, loc.y, 2.5, 0, Math.PI * 2);
      ctx.fill();
    } else {
      // All locations: gold dot with dark outline (clickable)
      ctx.strokeStyle = '#1a1200';
      ctx.lineWidth = 1.5;
      ctx.fillStyle = isHover ? '#FFE8A0' : (isVisited ? '#D4A03C' : '#B08828');
      ctx.beginPath();
      ctx.arc(loc.x, loc.y, isHover ? 5 : 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      if (isHover) {
        ctx.shadowColor = '#FFE8A0';
        ctx.shadowBlur = 6;
        ctx.strokeStyle = '#FFE8A0';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }
    ctx.restore();

    // Label for current + hover (with dark background for readability on map)
    if (isCurrent || isHover) {
      ctx.save();
      const label = loc.label;
      ctx.font = '7px "Press Start 2P", monospace';
      ctx.textAlign = 'center';
      const tw = ctx.measureText(label).width;
      // Dark pill behind label
      ctx.fillStyle = 'rgba(15, 12, 6, 0.75)';
      const lx = loc.x - tw / 2 - 4, ly = loc.y - 20;
      ctx.beginPath();
      ctx.roundRect(lx, ly, tw + 8, 12, 3);
      ctx.fill();
      // Label text
      ctx.fillStyle = isCurrent ? '#FFE8A0' : '#D4A03C';
      ctx.shadowColor = '#000'; ctx.shadowBlur = 2;
      ctx.fillText(label, loc.x, loc.y - 11);
      ctx.restore();
    }
  }

  // Bottom hint with background
  ctx.save();
  ctx.fillStyle = 'rgba(20, 16, 8, 0.7)';
  ctx.fillRect(mx + 4, my + mh - 16, mw - 8, 12);
  ctx.fillStyle = '#8a7a4a';
  ctx.font = '6px "Press Start 2P", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('Κλικ σε τοποθεσία | M ή ESC για κλείσιμο', GW / 2, GH - 26);
  ctx.restore();
}

// ════════════════════════════════════════════════════════════
// HELP OVERLAY
// ════════════════════════════════════════════════════════════
function drawHelp() {
  if (!state.helpOpen) return;
  const mx = 50, my = 30, mw = GW - 100, mh = GH - 60;

  // Dark backdrop
  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = '#0a0806';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();

  // Frame
  ctx.fillStyle = '#1a1610';
  ctx.fillRect(mx, my, mw, mh);
  ctx.strokeStyle = '#D4A03C';
  ctx.lineWidth = 2;
  ctx.strokeRect(mx, my, mw, mh);

  // Title
  ctx.save();
  ctx.fillStyle = '#D4A03C';
  ctx.font = '9px "Press Start 2P", monospace';
  ctx.textAlign = 'center';
  ctx.shadowColor = '#000'; ctx.shadowBlur = 4;
  ctx.fillText('ΒΟΗΘΕΙΑ', GW / 2, my + 16);
  ctx.restore();

  let y = my + 38;

  // General section
  ctx.save();
  ctx.font = '7px "Press Start 2P", monospace';
  ctx.textAlign = 'left';
  ctx.fillStyle = '#8a6e42';
  ctx.fillText('— Πώς παίζεται —', mx + 14, y);
  y += 16;
  ctx.fillStyle = '#c8b888';
  for (const line of HELP_GENERAL) {
    ctx.fillText(line, mx + 14, y);
    y += 13;
  }
  ctx.restore();

  y += 12;

  // Scene hint section
  const hint = HELP_HINTS[state.scene];
  if (hint) {
    ctx.save();
    ctx.font = '7px "Press Start 2P", monospace';
    ctx.textAlign = 'left';
    ctx.fillStyle = '#8a6e42';
    const sc = scenes[state.scene];
    ctx.fillText('— ' + (sc ? sc.label : 'Υπόδειξη') + ' —', mx + 14, y);
    y += 16;
    ctx.fillStyle = '#FFE8A0';
    // Word-wrap hint
    const words = hint.split(' ');
    let line = '';
    const maxW = mw - 28;
    for (const word of words) {
      const test = line + (line ? ' ' : '') + word;
      if (ctx.measureText(test).width > maxW && line) {
        ctx.fillText(line, mx + 14, y);
        y += 13;
        line = word;
      } else {
        line = test;
      }
    }
    if (line) ctx.fillText(line, mx + 14, y);
    ctx.restore();
  }

  // Dismiss hint
  ctx.save();
  ctx.fillStyle = '#5a4a2a';
  ctx.font = '6px "Press Start 2P", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('H ή ESC για κλείσιμο', GW / 2, my + mh - 8);
  ctx.restore();
}

// ════════════════════════════════════════════════════════════
// SHIP'S LOG OVERLAY — ΗΜΕΡΟΛΟΓΙΟ
// ════════════════════════════════════════════════════════════
function drawStatus() {
  if (!state.statusOpen) return;
  const mx = 28, my = 10, mw = GW - 56, mh = GH - 20;
  const pulse = Math.sin(state.tick * 0.06) * 0.5 + 0.5;

  // ── Full-screen dark backdrop ──
  ctx.save();
  ctx.globalAlpha = 0.94;
  ctx.fillStyle = '#060402';
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();

  // ── Parchment panel with gradient ──
  const bgGrad = ctx.createLinearGradient(mx, my, mx, my + mh);
  bgGrad.addColorStop(0, '#1c1608');
  bgGrad.addColorStop(0.3, '#18120a');
  bgGrad.addColorStop(0.7, '#14100a');
  bgGrad.addColorStop(1, '#100c06');
  ctx.fillStyle = bgGrad;
  ctx.fillRect(mx, my, mw, mh);

  // Subtle inner vignette
  ctx.save();
  ctx.globalAlpha = 0.25;
  const vig = ctx.createRadialGradient(GW / 2, GH / 2, mw * 0.15, GW / 2, GH / 2, mw * 0.65);
  vig.addColorStop(0, 'transparent');
  vig.addColorStop(1, '#000000');
  ctx.fillStyle = vig;
  ctx.fillRect(mx, my, mw, mh);
  ctx.restore();

  // ── Double ornamental border ──
  ctx.strokeStyle = '#C89830';
  ctx.lineWidth = 2;
  ctx.strokeRect(mx, my, mw, mh);
  ctx.strokeStyle = '#6a5428';
  ctx.lineWidth = 1;
  ctx.strokeRect(mx + 5, my + 5, mw - 10, mh - 10);

  // Corner ornaments (L-brackets)
  const cs = 14;
  ctx.strokeStyle = '#D4A03C';
  ctx.lineWidth = 2;
  [[mx + 1, my + 1, 1, 1], [mx + mw - 1, my + 1, -1, 1],
   [mx + 1, my + mh - 1, 1, -1], [mx + mw - 1, my + mh - 1, -1, -1]].forEach(([cx, cy, dx, dy]) => {
    ctx.beginPath();
    ctx.moveTo(cx, cy + cs * dy);
    ctx.lineTo(cx, cy);
    ctx.lineTo(cx + cs * dx, cy);
    ctx.stroke();
  });

  // ── Title: ΗΜΕΡΟΛΟΓΙΟ with anchor glyphs ──
  ctx.save();
  ctx.textAlign = 'center';
  ctx.shadowColor = '#D4A03C';
  ctx.shadowBlur = 8;
  ctx.fillStyle = '#E8C060';
  ctx.font = '11px "Press Start 2P", monospace';
  ctx.fillText('\u2693 ΗΜΕΡΟΛΟΓΙΟ \u2693', GW / 2, my + 24);
  ctx.shadowBlur = 0;
  ctx.restore();

  // Decorative rule under title with center diamond
  const ruleY = my + 30;
  ctx.save();
  ctx.strokeStyle = '#6a5428';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(mx + 20, ruleY);
  ctx.lineTo(GW / 2 - 70, ruleY);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(GW / 2 + 70, ruleY);
  ctx.lineTo(mx + mw - 20, ruleY);
  ctx.stroke();
  ctx.fillStyle = '#D4A03C';
  ctx.beginPath();
  ctx.moveTo(GW / 2, ruleY - 3);
  ctx.lineTo(GW / 2 + 3, ruleY);
  ctx.lineTo(GW / 2, ruleY + 3);
  ctx.lineTo(GW / 2 - 3, ruleY);
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  // ── Build quest steps ──
  const steps = [
    { done: state.flags.drawer_open,    text: 'Βρήκαμε το γράμμα του Βισβίκη στο συρτάρι' },
    { done: state.visited.has('port'),  text: 'Φτάσαμε στο λιμάνι — γνωρίσαμε τον Άκη και τον Στάθη' },
    { done: state.visited.has('museum'),text: 'Μάθαμε για τον χρυσό αιώνα στο Ναυτικό Μουσείο' },
    { done: state.visited.has('liotrivi'), text: 'Ο Άθος μας μίλησε για τη διαθήκη του Βισβίκη' },
    { done: state.flags.lantern_given,  text: 'Ο Γιάννης μας έδωσε φανάρι για το σπήλαιο' },
    { done: state.flags.vote_read,      text: 'Ο Αίας ανακάλυψε την ψηφοφορία: 9 προς 3' },
    { done: state.flags.jade_found,     text: 'Η Κλειώ βρήκε την πράσινη πέτρα νεφρίτη' },
    { done: state.flags.ghost_summoned, text: 'Ο Βισβίκης εμφανίστηκε — μας οδήγησε στην εκκλησία' },
    { done: state.flags.candle_lit,     text: 'Η Κλειώ άναψε κερί στον Άγιο Νικόλαο' },
    { done: !!state.inv.find(i => i.id === 'nautical_chart') || state.visited.has('boat'), text: 'Βρήκαμε τον ναυτικό χάρτη κάτω από την πλάκα «Λ.Β.»' },
    { done: state.visited.has('boat'),  text: 'Πλεύσαμε με την Ελπίδα στον Άγιο Γεώργιο' },
    { done: state.flags.chest_opened,   text: 'Ανοίξαμε το κιβώτιο του Βισβίκη' },
    { done: state.flags.letter_read,    text: 'Διαβάσαμε το τελευταίο γράμμα: «Κράτα την αλληλεγγύη»' },
    { done: state.flags.speech_done,    text: 'Ο Ντέμης μίλησε στο Γαλαξίδι — 104 υπογραφές ξανά' },
  ];

  const doneCount = steps.filter(s => s.done).length;
  const total = steps.length;
  const nextIdx = steps.findIndex(s => !s.done);

  // ── Progress bar (brass gauge with notches) ──
  ctx.save();
  const barX = mx + 20, barY = my + 38, barW = mw - 80, barH = 6;
  ctx.fillStyle = '#1a1408';
  ctx.fillRect(barX, barY, barW, barH);
  if (doneCount > 0) {
    const fillGrad = ctx.createLinearGradient(barX, barY, barX + barW * (doneCount / total), barY);
    fillGrad.addColorStop(0, '#8a6e20');
    fillGrad.addColorStop(0.5, '#D4A03C');
    fillGrad.addColorStop(1, '#E8C060');
    ctx.fillStyle = fillGrad;
    ctx.fillRect(barX, barY, barW * (doneCount / total), barH);
  }
  ctx.strokeStyle = '#5a4a2a';
  ctx.lineWidth = 1;
  ctx.strokeRect(barX, barY, barW, barH);
  for (let i = 1; i < total; i++) {
    ctx.fillStyle = '#3a3018';
    ctx.fillRect(barX + (barW / total) * i, barY, 1, barH);
  }
  ctx.font = '6px "Press Start 2P", monospace';
  ctx.fillStyle = '#E8C060';
  ctx.textAlign = 'left';
  ctx.fillText(doneCount + ' / ' + total, barX + barW + 8, barY + 6);
  ctx.restore();

  // ── Log entries ──
  let y = my + 56;
  const listFont = '6px "Press Start 2P", monospace';
  const maxW = mw - 70;
  ctx.save();
  ctx.font = listFont;
  ctx.textAlign = 'left';

  for (let i = 0; i < steps.length; i++) {
    const step = steps[i];
    const isNext = (i === nextIdx);
    const numStr = String(i + 1).padStart(2, ' ') + '.';

    // Next step highlight bar (pulsing)
    if (isNext) {
      ctx.save();
      ctx.globalAlpha = 0.12 + pulse * 0.08;
      ctx.fillStyle = '#D4A03C';
      const words = step.text.split(' ');
      let testLine = '', lines = 1;
      ctx.font = listFont;
      for (const word of words) {
        const test = testLine + (testLine ? ' ' : '') + word;
        if (ctx.measureText(test).width > maxW && testLine) { lines++; testLine = word; }
        else testLine = test;
      }
      ctx.fillRect(mx + 10, y - 8, mw - 20, lines * 11 + 4);
      ctx.restore();
      ctx.font = listFont;
    }

    // Entry number
    ctx.fillStyle = step.done ? '#8a7840' : isNext ? '#E8C060' : '#3a3020';
    ctx.fillText(numStr, mx + 14, y);

    // Status icon
    const iconX = mx + 38;
    if (step.done) {
      ctx.fillStyle = '#6aB050';
      ctx.fillText('\u2713', iconX, y);
    } else if (isNext) {
      ctx.fillStyle = 'rgba(232,192,96,' + (0.6 + pulse * 0.4).toFixed(2) + ')';
      ctx.fillText('\u25B6', iconX, y);
    } else {
      ctx.fillStyle = '#2a2418';
      ctx.fillText('\u00B7', iconX + 1, y);
    }

    // Entry text with word-wrap
    ctx.fillStyle = step.done ? '#b8a878' : isNext ? '#FFE8A0' : '#3a3020';
    const textX = mx + 50;
    const words = step.text.split(' ');
    let line = '';
    for (const word of words) {
      const test = line + (line ? ' ' : '') + word;
      if (ctx.measureText(test).width > maxW && line) {
        ctx.fillText(line, textX, y);
        y += 11;
        line = word;
      } else {
        line = test;
      }
    }
    if (line) { ctx.fillText(line, textX, y); y += 11; }

    // Dashed separator between done and next
    if (step.done && i + 1 === nextIdx) {
      ctx.strokeStyle = '#3a3018';
      ctx.lineWidth = 1;
      ctx.setLineDash([2, 3]);
      ctx.beginPath();
      ctx.moveTo(mx + 14, y);
      ctx.lineTo(mx + mw - 14, y);
      ctx.stroke();
      ctx.setLineDash([]);
      y += 5;
    } else {
      y += 2;
    }

    if (y > my + mh - 40) break;
  }
  ctx.restore();

  // ── Next objective box at bottom ──
  const nextStep = steps.find(s => !s.done);
  if (nextStep) {
    const boxY = my + mh - 36;
    ctx.save();
    ctx.strokeStyle = '#5a4a2a';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(mx + 15, boxY - 2);
    ctx.lineTo(mx + mw - 15, boxY - 2);
    ctx.stroke();
    ctx.font = '5px "Press Start 2P", monospace';
    ctx.fillStyle = '#8a7840';
    ctx.textAlign = 'left';
    ctx.fillText('ΕΠΟΜΕΝΟ ΒΗΜΑ:', mx + 18, boxY + 8);
    ctx.font = '6px "Press Start 2P", monospace';
    ctx.fillStyle = 'rgba(255,232,160,' + (0.7 + pulse * 0.3).toFixed(2) + ')';
    ctx.textAlign = 'left';
    const nextTxt = nextStep.text.length > 52 ? nextStep.text.substring(0, 52) + '...' : nextStep.text;
    ctx.fillText(nextTxt, mx + 18, boxY + 20);
    ctx.restore();
  }

  // ── Dismiss hint ──
  ctx.save();
  ctx.fillStyle = '#4a3a22';
  ctx.font = '5px "Press Start 2P", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('Q  \u00B7  ESC', GW / 2, my + mh - 6);
  ctx.restore();
}

// Scene-entry cutscene triggers (play on first visit)
const SCENE_CUTSCENES = {
  cave: 'cave_enter',
  boat: 'crossing',
  // treasure cutscene now triggered manually when player opens the chest
};

// ════════════════════════════════════════════════════════════
// SCENE MANAGEMENT
// ════════════════════════════════════════════════════════════

// (treasure visibility no longer needed — simplified scene has no hidden objects)

function startScene(id) {
  if (state.phase === 'playing') saveGame('auto');
  const sc = scenes[id];
  state.scene = id;
  state.hoverObj = null;
  bgCachedScene = null; // invalidate background cache

  // Reset sequence environment (prevent bleed between scenes)
  state.seq.env.darken = 0;
  state.seq.env.vignette = 0;
  state.seq.env.spectral = 0;
  state.seq.swirlParticles.length = 0;
  state.seq.stoneGlow.active = false;
  state.seq.jadeReveal.active = false;

  document.getElementById('ui-panel').classList.add('on');
  document.getElementById('action-line').classList.add('on');

  // Position characters — snap to walkLine ground level
  for (const [who, pos] of Object.entries(sc.charPos)) {
    chars[who].x = pos.x;
    // Use walkLine ground Y if available, otherwise fallback to charPos.y
    chars[who].y = sc.walkLine ? getGroundY(id, pos.x) : pos.y;
    chars[who].walking = false;
    chars[who].visible = true;
    chars[who].fadeIn = 0; // start fade-in
    chars[who].dir = 1;
  }

  initParticles();
  initAmbientSound();
  startSceneAmbience(id);
  changeSceneMusic(id);

  // ── Restore dynamic object state from saved flags ──
  if (id === 'church_interior' && state.flags.candle_lit) {
    const tile = sc.objects.find(o => o.id === 'floor_tile');
    if (tile) tile._hidden = false;
  }
  // (treasure visibility handled inline by verbs now)

  // Entry dialogue (first visit only) — with cutscene triggers
  if (!state.visited.has(id)) {
    state.visited.add(id);
    const csId = SCENE_CUTSCENES[id];
    if (csId && cutscenes[csId]) {
      // Play scene-entry cutscene, then show entry dialog on complete
      const origComplete = cutscenes[csId].onComplete;
      cutscenes[csId].onComplete = () => {
        if (origComplete) origComplete();
        state.phase = 'playing';
        document.getElementById('ui-panel').classList.add('on');
        document.getElementById('action-line').classList.add('on');
        if (sc.entry) setTimeout(() => showDlg(typeof sc.entry === 'function' ? sc.entry() : sc.entry), 600);
      };
      startCutscene(csId);
      return;
    }
    if (sc.entry) setTimeout(() => showDlg(typeof sc.entry === 'function' ? sc.entry() : sc.entry), 600);
  } else {
    // Clio auto-comment on revisit (after a short delay)
    scheduleClio(id);
  }
}

// ── Clio Auto-Comments — spontaneous observations on scene entry ──
const clioComments = {
  exterior: [
    'Μπαμπά, η μπουκαμβίλια μεγάλωσε από χθες!',
    'Ακούω τζιτζίκια. Πόσο αγαπώ αυτόν τον ήχο.',
    'Κοίτα πώς λάμπει η θάλασσα.',
    'Μυρίζει πεύκο και αλάτι.',
  ],
  terrace: [
    'Θα μπορούσα να μείνω εδώ για πάντα.',
    'Κοίτα τα βουνά, μπαμπά!',
    'Βλέπω ένα καράβι στο βάθος.',
    'Ο αέρας εδώ πάνω είναι μαγικός.',
  ],
  kitchen: [
    'Κοίτα πόσα πλοία! Σαν μουσείο!',
    'Μπαμπά, τι είναι αυτό το μηχάνημα;',
    'Φαντάζομαι τον καπετάνιο να κάθεται εδώ.',
    'Μυρίζει θάλασσα και παλιό ξύλο.',
  ],
  port: [
    'Τα καΐκια κουνιούνται σαν να χορεύουν.',
    'Μπαμπά, μπορώ να πατήσω πάνω στα σχοινιά;',
    'Μυρίζει ψάρι και θαλασσινό αλάτι.',
    'Φαντάζομαι πώς ήταν γεμάτο καράβια κάποτε.',
  ],
  museum: [
    'Σσσ... πρέπει να είμαστε ήσυχοι εδώ μέσα;',
    'Πόσα μυστικά κρύβουν αυτά τα πλοία...',
    'Κοίτα τη χάρτα! Πόσα ταξίδια!',
  ],
  liotrivi: [
    'Μυρίζει ελιά. Λατρεύω αυτή τη μυρωδιά.',
    'Φαντάσου πόσα χέρια γύρισαν αυτή την πέτρα.',
  ],
  cave: [
    'Είναι σκοτεινά εδώ μέσα...',
    'Μπαμπά, κρατήσε με σφιχτά.',
    'Ακούω σταγόνες. Σαν να χτυπάει ρολόι.',
  ],
  windmill: [
    'Βλέπω ολόκληρο το Γαλαξίδι από εδώ πάνω!',
    'Ο αέρας θέλει να με πάρει!',
  ],
  graveyard: [
    'Κάθε πέτρα κι ένα ταξίδι...',
    'Είναι ήσυχα εδώ. Σαν να ακούω τη θάλασσα να τους νανουρίζει.',
  ],
  church: [
    'Τι ωραία εκκλησία...',
    'Μπαμπά, να ρίξω νόμισμα στο σιντριβάνι;',
  ],
  church_interior: [
    'Μυρίζει λιβάνι...',
    'Κοίτα πόσα κεριά! Κάποιος τα ανάβει κάθε μέρα.',
    'Οι εικόνες φαίνονται να σε κοιτάνε...',
  ],
  boat: [
    'Κουνιέται! Κρατήσου καλά, Αίαντα!',
    'Βλέπω το Γαλαξίδι από εδώ. Είναι τόσο μικρό...',
  ],
  treasure: [
    'Νιώθω ότι είμαστε κοντά...',
  ],
  new_era: [
    'Κοίτα πόσος κόσμος ήρθε!',
    'Μπαμπά, τα κατάφερες. Τα καταφέραμε.',
  ],
};

// Track which comments Clio has already said per scene
const clioSaid = {};
let clioTimer = null;

function scheduleClio(sceneId) {
  if (clioTimer) { clearTimeout(clioTimer); clioTimer = null; }
  const pool = clioComments[sceneId];
  if (!pool || pool.length === 0) return;
  if (!clioSaid[sceneId]) clioSaid[sceneId] = new Set();
  // Find unsaid comments
  const unsaid = pool.filter((_, i) => !clioSaid[sceneId].has(i));
  if (unsaid.length === 0) return; // all said, stay quiet
  // Pick a random unsaid comment
  const idx = pool.indexOf(unsaid[Math.floor(Math.random() * unsaid.length)]);
  clioSaid[sceneId].add(idx);
  // Delay: 3-5 seconds after scene loads, only if no dialog active
  const delay = 3000 + Math.random() * 2000;
  clioTimer = setTimeout(() => {
    clioTimer = null;
    if (state.dlg.active || state.seq.active || state.scene !== sceneId) return;
    showDlg([{ s: 'ΚΛΕΙΩ', t: pool[idx] }]);
  }, delay);
}

function changeScene(id) {
  if (clioTimer) { clearTimeout(clioTimer); clioTimer = null; }
  playSFX('whoosh');
  // Iris wipe centered on Ntemis
  state.fade.active = true;
  state.fade.alpha = 0;
  state.fade.dir = 1; // iris close
  state.fade.mode = 'iris';
  state.fade.cx = chars.ntemis.x;
  state.fade.cy = chars.ntemis.y - 30; // chest height
  state.fade.cb = () => {
    startScene(id);
    state.fade.cx = chars.ntemis.x;
    state.fade.cy = chars.ntemis.y - 30;
    state.fade.dir = -1; // iris open
    state.fade.cb = () => { state.fade.active = false; state.fade.mode = null; };
  };
}

function checkEnd() {}

// ════════════════════════════════════════════════════════════
// RENDER — Main drawing function
// ════════════════════════════════════════════════════════════
function render() {
  ctx.clearRect(0, 0, GW, GH);

  // Canvas-rendered title screen
  if (state.phase === 'title') {
    drawTitleScreen(state.tick);
    drawCustomCursor();
    return;
  }

  if (state.phase === 'crawl') {
    drawCrawl(state.tick);
    drawCustomCursor();
    return;
  }

  if (state.phase === 'cutscene') {
    renderCutscene();
    drawCustomCursor();
    return;
  }

  if (state.phase !== 'playing') return;
  if (!state.scene) return;

  const sc = scenes[state.scene];

  // Background + ambient overlay (cached — only redraws on scene change)
  if (bgCachedScene !== state.scene) {
    bgCtx.clearRect(0, 0, GW, GH);
    const bgImg = images[sc.bg];
    if (bgImg) {
      bgCtx.imageSmoothingEnabled = true;
      bgCtx.imageSmoothingQuality = 'high';
      // Smart cover-fit: crop source image to match canvas aspect ratio
      const imgW = bgImg.naturalWidth;
      const imgH = bgImg.naturalHeight;
      const canvasRatio = GW / GH; // 1.6
      const imgRatio = imgW / imgH;
      let sx = 0, sy = 0, sw = imgW, sh = imgH;
      if (imgRatio < canvasRatio) {
        sh = imgW / canvasRatio;
        sy = (imgH - sh) / 2;
      } else if (imgRatio > canvasRatio) {
        sw = imgH * canvasRatio;
        sx = (imgW - sw) / 2;
      }
      bgCtx.drawImage(bgImg, sx, sy, sw, sh, 0, 0, GW, GH);
      bgCtx.imageSmoothingEnabled = false;
    } else {
      bgCtx.fillStyle = '#1a1510';
      bgCtx.fillRect(0, 0, GW, GH);
    }
    const grad = bgCtx.createLinearGradient(0, 0, 0, GH);
    grad.addColorStop(0, 'rgba(212,160,60,0.03)');
    grad.addColorStop(0.3, 'rgba(0,0,0,0)');
    grad.addColorStop(0.7, 'rgba(0,0,0,0)');
    grad.addColorStop(1, 'rgba(0,0,0,0.15)');
    bgCtx.fillStyle = grad;
    bgCtx.fillRect(0, 0, GW, GH);
    bgCachedScene = state.scene;
  }
  ctx.drawImage(bgBuffer, 0, 0);

  // Scene-specific ambience (behind characters)
  drawSceneAmbience(state.tick);

  // Dust particles
  drawParticles();

  // Hotspot shimmer hints — subtle sparkles on all interactive objects
  if (sc.objects) {
    const t = state.tick;
    for (let i = 0; i < sc.objects.length; i++) {
      const obj = sc.objects[i];
      if (obj._hidden) continue;
      if (obj === state.hoverObj) continue;
      const seed = (obj.x * 7 + obj.y * 13 + i * 31);
      const sparkleT = (t + seed) * 0.03;
      const alpha = Math.max(0, Math.sin(sparkleT) * 0.6 - 0.2);
      if (alpha > 0) {
        ctx.save();
        ctx.globalAlpha = alpha * 0.5;
        const sx = obj.x + (seed * 17 % obj.w);
        const sy = obj.y + (seed * 23 % obj.h);
        ctx.fillStyle = '#FFE8A0';
        ctx.beginPath();
        ctx.moveTo(sx, sy - 2); ctx.lineTo(sx + 0.7, sy);
        ctx.lineTo(sx, sy + 2); ctx.lineTo(sx - 0.7, sy);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }
  }

  // Hotspot highlight on hover — prominent pulsing glow
  if (state.hoverObj && state.hoverObj.w && !state.hoverObj._hidden) {
    const obj = state.hoverObj;
    const pulse = 0.5 + Math.sin(state.tick * 0.08) * 0.3;
    ctx.save();
    // Soft fill glow behind the border
    ctx.fillStyle = `rgba(255,220,120,${pulse * 0.12})`;
    ctx.shadowColor = 'rgba(255,220,120,0.8)';
    ctx.shadowBlur = 14;
    const r = 4, hx = obj.x - 4, hy = obj.y - 4, hw = obj.w + 8, hh = obj.h + 8;
    ctx.beginPath();
    ctx.moveTo(hx + r, hy);
    ctx.lineTo(hx + hw - r, hy); ctx.arcTo(hx + hw, hy, hx + hw, hy + r, r);
    ctx.lineTo(hx + hw, hy + hh - r); ctx.arcTo(hx + hw, hy + hh, hx + hw - r, hy + hh, r);
    ctx.lineTo(hx + r, hy + hh); ctx.arcTo(hx, hy + hh, hx, hy + hh - r, r);
    ctx.lineTo(hx, hy + r); ctx.arcTo(hx, hy, hx + r, hy, r);
    ctx.closePath();
    ctx.fill();
    // Bright border
    ctx.strokeStyle = `rgba(255,220,120,${pulse})`;
    ctx.lineWidth = 2.5;
    ctx.stroke();
    ctx.restore();
  }

  // Exit zone highlights with pulsing arrow
  if (sc.exits) {
    const arrowPulse = 0.6 + Math.sin(state.tick * 0.06) * 0.4;
    const arrowBob = Math.sin(state.tick * 0.08) * 2;
    for (const exit of sc.exits) {
      const isHover = (exit.side === 'left' && state.mouseGX < 35) ||
                      (exit.side === 'right' && state.mouseGX > GW - 35);
      if (isHover) {
        ctx.save();
        const exGrad = exit.side === 'left'
          ? ctx.createLinearGradient(0, 0, 40, 0)
          : ctx.createLinearGradient(GW, 0, GW - 40, 0);
        exGrad.addColorStop(0, `rgba(212,160,60,${0.15 + arrowPulse * 0.1})`);
        exGrad.addColorStop(1, 'rgba(212,160,60,0)');
        ctx.fillStyle = exGrad;
        if (exit.side === 'left') ctx.fillRect(0, 0, 40, GH);
        else ctx.fillRect(GW - 40, 0, 40, GH);
        // Pulsing bobbing arrow
        ctx.globalAlpha = arrowPulse;
        ctx.fillStyle = '#FFE8A0';
        ctx.font = '20px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const ax = exit.side === 'left' ? 16 + arrowBob : GW - 16 - arrowBob;
        ctx.fillText(exit.side === 'left' ? '◀' : '▶', ax, GH / 2);
        ctx.restore();
      }
    }
  }

  // Collect all visible characters + NPCs and sort by Y for proper depth
  const drawOrder = [];
  for (const who of ['ntemis', 'ajax', 'clio']) {
    if (chars[who].visible) drawOrder.push({ type: 'char', id: who, y: chars[who].y });
  }
  for (const npcId of Object.keys(npcChars)) {
    const npc = npcChars[npcId];
    const isMaterializing = npcId === 'ghost' && state.seq.active && state.seq.ghostMat.active;
    if (npc.scene === state.scene && (npc.visible || isMaterializing))
      drawOrder.push({ type: 'npc', id: npcId, y: npc.y });
  }
  drawOrder.sort((a, b) => a.y - b.y);
  for (const entry of drawOrder) {
    if (entry.type === 'char') drawCharacter(entry.id, state.tick);
    else drawNPC(entry.id, state.tick);
  }
  drawGhostArm();

  // Scene label
  ctx.save();
  ctx.fillStyle = '#D4A03C';
  ctx.font = '8px "Press Start 2P", monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.shadowColor = '#000';
  ctx.shadowBlur = 4;
  ctx.shadowOffsetX = 2;
  ctx.shadowOffsetY = 2;
  ctx.fillText(sc.label, GW / 2, 8);
  ctx.restore();

  // Top-right toolbar: Help | Status | Map | Music — SCUMM-style prominent buttons
  ctx.save();
  const tbY = 4, tbH = 28, tbW = 32, tbGap = 3;
  const tbTotalW = tbW * 4 + tbGap * 3;
  const tbX0 = GW - tbTotalW - 6;
  const tbIcons = [
    { label: '?', tip: 'HELP', x: tbX0, key: 'help' },
    { label: 'Q', tip: 'QUEST', x: tbX0 + tbW + tbGap, key: 'status' },
    { label: 'M', tip: 'MAP', x: tbX0 + (tbW + tbGap) * 2, key: 'map' },
    { label: '\u266A', tip: 'MUSIC', x: tbX0 + (tbW + tbGap) * 3, key: 'music' },
  ];

  // Toolbar backing panel
  ctx.globalAlpha = 0.7;
  ctx.fillStyle = '#0a0820';
  ctx.beginPath();
  ctx.roundRect(tbX0 - 5, tbY - 2, tbTotalW + 10, tbH + 4, 5);
  ctx.fill();
  ctx.strokeStyle = '#8B6914';
  ctx.lineWidth = 1;
  ctx.globalAlpha = 0.5;
  ctx.stroke();

  for (const btn of tbIcons) {
    const active = (btn.key === 'map' && state.mapOpen) || (btn.key === 'help' && state.helpOpen) || (btn.key === 'status' && state.statusOpen) || (btn.key === 'music' && state.musicOn);

    // Outer shadow glow for active buttons
    if (active) {
      ctx.globalAlpha = 0.3;
      ctx.shadowColor = '#D4A03C';
      ctx.shadowBlur = 8;
    } else {
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
    }

    // Button background — wood/leather feel
    const bgGrad = ctx.createLinearGradient(btn.x, tbY, btn.x, tbY + tbH);
    bgGrad.addColorStop(0, active ? '#3a2a10' : '#1a1428');
    bgGrad.addColorStop(0.5, active ? '#4a3518' : '#22193a');
    bgGrad.addColorStop(1, active ? '#2a1a08' : '#14102a');
    ctx.globalAlpha = active ? 0.95 : 0.8;
    ctx.fillStyle = bgGrad;
    ctx.beginPath();
    ctx.roundRect(btn.x, tbY, tbW, tbH, 4);
    ctx.fill();
    ctx.shadowBlur = 0;

    // Gold border — double line for active
    ctx.strokeStyle = active ? '#F0C040' : '#D4A03C';
    ctx.lineWidth = active ? 2 : 1.5;
    ctx.globalAlpha = active ? 1.0 : 0.7;
    ctx.stroke();

    // Inner highlight (top edge)
    ctx.beginPath();
    ctx.moveTo(btn.x + 5, tbY + 1.5);
    ctx.lineTo(btn.x + tbW - 5, tbY + 1.5);
    ctx.strokeStyle = active ? 'rgba(240,192,64,0.5)' : 'rgba(212,160,60,0.25)';
    ctx.lineWidth = 1;
    ctx.globalAlpha = 1;
    ctx.stroke();

    // Icon/Label
    ctx.globalAlpha = active ? 1.0 : 0.85;
    ctx.fillStyle = active ? '#F5D060' : '#D4A03C';
    ctx.shadowColor = '#000';
    ctx.shadowBlur = 2;
    ctx.shadowOffsetX = 1;
    ctx.shadowOffsetY = 1;
    ctx.font = btn.key === 'music' ? 'bold 16px sans-serif' : 'bold 11px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(btn.label, btn.x + tbW / 2, tbY + tbH / 2);
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
  }
  ctx.restore();

  // ── Sequence overlays (between scene and dialogue) ──
  if (state.seq.env.darken > 0) {
    ctx.save();
    ctx.globalAlpha = state.seq.env.darken;
    ctx.fillStyle = '#0a0820'; // deep blue-black
    ctx.fillRect(0, 0, GW, GH);
    ctx.restore();
  }
  if (state.seq.env.vignette > 0) {
    ctx.save();
    ctx.globalAlpha = state.seq.env.vignette;
    const vig = ctx.createRadialGradient(GW / 2, GH / 2, GW * 0.25, GW / 2, GH / 2, GW * 0.6);
    vig.addColorStop(0, 'rgba(0,0,0,0)');
    vig.addColorStop(1, 'rgba(5,5,20,0.8)');
    ctx.fillStyle = vig;
    ctx.fillRect(0, 0, GW, GH);
    ctx.restore();
  }
  drawSwirlParticles();
  drawStoneGlow();
  drawJadeReveal();

  // Dialogue overlay
  drawDialogue();

  // ── CRT scanline overlay + vignette (subtle retro post-processing) ──
  ctx.save();
  ctx.globalAlpha = 0.03;
  ctx.fillStyle = '#000';
  for (let y = 0; y < GH; y += 2) {
    ctx.fillRect(0, y, GW, 1);
  }
  ctx.restore();
  // Subtle gameplay vignette
  ctx.save();
  const vg = ctx.createRadialGradient(GW/2, GH/2, GH*0.35, GW/2, GH/2, GH*0.75);
  vg.addColorStop(0, 'rgba(0,0,0,0)');
  vg.addColorStop(1, 'rgba(0,0,0,0.12)');
  ctx.fillStyle = vg;
  ctx.fillRect(0, 0, GW, GH);
  ctx.restore();

  // Save indicator
  if (state.saveIndicator && performance.now() < state.saveIndicator.until) {
    ctx.save();
    ctx.globalAlpha = 0.8;
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(GW - 160, 8, 152, 24);
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#D4A03C';
    ctx.font = '8px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText(state.saveIndicator.text, GW - 84, 24);
    ctx.restore();
  }

  // Map & Help overlays
  drawMap();
  drawHelp();
  drawStatus();

  // Transition overlay — iris wipe or flat fade
  if (state.fade.active && state.fade.alpha > 0) {
    ctx.save();
    if (state.fade.mode === 'iris') {
      // Iris wipe: circle shrinks/grows centered on character
      const maxR = Math.sqrt(GW * GW + GH * GH) * 0.6;
      const radius = maxR * (1 - state.fade.alpha);
      const cx = state.fade.cx || GW / 2;
      const cy = state.fade.cy || GH / 2;
      // Draw black everywhere except the circle
      ctx.beginPath();
      ctx.rect(0, 0, GW, GH);
      ctx.arc(cx, cy, Math.max(0, radius), 0, Math.PI * 2, true); // counter-clockwise = hole
      ctx.fillStyle = '#000';
      ctx.fill('evenodd');
    } else {
      ctx.globalAlpha = state.fade.alpha;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, GW, GH);
    }
    ctx.restore();
  }

  // ── Debug hotspot overlay ──
  if (state.debugHotspots && state.scene) {
    drawDebugHotspots();
  }

  // ── Custom canvas cursor — always on top ──
  drawCustomCursor();
}

// ════════════════════════════════════════════════════════════
// DEBUG HOTSPOT OVERLAY — press D to toggle
// ════════════════════════════════════════════════════════════
function drawDebugHotspots() {
  const sc = scenes[state.scene];
  if (!sc || !sc.objects) return;
  ctx.save();
  const colors = ['#ff000080','#00ff0080','#0088ff80','#ff880080','#ff00ff80','#00ffff80','#ffff0080'];
  for (let i = 0; i < sc.objects.length; i++) {
    const obj = sc.objects[i];
    if (obj._hidden) continue;
    const c = colors[i % colors.length];
    ctx.fillStyle = c;
    ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
    ctx.strokeStyle = c.replace('80','ff');
    ctx.lineWidth = 1;
    ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
    ctx.fillStyle = '#fff';
    ctx.font = '8px monospace';
    ctx.fillText(obj.id, obj.x + 2, obj.y + 9);
  }
  // Mouse coordinates
  const mx = Math.round(state.mouseGX || 0), my = Math.round(state.mouseGY || 0);
  ctx.fillStyle = '#000';
  ctx.fillRect(GW - 80, 2, 78, 14);
  ctx.fillStyle = '#0f0';
  ctx.font = '10px monospace';
  ctx.fillText(`${mx}, ${my}`, GW - 76, 13);
  ctx.restore();
}

// ════════════════════════════════════════════════════════════
// CUSTOM CURSOR — Monkey Island SCUMM-style pixel cursor
// ════════════════════════════════════════════════════════════
// Helper: draw a crisp pixel-art shape from a bitmap pattern
function drawPixelCursor(cx, cy, pattern, fg, outline) {
  const h = pattern.length, w = pattern[0].length;
  const ox = -Math.floor(w / 2), oy = -Math.floor(h / 2);
  // Pass 1: black outline (draw fg pixels expanded by 1 in all directions)
  if (outline) {
    ctx.fillStyle = outline;
    for (let r = 0; r < h; r++) {
      for (let c = 0; c < w; c++) {
        if (pattern[r][c]) {
          ctx.fillRect(cx + ox + c - 1, cy + oy + r - 1, 3, 3);
        }
      }
    }
  }
  // Pass 2: foreground pixels
  ctx.fillStyle = fg;
  for (let r = 0; r < h; r++) {
    for (let c = 0; c < w; c++) {
      if (pattern[r][c]) {
        ctx.fillRect(cx + ox + c, cy + oy + r, 1, 1);
      }
    }
  }
}

// Cursor bitmaps — Monkey Island 2 exact pixel patterns
// MI2 crosshair: thin + shape, 1px arms, 5px each side, 1px gap from center
const CURSOR_CROSS = [
  [0,0,0,0,0,0,1,0,0,0,0,0,0],
  [0,0,0,0,0,0,1,0,0,0,0,0,0],
  [0,0,0,0,0,0,1,0,0,0,0,0,0],
  [0,0,0,0,0,0,1,0,0,0,0,0,0],
  [0,0,0,0,0,0,1,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0],
  [1,1,1,1,1,0,0,0,1,1,1,1,1],
  [0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,1,0,0,0,0,0,0],
  [0,0,0,0,0,0,1,0,0,0,0,0,0],
  [0,0,0,0,0,0,1,0,0,0,0,0,0],
  [0,0,0,0,0,0,1,0,0,0,0,0,0],
  [0,0,0,0,0,0,1,0,0,0,0,0,0],
];

// MI2 interactive cursor: same cross but with small diamond tips
const CURSOR_INTERACT = [
  [0,0,0,0,0,0,1,0,0,0,0,0,0],
  [0,0,0,0,0,0,1,0,0,0,0,0,0],
  [0,0,0,0,0,0,1,0,0,0,0,0,0],
  [0,0,0,0,0,0,1,0,0,0,0,0,0],
  [0,0,0,0,0,1,1,1,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0],
  [1,1,1,1,1,0,0,0,1,1,1,1,1],
  [0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,1,1,1,0,0,0,0,0],
  [0,0,0,0,0,0,1,0,0,0,0,0,0],
  [0,0,0,0,0,0,1,0,0,0,0,0,0],
  [0,0,0,0,0,0,1,0,0,0,0,0,0],
  [0,0,0,0,0,0,1,0,0,0,0,0,0],
];

// MI2 exit arrows — chunky pixel arrows
const CURSOR_ARROW_L = [
  [0,0,0,0,1,0,0,0,0,0,0],
  [0,0,0,1,1,0,0,0,0,0,0],
  [0,0,1,1,1,0,0,0,0,0,0],
  [0,1,1,1,1,1,1,1,1,1,1],
  [1,1,1,1,1,1,1,1,1,1,1],
  [0,1,1,1,1,1,1,1,1,1,1],
  [0,0,1,1,1,0,0,0,0,0,0],
  [0,0,0,1,1,0,0,0,0,0,0],
  [0,0,0,0,1,0,0,0,0,0,0],
];

const CURSOR_ARROW_R = [
  [0,0,0,0,0,0,1,0,0,0,0],
  [0,0,0,0,0,0,1,1,0,0,0],
  [0,0,0,0,0,0,1,1,1,0,0],
  [1,1,1,1,1,1,1,1,1,1,0],
  [1,1,1,1,1,1,1,1,1,1,1],
  [1,1,1,1,1,1,1,1,1,1,0],
  [0,0,0,0,0,0,1,1,1,0,0],
  [0,0,0,0,0,0,1,1,0,0,0],
  [0,0,0,0,0,0,1,0,0,0,0],
];

function drawCustomCursor() {
  const mx = state.mouseGX, my = state.mouseGY;
  if (mx <= 0 && my <= 0) return;
  ctx.save();
  ctx.imageSmoothingEnabled = false;
  const mode = state.cursorMode || 'default';
  const isHot = mode === 'pointer' || mode === 'zoom-in' || mode === 'help' || mode === 'grab';
  const isExit = mode === 'w-resize' || mode === 'e-resize';

  if (isExit) {
    // Exit: MI2-style pixel arrow
    const pattern = mode === 'w-resize' ? CURSOR_ARROW_L : CURSOR_ARROW_R;
    drawPixelCursor(mx, my, pattern, '#39d52e', '#000');
  } else if (isHot) {
    // Interactive: MI2 cross with widened tips
    drawPixelCursor(mx, my, CURSOR_INTERACT, '#fff', '#000');
  } else {
    // Default: MI2 exact crosshair — white thin cross, black outline
    drawPixelCursor(mx, my, CURSOR_CROSS, '#fff', '#000');
  }
  ctx.restore();
}

// ════════════════════════════════════════════════════════════
// UPDATE — Main logic update
// ════════════════════════════════════════════════════════════
function update(dt) {
  state.tick++;

  // Title screen — start music on first interaction (handled by click)
  if (state.phase === 'title') return;
  if (state.phase === 'crawl') {
    if (!state.crawlFading) {
      state.crawlScroll += CRAWL_SPEED * dt;
      const lastLinePos = (CRAWL_LINES.length - 1) * CRAWL_LINE_SPACING;
      if (state.crawlScroll > lastLinePos + CRAWL_VISIBLE_DEPTH) {
        endCrawl();
      }
    }
    return;
  }
  if (state.phase === 'cutscene') { updateCutscene(dt); return; }
  if (state.phase !== 'playing') return;

  // (treasure visibility handled inline by verbs now)

  // Walking
  updateWalking(dt);

  // Character fade-in
  for (const who of ['ntemis','ajax','clio']) {
    if (chars[who].fadeIn < 1) {
      const delays = { ntemis: 0.1, ajax: 0.3, clio: 0.5 };
      if (state.tick > delays[who] * 60) {
        chars[who].fadeIn = Math.min(1, chars[who].fadeIn + dt * 1.5);
      }
    }
  }

  // Dialogue typewriter
  updateDlg(dt);

  // Scripted sequences
  updateSequence(dt);

  // Particles
  updateParticles();

  // Scene ambience (seagulls, petals, bells, sounds)
  updateSceneAmbience(dt);

  // Fade/iris transition
  if (state.fade.active) {
    const speed = state.fade.mode === 'iris' ? 1.5 : 2.0;
    state.fade.alpha += state.fade.dir * dt * speed;
    if (state.fade.dir > 0 && state.fade.alpha >= 1) {
      state.fade.alpha = 1;
      if (state.fade.cb) { const cb = state.fade.cb; state.fade.cb = null; cb(); }
    }
    if (state.fade.dir < 0 && state.fade.alpha <= 0) {
      state.fade.alpha = 0;
      if (state.fade.cb) { const cb = state.fade.cb; state.fade.cb = null; cb(); }
    }
  }
}

// ════════════════════════════════════════════════════════════
// GAME LOOP
// ════════════════════════════════════════════════════════════
let lastTime = 0;

function gameLoop(timestamp) {
  const dt = lastTime ? Math.min((timestamp - lastTime) / 1000, 0.05) : 0.016;
  lastTime = timestamp;

  // Resize canvas to fill available space
  const rect = CVS.getBoundingClientRect();
  // Keep internal resolution fixed, CSS handles scaling

  update(dt);
  render();
  requestAnimationFrame(gameLoop);
}

// ════════════════════════════════════════════════════════════
// INPUT HANDLING
// ════════════════════════════════════════════════════════════
CVS.addEventListener('mousemove', (e) => {
  const g = screenToGame(e.clientX, e.clientY);
  state.mouseGX = g.x;
  state.mouseGY = g.y;

  if (state.phase === 'title' || state.phase === 'crawl') {
    state.cursorMode ='pointer';
    return;
  }

  if (state.phase === 'cutscene' && state.cutscene.active) {
    const skipW = 80, skipH = 18, skipX = GW - skipW - 8, skipY = 8;
    const over = g.x >= skipX && g.x <= skipX + skipW && g.y >= skipY && g.y <= skipY + skipH;
    state.cutscene.skipHover = over;
    state.cursorMode =over ? 'pointer' : 'default';
    return;
  }

  if (state.phase !== 'playing' || state.dlg.active || state.seq.active) {
    state.cursorMode =(state.dlg.active || state.seq.active) ? 'pointer' : 'default';
    state.hoverObj = null;
    updateActionLine();
    return;
  }

  // Map hover
  if (state.mapOpen) {
    state.mapHover = getMapHoverLocation(g.x, g.y);
    if (state.mapHover !== null) {
      const loc = MAP_LOCATIONS[state.mapHover];
      const isCurrent = loc.sceneIds.includes(state.scene);
      state.cursorMode = !isCurrent ? 'pointer' : 'default';
    } else {
      state.cursorMode ='default';
    }
    return;
  }

  // Help/Status overlay — block hover
  if (state.helpOpen || state.statusOpen) { state.cursorMode ='default'; return; }

  // Toolbar button hover — pointer cursor
  {
    const _tbW = 32, _tbGap = 3, _tbY = 4, _tbH = 28;
    const _tbTotalW = _tbW * 4 + _tbGap * 3;
    const _tbX0 = GW - _tbTotalW - 6;
    if (g.y >= _tbY && g.y <= _tbY + _tbH && g.x >= _tbX0 && g.x <= _tbX0 + _tbTotalW) {
      state.cursorMode = 'pointer';
      state.hoverObj = null;
      updateActionLine();
      return;
    }
  }

  // Check hotspots
  const obj = hitTestObj(g.x, g.y);
  state.hoverObj = obj;

  // Check exits for cursor change
  const exit = hitTestExit(g.x, g.y);
  if (exit) {
    state.cursorMode =exit.side === 'left' ? 'w-resize' : 'e-resize';
    state.hoverObj = { label: exit.label }; // fake obj for action line
  } else if (obj) {
    // Verb-aware cursor
    const verbCursors = { look: 'zoom-in', talk: 'help', open: 'grab', use: 'pointer' };
    state.cursorMode =verbCursors[state.verb] || 'pointer';
  } else {
    state.cursorMode =g.y > 200 ? 'crosshair' : 'default';
  }
  updateActionLine();
});

CVS.addEventListener('click', (e) => {
  const g = screenToGame(e.clientX, e.clientY);

  // Cutscene: skip button or speed up dialogue
  if (state.phase === 'cutscene' && state.cutscene.active) {
    const skipW = 80, skipH = 18, skipX = GW - skipW - 8, skipY = 8;
    if (g.x >= skipX && g.x <= skipX + skipW && g.y >= skipY && g.y <= skipY + skipH) {
      skipCutscene();
      return;
    }
    if (state.cutscene.dlgCharIdx < state.cutscene.dlgText.length) {
      state.cutscene.dlgDisplayed = state.cutscene.dlgText;
      state.cutscene.dlgCharIdx = state.cutscene.dlgText.length;
    }
    return;
  }

  // Title clicks handled by dedicated handler
  if (state.phase !== 'playing') return;

  // Map click — teleport
  if (state.mapOpen) {
    if (state.mapHover !== null) {
      const loc = MAP_LOCATIONS[state.mapHover];
      const isCurrent = loc.sceneIds.includes(state.scene);
      if (!isCurrent) {
        state.mapOpen = false;
        state.mapHover = null;
        changeScene(loc.sceneIds[0]);
      }
    }
    return;
  }

  // Help/Status click — dismiss
  if (state.helpOpen) { state.helpOpen = false; return; }
  if (state.statusOpen) { state.statusOpen = false; return; }

  // Dialogue advance
  if (state.dlg.active) { advanceDlg(); return; }

  // Block all interaction during sequences (dialog already handled above)
  if (state.seq.active) return;

  // Top-right toolbar clicks — must match render positions (tbY=4, tbH=28, tbW=32, tbGap=3)
  const tbW = 32, tbGap = 3, tbY = 4, tbH = 28;
  const tbTotalW = tbW * 4 + tbGap * 3; // 137
  const tbX0 = GW - tbTotalW - 6;       // 497
  if (g.y >= tbY && g.y <= tbY + tbH) {
    if (g.x >= tbX0 && g.x < tbX0 + tbW) { state.helpOpen = !state.helpOpen; state.mapOpen = false; state.statusOpen = false; return; }
    if (g.x >= tbX0 + tbW + tbGap && g.x < tbX0 + tbW * 2 + tbGap) { state.statusOpen = !state.statusOpen; state.helpOpen = false; state.mapOpen = false; return; }
    if (g.x >= tbX0 + (tbW + tbGap) * 2 && g.x < tbX0 + (tbW + tbGap) * 2 + tbW) { state.mapOpen = !state.mapOpen; state.helpOpen = false; state.statusOpen = false; state.mapHover = null; return; }
    if (g.x >= tbX0 + (tbW + tbGap) * 3 && g.x < tbX0 + (tbW + tbGap) * 3 + tbW) { toggleMusic(); return; }
  }

  // Check exit zones
  const exit = hitTestExit(g.x, g.y);
  if (exit) {
    // Quest gates
    if (exit.target === 'cave' && !state.inv.find(i => i.id === 'lantern')) {
      showDlg([{s:'ΝΤΕΜΗΣ',t:'Είναι σκοτεινά εκεί μέσα. Χρειαζόμαστε φανάρι.'},{s:'ΚΛΕΙΩ',t:'Ο Γιάννης στον μύλο ίσως έχει κάτι.'}]);
      return;
    }
    if (exit.target === 'treasure' && !state.inv.find(i => i.id === 'nautical_chart')) {
      showDlg([{s:'ΝΤΕΜΗΣ',t:'Χρειαζόμαστε τον χάρτη του Βισβίκη για να βρούμε το νησί.'}]);
      return;
    }
    if (exit.target === 'new_era' && !state.flags.letter_read) {
      showDlg([{s:'ΝΤΕΜΗΣ',t:'Πρέπει να δούμε τι μας άφησε ο Βισβίκης πρώτα.'}]);
      return;
    }
    // Sailing back cutscene: boat → port
    if (state.scene === 'boat' && exit.target === 'port') {
      startCutscene('sail_back');
      return;
    }
    changeScene(exit.target);
    return;
  }

  // Check hotspots
  const obj = hitTestObj(g.x, g.y);
  if (obj) { objClick(obj); return; }

  // Click ground — walk Ntemis (walkLine defines valid ground area)
  const sc = scenes[state.scene];
  if (sc && sc.walkLine && g.y > 200) {
    startWalk('ntemis', g.x);
    familyFollow(g.x);
  } else if (g.y > 200) {
    startWalk('ntemis', g.x);
    familyFollow(g.x);
  }
});

// Right-click — SCUMM-style default verb (Look for most, Talk for NPCs, Open for doors)
CVS.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  if (state.phase !== 'playing' || state.dlg.active || state.seq.active) return;
  const g = screenToGame(e.clientX, e.clientY);
  const obj = hitTestObj(g.x, g.y);
  if (!obj) return;
  // Pick the best default verb for this object
  const prevVerb = state.verb;
  if (obj.verbs.talk && (obj.id.includes('npc') || obj.id.includes('akis') || obj.id.includes('stathis') || obj.id.includes('curator') || obj.id.includes('athos') || obj.id.includes('giannis') || obj.id.includes('papas') || obj.id.includes('chryso') || obj.id.includes('ghost'))) {
    state.verb = 'talk';
  } else if (obj.verbs.open && (obj.id.includes('door') || obj.id.includes('chest') || obj.id.includes('satchel') || obj.id.includes('barrel'))) {
    state.verb = 'open';
  } else {
    state.verb = 'look';
  }
  objClick(obj);
  state.verb = prevVerb;
});

// Keyboard
document.addEventListener('keydown', e => {
  // Escape: close overlays first, then skip crawl/cutscene
  if (e.key === 'Escape') {
    if (state.phase === 'crawl') { endCrawl(); return; }
    if (state.mapOpen) { state.mapOpen = false; state.mapHover = null; return; }
    if (state.helpOpen) { state.helpOpen = false; return; }
    if (state.statusOpen) { state.statusOpen = false; return; }
    if (state.phase === 'cutscene') { skipCutscene(); return; }
    return;
  }
  if (e.key === ' ' || e.key === 'Enter') {
    e.preventDefault();
    if (state.dlg.active) advanceDlg();
  }
  // Use e.code for letter keys — works regardless of keyboard layout (Greek/English)
  const code = e.code;
  // Map toggle
  if (code === 'KeyM' && state.phase === 'playing' && !state.dlg.active && !state.seq.active) {
    state.mapOpen = !state.mapOpen; state.helpOpen = false; state.statusOpen = false; state.mapHover = null; return;
  }
  // Help toggle
  if (code === 'KeyH' && state.phase === 'playing' && !state.dlg.active && !state.seq.active) {
    state.helpOpen = !state.helpOpen; state.mapOpen = false; state.statusOpen = false; return;
  }
  // Debug hotspot overlay toggle
  if (code === 'KeyD' && state.phase === 'playing') {
    state.debugHotspots = !state.debugHotspots; return;
  }
  // Quest status toggle
  if (code === 'KeyQ' && state.phase === 'playing' && !state.dlg.active && !state.seq.active) {
    state.statusOpen = !state.statusOpen; state.helpOpen = false; state.mapOpen = false; return;
  }
  const vk = {'1':'look','2':'talk','3':'open','4':'use'};
  if (vk[e.key] && state.phase === 'playing' && !state.mapOpen && !state.helpOpen && !state.statusOpen) setVerb(vk[e.key]);
  if (code === 'KeyS' && state.phase === 'playing' && !state.mapOpen && !state.helpOpen && !state.statusOpen) { saveGame('manual'); }
});

// ════════════════════════════════════════════════════════════
// MUSIC
// ════════════════════════════════════════════════════════════
const bgm = document.getElementById('bgm');
bgm.volume = 0.25;
bgm.onerror = () => console.error('Failed to load music:', bgm.src);

// Per-scene music map
const sceneMusic = {
  exterior: 'music/arrival-at-galaxidi-scene-1-1.mp3',
  terrace:  'music/arrival-at-galaxidi-scene-1-1.mp3',
  kitchen:  'music/the-grandfather-s-house-1.mp3',
  port:     'music/the-harbor-at-dusk-1.mp3',
  museum:   'music/the-maritime-museum-1.mp3',
  liotrivi: 'music/the-old-olive-press-1.mp3',
  windmill: 'music/the-view-from-the-windmill-1.mp3',
  cave:     'music/the-cave-of-karkaros-1.mp3',
  graveyard:'music/the-captain-s-rest-1.mp3',
  church:   'music/the-map-in-the-church-1.mp3',
  church_interior: 'music/the-map-in-the-church-1.mp3',
  boat:     'music/the-crossing-1.mp3',
  treasure:  'music/the-treasure-1.mp3',
  new_era:   'music/the-sea-remembers-1.mp3',
  epilogue:  'music/the-sea-remembers-1.mp3',
  _festival: 'music/the-festival-of-galaxidi-1.mp3',
  _ghost:    'music/graveyard-veil-1.mp3',
  _jade:     'music/the-ghost-of-captain-visvikis-1.mp3',
};

let currentMusicSrc = '';

function fadeAllAudio(targetVol, duration, cb) {
  const startBgm = bgm.volume;
  const targetBgm = targetVol * 0.25;
  const startAmb = (ambientSounds.masterGain && ambientSounds.masterGain.gain) ? ambientSounds.masterGain.gain.value : 1;
  const targetAmb = targetVol;
  const t0 = performance.now();
  const step = () => {
    const p = Math.min(1, (performance.now() - t0) / duration);
    bgm.volume = startBgm + (targetBgm - startBgm) * p;
    if (ambientSounds.masterGain) ambientSounds.masterGain.gain.value = startAmb + (targetAmb - startAmb) * p;
    if (p < 1) requestAnimationFrame(step);
    else if (cb) cb();
  };
  requestAnimationFrame(step);
}

function changeSceneMusic(sceneId) {
  const newSrc = sceneMusic[sceneId];
  if (!newSrc || newSrc === currentMusicSrc) return;
  // Crossfade: old out, new in
  const oldVol = bgm.volume;
  const fadeDur = 1500;
  const fadeStart = performance.now();
  const fadeOut = () => {
    const t = Math.min(1, (performance.now() - fadeStart) / fadeDur);
    bgm.volume = oldVol * (1 - t);
    if (t < 1) { requestAnimationFrame(fadeOut); return; }
    bgm.pause();
    bgm.src = newSrc;
    currentMusicSrc = newSrc;
    bgm.volume = 0;
    bgm.play().catch(() => {});
    // Fade in
    const fadeInStart = performance.now();
    const fadeIn = () => {
      const t2 = Math.min(1, (performance.now() - fadeInStart) / fadeDur);
      bgm.volume = 0.25 * t2;
      if (t2 < 1) requestAnimationFrame(fadeIn);
    };
    requestAnimationFrame(fadeIn);
  };
  requestAnimationFrame(fadeOut);
}

function toggleMusic() {
  if (state.musicOn) {
    bgm.pause(); state.musicOn = false;
  } else {
    bgm.play().catch(() => {}); state.musicOn = true;
  }
}

// ════════════════════════════════════════════════════════════
// TITLE SCREEN — Bright sunny harbor with animated title
// ════════════════════════════════════════════════════════════
const titleMusic = document.getElementById('title-music');
titleMusic.volume = 0.7;
let titleFadeOut = 0;
let titleStartTick = -1;

// Title text animation config
const titleLine1 = 'ΤΟ ΜΥΣΤΗΡΙΟ';
const titleLine2 = 'του';
const titleLine3 = 'ΓΑΛΑΞΕΙΔΙΟΥ';
const LETTER_DELAY = 4;
const LINE2_DELAY = 55;
const LINE3_DELAY = 25;
const PROMPT_DELAY = 70;

function drawTitleScreen(tick) {
  if (titleStartTick < 0) titleStartTick = tick;
  const elapsed = tick - titleStartTick;
  const t = tick * 0.02;

  // ═══════════════════════════════════════
  // BACKGROUND — cinematic zoom-out + animated water
  // Scanline displacement (Monkey Island / SNES technique)
  // ═══════════════════════════════════════
  const bg = images['title-bg'];
  const waterLine = Math.floor(GH * 0.80);

  // Zoom: starts at 1.12x, eases to 1.0x over ~400 ticks (~7 sec)
  const zoomDuration = 400;
  const zoomT = Math.min(1, elapsed / zoomDuration);
  const easeOut = 1 - Math.pow(1 - zoomT, 3);
  const zoom = 1.12 - 0.12 * easeOut;

  if (bg && bg.complete) {
    // Draw with zoom — sky + land above waterline (static)
    const srcWaterY = bg.naturalHeight * (waterLine / GH);
    ctx.save();
    ctx.translate(GW / 2, GH / 2);
    ctx.scale(zoom, zoom);
    ctx.translate(-GW / 2, -GH / 2);

    // Sky + land (smooth scaling to avoid dithered gradients)
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(bg,
      0, 0, bg.naturalWidth, srcWaterY,
      0, 0, GW, waterLine);
    ctx.imageSmoothingEnabled = false;

    // Water: per-scanline horizontal displacement for wave motion
    for (let y = waterLine; y < GH; y++) {
      const depth = (y - waterLine) / (GH - waterLine);
      const amp = 0.6 + depth * 1.8;
      const dx = Math.sin(y * 0.08 + t * 1.6) * amp
               + Math.sin(y * 0.13 - t * 1.0) * (amp * 0.4);
      const srcY = bg.naturalHeight * (y / GH);
      ctx.drawImage(bg,
        0, srcY, bg.naturalWidth, 1,
        dx, y, GW, 1);
    }
    ctx.restore();

    // Sun sparkles on the water
    for (let i = 0; i < 18; i++) {
      const sx = ((tick * 0.35 + i * 43) % GW);
      const sy = waterLine + 4 + ((i * 29) % (GH - waterLine - 8));
      const glint = Math.sin(tick * 0.09 + i * 2.3);
      if (glint > 0.55) {
        const a = (glint - 0.55) * 2.2;
        ctx.fillStyle = `rgba(255,255,240,${a * 0.45})`;
        ctx.fillRect(sx, sy, 2, 1);
        if (glint > 0.8) {
          ctx.fillRect(sx + 1, sy - 1, 1, 1);
          ctx.fillRect(sx + 1, sy + 1, 1, 1);
        }
      }
    }

    // ── Sun rays / god rays ──
    ctx.save();
    const rt = tick * 0.004;
    const lg = ctx.createLinearGradient(GW * 0.7, 0, GW * 0.2, GH * 0.5);
    lg.addColorStop(0, `rgba(255,220,120,${0.04 + Math.sin(rt) * 0.012})`);
    lg.addColorStop(0.5, `rgba(255,200,80,${0.015 + Math.sin(rt + 1) * 0.006})`);
    lg.addColorStop(1, 'rgba(255,200,80,0)');
    ctx.fillStyle = lg;
    ctx.fillRect(0, 0, GW, GH);
    ctx.fillStyle = '#FFD880';
    ctx.globalAlpha = 0.016 + Math.sin(rt * 0.8) * 0.005;
    ctx.beginPath();
    ctx.moveTo(GW * 0.65, 0); ctx.lineTo(GW * 0.25, GH * 0.6);
    ctx.lineTo(GW * 0.32, GH * 0.6); ctx.lineTo(GW * 0.72, 0);
    ctx.closePath(); ctx.fill();
    ctx.globalAlpha = 0.012 + Math.sin(rt * 0.6 + 1.5) * 0.004;
    ctx.beginPath();
    ctx.moveTo(GW * 0.78, 0); ctx.lineTo(GW * 0.45, GH * 0.5);
    ctx.lineTo(GW * 0.50, GH * 0.5); ctx.lineTo(GW * 0.83, 0);
    ctx.closePath(); ctx.fill();
    ctx.globalAlpha = 0.009 + Math.sin(rt * 0.5 + 3.0) * 0.003;
    ctx.beginPath();
    ctx.moveTo(GW * 0.55, 0); ctx.lineTo(GW * 0.10, GH * 0.7);
    ctx.lineTo(GW * 0.18, GH * 0.7); ctx.lineTo(GW * 0.60, 0);
    ctx.closePath(); ctx.fill();
    ctx.restore();

    // ── Seagulls — pixel birds flying across the sky ──
    const gulls = [
      { speed: 0.35, y0: 30, amp: 5, phase: 0 },
      { speed: 0.25, y0: 50, amp: 8, phase: 150 },
      { speed: 0.45, y0: 18, amp: 4, phase: 300 },
      { speed: 0.30, y0: 65, amp: 6, phase: 220 },
      { speed: 0.20, y0: 40, amp: 10, phase: 400 },
    ];
    for (const gull of gulls) {
      const cycle = GW + 100;
      const gx = ((tick * gull.speed + gull.phase * 2) % cycle) - 50;
      const gy = gull.y0 + Math.sin(t * 1.2 + gull.phase) * gull.amp;
      const wingFlap = Math.sin(tick * 0.15 + gull.phase) * 5;
      const gSize = 0.8 + gull.speed * 0.5;
      ctx.save();
      ctx.translate(gx, gy);
      ctx.scale(gSize, gSize);
      ctx.fillStyle = '#FFF';
      ctx.fillRect(-1, 0, 3, 2);
      ctx.strokeStyle = '#2A2A30';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-8, wingFlap); ctx.lineTo(-3, -1);
      ctx.lineTo(0, 1); ctx.lineTo(3, -1); ctx.lineTo(8, wingFlap);
      ctx.stroke();
      ctx.strokeStyle = 'rgba(255,255,255,0.7)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-7, wingFlap - 1); ctx.lineTo(-3, -2);
      ctx.moveTo(3, -2); ctx.lineTo(7, wingFlap - 1);
      ctx.stroke();
      ctx.restore();
    }

    // ── Tiny people strolling along the dock ──
    const walkers = [
      // Right dock / stone walkway
      { x0: 400, range: 45, speed: 0.06, y: 350, phase: 0,   shirt: '#9A3030', pants: '#4A4A56' },
      { x0: 480, range: 40, speed: -0.05, y: 353, phase: 80,  shirt: '#2858A0', pants: '#3A3A48' },
      { x0: 540, range: 30, speed: 0.07, y: 347, phase: 200, shirt: '#D09040', pants: '#484854' },
      // Harbor edge near boats (left side)
      { x0: 120, range: 30, speed: 0.04, y: 285, phase: 50,  shirt: '#7A4020', pants: '#3A3A48' },
      { x0: 220, range: 25, speed: -0.03, y: 288, phase: 160, shirt: '#308050', pants: '#484854' },
    ];
    ctx.globalAlpha = 0.8;
    for (const p of walkers) {
      const pcycle = p.range * 2;
      const raw = ((tick * Math.abs(p.speed) + p.phase) % pcycle);
      const wx = p.x0 + (raw < p.range ? raw : pcycle - raw);
      const dir = p.speed > 0 ? (raw < p.range ? 1 : -1) : (raw < p.range ? -1 : 1);
      const step = Math.floor(tick * Math.abs(p.speed) * 0.4 + p.phase) % 2;
      ctx.save();
      ctx.translate(Math.floor(wx), p.y);
      if (dir < 0) ctx.scale(-1, 1);
      // Head (3x2)
      ctx.fillStyle = '#D4AC80';
      ctx.fillRect(0, 0, 3, 2);
      // Hair
      ctx.fillStyle = '#5A3A20';
      ctx.fillRect(0, 0, 3, 1);
      // Torso (3x3)
      ctx.fillStyle = p.shirt;
      ctx.fillRect(0, 2, 3, 3);
      // Arms swinging
      const armSwing = step === 0 ? 1 : -1;
      ctx.fillRect(-1, 2 + armSwing, 1, 2);
      ctx.fillRect(3, 2 - armSwing, 1, 2);
      // Legs (2-frame walk)
      ctx.fillStyle = p.pants;
      if (step === 0) {
        ctx.fillRect(0, 5, 1, 3);
        ctx.fillRect(2, 5, 1, 2);
      } else {
        ctx.fillRect(0, 5, 1, 2);
        ctx.fillRect(2, 5, 1, 3);
      }
      // Shoes
      ctx.fillStyle = '#2A1A10';
      ctx.fillRect(0, step === 0 ? 8 : 7, 1, 1);
      ctx.fillRect(2, step === 0 ? 7 : 8, 1, 1);
      ctx.restore();
    }
    ctx.globalAlpha = 1;

    // ── Wind dust motes ──
    ctx.save();
    for (let i = 0; i < 15; i++) {
      const dx = ((tick * (0.15 + i * 0.03) + i * 47) % (GW + 20)) - 10;
      const baseY = 40 + (i * 53) % 280;
      const dy = baseY + Math.sin(tick * 0.012 + i * 1.7) * 8;
      const gustAlpha = 0.12 + Math.sin(tick * 0.008 + i * 2.1) * 0.08;
      if (gustAlpha > 0) {
        ctx.globalAlpha = gustAlpha;
        ctx.fillStyle = '#FFE8A0';
        ctx.fillRect(Math.floor(dx), Math.floor(dy), 1, 1);
      }
    }
    ctx.restore();

  } else {
    ctx.fillStyle = '#4A9FD8';
    ctx.fillRect(0, 0, GW, GH);
  }

  // Subtle vignette
  const vig = ctx.createRadialGradient(GW/2, GH/2, GW*0.3, GW/2, GH/2, GW*0.75);
  vig.addColorStop(0, 'rgba(0,0,0,0)');
  vig.addColorStop(1, 'rgba(0,0,0,0.12)');
  ctx.fillStyle = vig;
  ctx.fillRect(0, 0, GW, GH);

  // ═══════════════════════════════════════
  // ANIMATED TITLE — letters unfold cinematically
  // ═══════════════════════════════════════
  const l1N = titleLine1.length;
  const l1End = l1N * LETTER_DELAY;
  const l2Start = l1End + LINE2_DELAY;
  const l2End = l2Start + 15;
  const l3Start = l2End + LINE3_DELAY;
  const l3N = titleLine3.length;
  const l3End = l3Start + l3N * LETTER_DELAY;
  const promptAt = l3End + PROMPT_DELAY;

  ctx.save();
  ctx.textBaseline = 'middle';

  function drawLetter(ch, cx, cy, size, progress) {
    if (progress <= 0) return;
    const p = Math.min(1, progress);
    const scale = p < 0.5 ? 1.5 - p : 1.0 + Math.sin((p-0.5)*Math.PI)*0.05;
    const alpha = Math.min(1, p * 2);
    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(scale, scale);
    ctx.globalAlpha = alpha;
    ctx.font = `bold ${size}px "Press Start 2P", monospace`;
    ctx.textAlign = 'center';
    const shd = [['#060200',5],['#1A0804',4],['#2E1508',3],['#4A2010',2],['#7A5018',1]];
    for (const [c,d] of shd) { ctx.fillStyle = c; ctx.fillText(ch, d, d); }
    const g = 0.3 + Math.sin(t*1.2 + cx*0.01)*0.15;
    ctx.shadowColor = `rgba(255,180,40,${g*alpha})`;
    ctx.shadowBlur = 20;
    ctx.fillStyle = '#D4A03C';
    ctx.fillText(ch, 0, 0);
    ctx.shadowBlur = 0;
    ctx.fillStyle = `rgba(255,235,170,${0.35*alpha})`;
    ctx.fillText(ch, 0, -1);
    ctx.restore();
  }

  // Line 1: "ΤΟ ΜΥΣΤΗΡΙΟ"
  const l1Size = 36, l1Y = 100;
  ctx.font = `bold ${l1Size}px "Press Start 2P", monospace`;
  ctx.textAlign = 'left';
  const l1W = ctx.measureText(titleLine1).width;
  let l1X = (GW - l1W) / 2;
  for (let i = 0; i < l1N; i++) {
    const ch = titleLine1[i];
    const chW = ctx.measureText(ch).width;
    drawLetter(ch, l1X + chW/2, l1Y, l1Size, (elapsed - i*LETTER_DELAY)/20);
    l1X += chW;
  }

  // Line 2: "του"
  if (elapsed > l2Start) {
    const p2 = Math.min(1, (elapsed - l2Start) / 25);
    ctx.save();
    ctx.globalAlpha = p2;
    ctx.translate(GW/2, l1Y + 50);
    ctx.scale(1.3 - p2*0.3, 1.3 - p2*0.3);
    ctx.font = 'bold 14px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#1A0804'; ctx.fillText(titleLine2, 2, 2);
    ctx.fillStyle = '#B8842C'; ctx.fillText(titleLine2, 0, 0);
    ctx.restore();
  }

  // Line 3: "ΓΑΛΑΞΕΙΔΙΟΥ"
  const l3Size = 38, l3Y = l1Y + 102;
  ctx.font = `bold ${l3Size}px "Press Start 2P", monospace`;
  const l3W = ctx.measureText(titleLine3).width;
  let l3X = (GW - l3W) / 2;
  for (let i = 0; i < l3N; i++) {
    const ch = titleLine3[i];
    const chW = ctx.measureText(ch).width;
    drawLetter(ch, l3X + chW/2, l3Y, l3Size, (elapsed - l3Start - i*LETTER_DELAY)/20);
    l3X += chW;
  }
  ctx.restore();


  // Blinking start prompt + continue option
  if (elapsed > promptAt) {
    const blink = 0.2 + Math.sin(tick*0.06)*0.45;
    const hasContinue = hasSave('auto') || hasSave('manual');
    const newGameY = hasContinue ? GH - 50 : GH - 35;
    ctx.save();
    ctx.font = '8px "Press Start 2P", monospace';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.globalAlpha = Math.max(0, blink);
    ctx.fillStyle = '#D4A03C';
    ctx.shadowColor = 'rgba(212,160,60,0.5)'; ctx.shadowBlur = 10;
    ctx.fillText('► ΝΕΟ ΠΑΙΧΝΙΔΙ ◄', GW/2, newGameY);
    ctx.restore();
    if (hasContinue) {
      const blink2 = 0.2 + Math.sin(tick*0.06 + 1)*0.45;
      ctx.save();
      ctx.font = '8px "Press Start 2P", monospace';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.globalAlpha = Math.max(0, blink2);
      ctx.fillStyle = '#8BC4E8';
      ctx.shadowColor = 'rgba(139,196,232,0.5)'; ctx.shadowBlur = 10;
      ctx.fillText('► ΣΥΝΕΧΕΙΑ ◄', GW/2, GH - 25);
      ctx.restore();
    }
  }

  // Version stamp
  ctx.save();
  ctx.font = '10px monospace';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'bottom';
  ctx.fillStyle = '#666';
  ctx.globalAlpha = 0.6;
  ctx.fillText(GAME_VERSION + ' \u2022 ' + GAME_BUILD, 6, GH - 4);
  ctx.restore();

  // Fade overlay
  if (titleFadeOut > 0) {
    ctx.save();
    ctx.globalAlpha = titleFadeOut;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, GW, GH);
    ctx.restore();
  }
}



// ════════════════════════════════════════════════════════════
// STAR WARS TEXT CRAWL
// ════════════════════════════════════════════════════════════

// Persistent dust motes for the crawl — initialized once
const crawlDust = Array.from({length: 40}, () => ({
  x: Math.random() * 640,
  y: Math.random() * 400,
  size: 1 + Math.random() * 2.5,
  speed: 0.15 + Math.random() * 0.3,
  drift: (Math.random() - 0.5) * 0.4,
  phase: Math.random() * Math.PI * 2,
  brightness: 0.5 + Math.random() * 0.5,
}));

function drawCrawl(tick) {
  const t0 = tick * 0.01; // slow time for ambient animation
  const parchment = images['intro-parchment'];

  // Draw parchment background (cover fit) with gentle brightness pulse
  if (parchment && parchment.complete) {
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    const imgAspect = parchment.naturalWidth / parchment.naturalHeight;
    const canAspect = GW / GH;
    let sw, sh, sx, sy;
    if (imgAspect > canAspect) {
      sh = parchment.naturalHeight; sw = sh * canAspect;
      sx = (parchment.naturalWidth - sw) / 2; sy = 0;
    } else {
      sw = parchment.naturalWidth; sh = sw / canAspect;
      sx = 0; sy = (parchment.naturalHeight - sh) / 2;
    }
    ctx.drawImage(parchment, sx, sy, sw, sh, 0, 0, GW, GH);
  } else {
    ctx.fillStyle = '#2a1f0e';
    ctx.fillRect(0, 0, GW, GH);
  }



  // ═══════════════════════════════════════
  // SUBTLE MAP ENHANCEMENTS — animated effects over the atlas map
  // The new intro-parchment-v2 already has ships, mermaid, compass, treasure X
  // ═══════════════════════════════════════

  // ── Subtle treasure X glow (pulsing golden light where X is on map) ──
  ctx.save();
  const txGlow = 0.08 + Math.sin(t0 * 1.2) * 0.06;
  ctx.globalAlpha = txGlow;
  ctx.fillStyle = '#d4a030';
  ctx.shadowColor = '#ffe060';
  ctx.shadowBlur = 20;
  ctx.beginPath();
  ctx.arc(GW * 0.47, GH * 0.62, 12, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();

  // ── Compass rose shimmer (subtle gold sparkle) ──
  ctx.save();
  const compassGlint = 0.06 + Math.sin(t0 * 0.7 + 1.5) * 0.04;
  ctx.globalAlpha = compassGlint;
  ctx.fillStyle = '#d4a030';
  ctx.shadowColor = '#b8860b';
  ctx.shadowBlur = 15;
  ctx.beginPath();
  ctx.arc(68, 58, 8, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();

  // ── Cartouche title shimmer ──
  ctx.save();
  const cartGlint = 0.04 + Math.sin(t0 * 0.5) * 0.03;
  ctx.globalAlpha = cartGlint;
  ctx.fillStyle = '#d4a030';
  ctx.shadowColor = '#ffe060';
  ctx.shadowBlur = 12;
  ctx.fillRect(GW - 180, 18, 160, 55);
  ctx.shadowBlur = 0;
  ctx.restore();

  // Warm ambient light overlay — gentle breathing glow
  const warmPulse = 0.06 + Math.sin(t0 * 0.8) * 0.03;
  ctx.fillStyle = `rgba(180, 140, 60, ${warmPulse})`;
  ctx.fillRect(0, 0, GW, GH);

  // Diagonal light rays (slow drift)
  ctx.save();
  ctx.globalCompositeOperation = 'screen';
  for (let r = 0; r < 3; r++) {
    const rayX = GW * (0.2 + r * 0.3) + Math.sin(t0 * 0.3 + r * 2) * 30;
    const rayW = 40 + Math.sin(t0 * 0.5 + r) * 15;
    const rayAlpha = 0.04 + Math.sin(t0 * 0.4 + r * 1.5) * 0.02;
    const rayGrd = ctx.createLinearGradient(rayX - rayW, 0, rayX + rayW, 0);
    rayGrd.addColorStop(0, 'rgba(200,170,80,0)');
    rayGrd.addColorStop(0.5, `rgba(200,170,80,${rayAlpha})`);
    rayGrd.addColorStop(1, 'rgba(200,170,80,0)');
    ctx.fillStyle = rayGrd;
    ctx.save();
    ctx.translate(rayX, GH / 2);
    ctx.rotate(-0.3);
    ctx.translate(-rayX, -GH / 2);
    ctx.fillRect(rayX - rayW * 2, -50, rayW * 4, GH + 100);
    ctx.restore();
  }
  ctx.restore();

  // Darken edges for readability
  ctx.fillStyle = 'rgba(10, 5, 0, 0.25)';
  ctx.fillRect(0, 0, GW, GH);

  // Warm vignette (golden center, dark edges)
  const vgrd = ctx.createRadialGradient(GW / 2, GH / 2, GW * 0.2, GW / 2, GH / 2, GW * 0.7);
  vgrd.addColorStop(0, 'rgba(60,40,10,0)');
  vgrd.addColorStop(0.6, 'rgba(20,10,0,0.15)');
  vgrd.addColorStop(1, 'rgba(0,0,0,0.65)');
  ctx.fillStyle = vgrd;
  ctx.fillRect(0, 0, GW, GH);

  // ── Floating golden dust motes ──
  ctx.save();
  for (const d of crawlDust) {
    d.y -= d.speed;
    d.x += d.drift + Math.sin(tick * 0.02 + d.phase) * 0.3;
    if (d.y < -5) { d.y = GH + 5; d.x = Math.random() * GW; }
    if (d.x < -5) d.x = GW + 5;
    if (d.x > GW + 5) d.x = -5;

    const flicker = 0.3 + Math.sin(tick * 0.06 + d.phase) * 0.2;
    ctx.globalAlpha = flicker * d.brightness;
    ctx.fillStyle = '#d4a84080';
    ctx.beginPath();
    ctx.arc(d.x, d.y, d.size, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();

  // ── Perspective text crawl (sub-pixel smooth) ──
  const scrollY = state.crawlScroll;
  const vanishY = GH * 0.10;
  const nearY = GH * 0.92;
  const crawlFont = "'Cormorant Garamond', 'Cinzel', Georgia, serif";
  // Fixed font sizes — all scaling done via canvas transform for buttery smoothness
  const basePx = 16;
  const titlePx = 28;

  ctx.save();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.imageSmoothingEnabled = true;

  for (let i = 0; i < CRAWL_LINES.length; i++) {
    const line = CRAWL_LINES[i];
    if (!line) continue;

    // Smooth fractional distance
    const dist = scrollY - i * CRAWL_LINE_SPACING;
    if (dist < -1) continue;
    if (dist > CRAWL_VISIBLE_DEPTH) continue;

    const tRaw = dist / CRAWL_VISIBLE_DEPTH;
    const t = Math.max(0, Math.min(1, tRaw));

    // Smooth perspective scale (never zero)
    const scale = 1 - t * 0.82;
    if (scale < 0.04) continue;

    // Smooth screen Y — cubic ease for more natural perspective
    const screenY = nearY - (nearY - vanishY) * (1 - Math.pow(1 - t, 1.8));

    // Smooth alpha — hermite (smoothstep) fade at both edges
    let alpha = 1;
    if (t > 0.78) {
      const f = (t - 0.78) / 0.22;
      alpha = 1 - f * f * (3 - 2 * f); // smoothstep out
    }
    if (t < 0.08) {
      const f = t / 0.08;
      alpha = f * f * (3 - 2 * f); // smoothstep in
    }
    if (alpha <= 0.005) continue;

    const isTitle = (i === 0);
    const fontPx = isTitle ? titlePx : basePx;
    const weight = isTitle ? '700' : '400';
    ctx.font = `${weight} ${fontPx}px ${crawlFont}`;

    // Dark outline pass (strong contrast against busy map)
    ctx.save();
    ctx.translate(GW / 2, screenY);
    ctx.scale(scale, scale);
    ctx.globalAlpha = alpha * 0.7;
    ctx.shadowColor = '#000';
    ctx.shadowBlur = isTitle ? 12 : 6;
    ctx.fillStyle = 'rgba(20,10,0,0.8)';
    ctx.fillText(line, 0, 0);
    ctx.restore();

    // Golden glow (warm halo behind text)
    ctx.save();
    ctx.translate(GW / 2, screenY);
    ctx.scale(scale, scale);
    ctx.globalAlpha = alpha * 0.4;
    ctx.shadowColor = '#d4a030';
    ctx.shadowBlur = isTitle ? 18 : 10;
    ctx.fillStyle = '#c8a030';
    ctx.fillText(line, 0, 0);
    ctx.restore();

    // Main text — warm golden cream
    ctx.save();
    ctx.translate(GW / 2, screenY);
    ctx.scale(scale, scale);
    ctx.globalAlpha = alpha;
    ctx.shadowColor = 'rgba(0,0,0,0.6)';
    ctx.shadowBlur = 3;
    ctx.shadowOffsetY = 1;
    ctx.fillStyle = isTitle ? '#ffd454' : '#f0d060';
    ctx.fillText(line, 0, 0);
    ctx.restore();
  }

  ctx.restore();

  // Skip hint
  ctx.save();
  ctx.globalAlpha = 0.3 + Math.sin(tick * 0.05) * 0.12;
  ctx.font = "7px 'Press Start 2P', monospace";
  ctx.fillStyle = '#8a7a5a';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'bottom';
  ctx.fillText('ESC / ΚΛΙΚ', GW - 10, GH - 8);
  ctx.restore();

  // Fade overlay (for transition out)
  if (state.crawlFadeAlpha > 0) {
    ctx.save();
    ctx.globalAlpha = state.crawlFadeAlpha;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, GW, GH);
    ctx.restore();
  }
}

function endCrawl() {
  if (state.crawlFading) return;
  state.crawlFading = true;
  const fadeStep = () => {
    state.crawlFadeAlpha += 0.025;
    if (state.crawlFadeAlpha < 1) {
      requestAnimationFrame(fadeStep);
    } else {
      state.crawlFadeAlpha = 1;
      state.phase = 'intro';
      state.musicOn = true;
      const intro = document.getElementById('intro-screen');
      intro.classList.add('show');
      showIntroPage();
    }
  };
  requestAnimationFrame(fadeStep);
}

// Click to skip crawl
CVS.addEventListener('click', () => {
  if (state.phase === 'crawl' && !state.crawlFading) {
    endCrawl();
  }
});

// ════════════════════════════════════════════════════════════
// TITLE & INTRO FLOW
// ════════════════════════════════════════════════════════════
let titleClicked = false;
let titleMusicStarted = false;

// Start title music on any user gesture (needed for autoplay policy)
function ensureTitleMusic() {
  if (!titleMusicStarted && state.phase === 'title') {
    titleMusic.currentTime = 0;
    const p = titleMusic.play();
    if (p) p.then(() => { titleMusicStarted = true; console.log('Title music playing'); }).catch(e => console.warn('Title music blocked:', e));
  }
}
// Try immediately + on any interaction
ensureTitleMusic();
document.addEventListener('click', ensureTitleMusic);
document.addEventListener('keydown', ensureTitleMusic);
document.addEventListener('touchstart', ensureTitleMusic);

CVS.addEventListener('click', function titleClickHandler(e) {
  if (state.phase !== 'title' || titleClicked) return;
  // First click just starts music — need a second click to proceed
  if (!titleMusicStarted) {
    ensureTitleMusic();
    return;
  }

  // Check if Continue was clicked
  const hasContinueData = hasSave('auto') || hasSave('manual');
  if (hasContinueData) {
    const g = screenToGame(e.clientX, e.clientY);
    const continueY = GH - 25;
    if (g.y > continueY - 12 && g.y < continueY + 12) {
      titleClicked = true;
      const fadeStep = () => {
        titleFadeOut += 0.02;
        if (titleFadeOut < 1) {
          requestAnimationFrame(fadeStep);
        } else {
          titleFadeOut = 1;
          const slot = hasSave('manual') ? 'manual' : 'auto';
          if (loadGame(slot)) {
            const sceneId = state.scene;
            state.phase = 'playing';
            state.musicOn = true;
            renderInvUI();
            startScene(sceneId);
          }
        }
      };
      requestAnimationFrame(fadeStep);
      return;
    }
  }

  titleClicked = true;

  // Keep title music playing through intro — don't fade it here

  // Animate fade to black
  const fadeStep = () => {
    titleFadeOut += 0.02;
    if (titleFadeOut < 1) {
      requestAnimationFrame(fadeStep);
    } else {
      titleFadeOut = 1;
      // Switch to text crawl — title music keeps playing
      state.phase = 'crawl';
      state.crawlScroll = 0;
      state.crawlFading = false;
      state.crawlFadeAlpha = 0;
      state.musicOn = true;
    }
  };
  requestAnimationFrame(fadeStep);
}, { once: false });

function showIntroPage() {
  const t = document.getElementById('intro-text');
  const h = document.getElementById('intro-hint');
  t.style.opacity = '0';
  h.classList.remove('on');
  setTimeout(() => {
    t.innerHTML = introPages[state.introPage].replace(/\n/g, '<br>');
    t.style.opacity = '1';
    setTimeout(() => h.classList.add('on'), 1200);
  }, 300);
}

document.getElementById('intro-screen').onclick = () => {
  state.introPage++;
  if (state.introPage >= introPages.length) {
    const is = document.getElementById('intro-screen');
    is.style.opacity = '0';

    // Keep title music playing through cutscene — dim slightly for cinematic feel
    const dimDur = 1500;
    const dimStart = performance.now();
    const dimStep = () => {
      const t = Math.min(1, (performance.now() - dimStart) / dimDur);
      const ease = t < 0.5 ? 4*t*t*t : 1-Math.pow(-2*t+2,3)/2;
      titleMusic.volume = 0.7 - ease * 0.3; // dim from 0.7 to 0.4
      if (t < 1) requestAnimationFrame(dimStep);
    };
    requestAnimationFrame(dimStep);

    setTimeout(() => {
      is.style.display = 'none';
      state.musicOn = true;
      startCutscene('arrival');
    }, 1500);
  } else {
    showIntroPage();
  }
};

// ════════════════════════════════════════════════════════════
// EPILOGUE SYSTEM
// ════════════════════════════════════════════════════════════
function showEpiloguePage() {
  const t = document.getElementById('epilogue-text');
  const h = document.getElementById('epilogue-hint');
  t.style.opacity = '0';
  h.classList.remove('on');
  setTimeout(() => {
    t.innerHTML = epiloguePages[state.epiloguePage].replace(/\n/g, '<br>');
    t.style.opacity = '1';
    setTimeout(() => h.classList.add('on'), 1200);
  }, 300);
}

document.getElementById('epilogue-screen').onclick = () => {
  state.epiloguePage++;
  if (state.epiloguePage >= epiloguePages.length) {
    const es = document.getElementById('epilogue-screen');
    es.style.opacity = '0';
    setTimeout(() => {
      es.style.display = 'none';
      es.classList.remove('show');
      es.style.opacity = '';
      state.phase = 'title';
      titleClicked = false;
      titleFadeOut = 0;
    }, 1500);
  } else {
    showEpiloguePage();
  }
};

// ════════════════════════════════════════════════════════════
// BOOT
// ════════════════════════════════════════════════════════════
loadAllAssets().then(() => {
  requestAnimationFrame(gameLoop);
});
</script>
</body>
</html>
