<!DOCTYPE html>
<html lang="el">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Το Μυστήριο του Γαλαξειδίου — Canvas Engine</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
  body { background: #000; overflow: hidden; font-family: 'Press Start 2P', monospace; display: flex; flex-direction: column; height: 100vh; }

  /* ── CANVAS ── */
  #game-canvas {
    display: block; background: #0a0812;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    cursor: crosshair;
    flex: 1;
    width: 100%;
    min-height: 0;
  }

  /* ── ACTION LINE ── */
  #action-line {
    height: 32px; display: none; align-items: center; justify-content: center;
    font-family: 'Press Start 2P', monospace;
    font-size: .65rem; color: #F0C860; letter-spacing: 1px;
    background: linear-gradient(180deg, #1a1610 0%, #0e0c08 100%);
    border-top: 3px solid #3a3020;
    border-bottom: 1px solid #1a1408;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.8), 0 0 8px rgba(212,160,60,0.15);
  }
  #action-line.on { display: flex; }

  /* ── UI PANEL — Classic SCUMM layout ── */
  #ui-panel {
    background: linear-gradient(180deg, #14120e 0%, #0c0a06 40%, #080604 100%);
    border-top: 3px solid #3a3020;
    display: none; flex-direction: column;
    box-shadow: inset 0 2px 6px rgba(0,0,0,0.5);
  }
  #ui-panel.on { display: flex; }

  /* Bottom row: verbs LEFT, inventory RIGHT */
  #ui-bottom {
    display: flex; height: 150px; padding: 6px 8px;
  }

  /* ── VERB GRID (left side, 2x2) ── */
  #verb-panel {
    display: grid; grid-template-columns: repeat(2, 1fr); grid-template-rows: repeat(2, 1fr);
    gap: 4px; width: 300px; flex-shrink: 0;
  }
  .vb {
    font-family: 'Press Start 2P', monospace; font-size: .6rem; color: #9a8a68;
    background: linear-gradient(180deg, #201c14 0%, #181410 50%, #141008 100%);
    border: 2px solid #2e2618;
    border-top-color: #3a3228; border-left-color: #3a3228;
    border-bottom-color: #1a1408; border-right-color: #1a1408;
    cursor: pointer; transition: all .15s;
    display: flex; align-items: center; justify-content: center;
    padding: 4px 8px; text-align: center;
    text-shadow: 1px 1px 1px rgba(0,0,0,0.6);
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.04), 0 1px 2px rgba(0,0,0,0.3);
  }
  .vb:hover {
    color: #F0C860; border-color: #D4A03C;
    background: linear-gradient(180deg, #2a2418 0%, #221e14 50%, #1a1610 100%);
    text-shadow: 0 0 6px rgba(240,200,96,0.3);
  }
  .vb:active { transform: scale(.97); }
  .vb.on {
    color: #F0C860;
    background: linear-gradient(180deg, #2e2818 0%, #261e10 50%, #201a0c 100%);
    border: 2px solid #D4A03C;
    border-top-color: #e0b050; border-left-color: #e0b050;
    border-bottom-color: #a08030; border-right-color: #a08030;
    text-shadow: 0 0 8px rgba(240,200,96,0.4);
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.06), 0 0 6px rgba(212,160,60,0.15);
  }

  /* ── INVENTORY GRID (right side) ── */
  #inv-panel {
    flex: 1; display: flex; align-items: stretch;
    margin-left: 8px;
    border: 2px solid #2e2618;
    border-top-color: #1a1408; border-left-color: #1a1408;
    border-bottom-color: #3a3228; border-right-color: #3a3228;
    background: linear-gradient(180deg, #0e0c08 0%, #121010 50%, #0e0c08 100%);
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.4);
    border-radius: 2px;
    padding: 0;
  }
  #inv-label { display: none; }
  #inv-arrows {
    display: flex; flex-direction: column; justify-content: center;
    gap: 6px; padding: 4px 6px; flex-shrink: 0;
    border-right: 1px solid #2a2218;
  }
  #inv-arrows button {
    font-size: .8rem; color: #7a6a48; background: linear-gradient(180deg, #1e1a12 0%, #161208 100%);
    border: 2px solid #2e2618;
    border-top-color: #3a3228; border-left-color: #3a3228;
    border-bottom-color: #1a1408; border-right-color: #1a1408;
    cursor: pointer; padding: 8px 10px; line-height: 1;
    transition: all .15s;
  }
  #inv-arrows button:hover {
    color: #F0C860; border-color: #D4A03C;
    text-shadow: 0 0 6px rgba(240,200,96,0.3);
  }
  #inv-grid {
    flex: 1; display: grid;
    grid-template-columns: repeat(auto-fill, 60px);
    grid-template-rows: repeat(2, 60px);
    grid-auto-flow: column;
    gap: 4px; padding: 6px;
    overflow: hidden;
    align-content: center;
  }
  .inv-slot {
    width: 60px; height: 60px;
    background: linear-gradient(180deg, #181410 0%, #121008 100%);
    border: 2px solid #2a2218;
    border-top-color: #1a1408; border-left-color: #1a1408;
    border-bottom-color: #322a1c; border-right-color: #322a1c;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; transition: all .15s;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
  }
  .inv-slot:hover {
    border-color: #D4A03C;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.3), 0 0 4px rgba(212,160,60,0.15);
  }
  .inv-slot.on {
    border: 2px solid #D4A03C;
    border-top-color: #e0b050; border-left-color: #e0b050;
    border-bottom-color: #a08030; border-right-color: #a08030;
    background: linear-gradient(180deg, #221e14 0%, #1a1610 100%);
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.2), 0 0 8px rgba(212,160,60,0.2);
  }
  .inv-slot .inv-text {
    font-family: 'Press Start 2P', monospace; font-size: .35rem; color: #9a8a68;
    text-align: center; line-height: 1.3;
    text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
  }

  /* ── TITLE (canvas-rendered, no HTML overlay) ── */
  @keyframes blink { 0%,100%{opacity:.3} 50%{opacity:.9} }

  /* ── INTRO OVERLAY ── */
  #intro-screen {
    position: fixed; inset: 0; background: #0a0812;
    display: none; flex-direction: column; align-items: center; justify-content: center;
    z-index: 1500; padding: 2rem; cursor: pointer; transition: opacity 1.5s;
  }
  #intro-screen.show { display: flex; }
  #intro-text { max-width:600px; font-size:clamp(.6rem,1.2vw,.8rem); color:#D4A03C; line-height:2.5; text-align:center; opacity:0; transition: opacity 1.5s; }
  #intro-hint { font-size:.5rem; color:#4a4a4a; margin-top:2rem; opacity:0; transition: opacity .5s; }
  #intro-hint.on { opacity:1; animation: blink 2s infinite; }

  /* ── FADE ── */
  #fade { position: fixed; inset: 0; background: #000; z-index: 3000; opacity: 0; pointer-events: none; transition: opacity .5s; }
  #fade.on { opacity: 1; }
</style>
</head>
<body>

<div id="fade"></div>

<!-- Title screen is canvas-rendered -->

<div id="intro-screen">
  <div id="intro-text"></div>
  <div id="intro-hint">▶ ΚΛΙΚ</div>
</div>

<canvas id="game-canvas" width="640" height="400"></canvas>

<div id="action-line"></div>

<div id="ui-panel">
  <div id="ui-bottom">
    <div id="verb-panel">
      <button class="vb on" data-v="look" onclick="setVerb('look')">Κοίταξε</button>
      <button class="vb" data-v="talk" onclick="setVerb('talk')">Μίλησε</button>
      <button class="vb" data-v="open" onclick="setVerb('open')">Άνοιξε</button>
      <button class="vb" data-v="use" onclick="setVerb('use')">Χρησιμοποίησε</button>
    </div>
    <div id="inv-panel">
      <div id="inv-arrows">
        <button onclick="scrollInv(-1)">▲</button>
        <button onclick="scrollInv(1)">▼</button>
      </div>
      <div id="inv-grid"></div>
    </div>
  </div>
</div>

<audio id="title-music" loop preload="auto"><source src="music/galaxidi-title-theme-1.mp3" type="audio/mpeg"></audio>
<audio id="bgm" loop preload="auto"><source src="music/arrival-at-galaxidi-scene-1-1.mp3" type="audio/mpeg"></audio>

<script>
// ════════════════════════════════════════════════════════════
// CANVAS ENGINE — Pure requestAnimationFrame game loop
// ════════════════════════════════════════════════════════════
const CVS = document.getElementById('game-canvas');
const ctx = CVS.getContext('2d');
const GW = 640, GH = 400; // internal game resolution
CVS.width = GW; CVS.height = GH;

// ════════════════════════════════════════════════════════════
// STATE
// ════════════════════════════════════════════════════════════
const state = {
  phase: 'title', // title, intro, playing
  scene: null,
  verb: 'look',
  inv: [],
  flags: {},
  visited: new Set(),
  tick: 0,
  mouseGX: 0, mouseGY: 0,
  hoverObj: null,
  musicOn: false,
  dlg: { active: false, queue: [], text: '', displayed: '', charIdx: 0, timer: 0, speaker: '', cb: null },
  fade: { active: false, alpha: 0, dir: 0, cb: null },
  introPage: 0,
};

// Characters
const chars = {
  ntemis: { x: 0, y: 0, dir: 1, walking: false, frame: 0, targetX: null, startX: 0, walkT: 0, walkDur: 0, visible: true, fadeIn: 0 },
  ajax:   { x: 0, y: 0, dir: 1, walking: false, frame: 0, targetX: null, startX: 0, walkT: 0, walkDur: 0, visible: true, fadeIn: 0 },
  clio:   { x: 0, y: 0, dir: 1, walking: false, frame: 0, targetX: null, startX: 0, walkT: 0, walkDur: 0, visible: true, fadeIn: 0 },
};
let walkDoneCallback = null;

// ════════════════════════════════════════════════════════════
// IMAGE LOADING
// ════════════════════════════════════════════════════════════
const images = {};
function loadImg(key, src) {
  return new Promise(resolve => {
    const img = new Image();
    img.onload = () => { images[key] = img; resolve(img); };
    img.onerror = () => { console.warn('Failed to load:', src); resolve(null); };
    img.src = src;
  });
}

// Character idle sprites
const CHAR_IMGS = {};
const WALK_FRAMES = { ntemis: [], ajax: [], clio: [] };
const PORTRAITS = {};

async function loadAllAssets() {
  // Backgrounds
  await Promise.all([
    loadImg('title-bg', 'assets/title-bg.png'),
    loadImg('bg-exterior', 'assets/pixel-exterior.png'),
    loadImg('bg-terrace', 'assets/pixel-terrace.png'),
    loadImg('bg-kitchen', 'assets/pixel-kitchen.png'),
    loadImg('bg-port', 'assets/pixel-port.jpg'),
    loadImg('bg-museum', 'assets/pixel-museum.png'),
    loadImg('bg-liotrivi', 'assets/pixel-liotrivi.png'),
    loadImg('bg-cave', 'assets/pixel-cave.png'),
    loadImg('bg-church', 'assets/pixel-church.jpg'),
    loadImg('bg-windmill', 'assets/pixel-windmill.jpg'),
    loadImg('bg-boat', 'assets/pixel-boat.png'),
    loadImg('bg-graveyard', 'assets/pixel-graveyard.png'),
  ]);

  // Character idle sprites
  const charPromises = ['ntemis','ajax','clio'].map(id =>
    loadImg(`char-${id}`, `assets/char-${id}-final.png`).then(img => { CHAR_IMGS[id] = img; })
  );

  // Portraits
  const portPromises = [
    loadImg('port-ntemis', 'assets/portrait-ntemis.png').then(img => { PORTRAITS['ΝΤΕΜΗΣ'] = img; }),
    loadImg('port-ajax', 'assets/portrait-ajax.png').then(img => { PORTRAITS['ΑΙΑΣ'] = img; }),
    loadImg('port-clio', 'assets/portrait-clio.png').then(img => { PORTRAITS['ΚΛΕΙΩ'] = img; }),
  ];

  await Promise.all([...charPromises, ...portPromises]);

  // Walk frames from JSON
  try {
    const resp = await fetch('assets/walk-frames-b64.json');
    const data = await resp.json();
    for (const who of ['ntemis','ajax','clio']) {
      if (data[who]) {
        for (let i = 0; i < data[who].length; i++) {
          const img = new Image();
          img.src = 'data:image/png;base64,' + data[who][i];
          WALK_FRAMES[who].push(img);
        }
      }
    }
  } catch(e) { console.warn('Walk frames load failed:', e); }
}

// ════════════════════════════════════════════════════════════
// SCENES DATA
// ════════════════════════════════════════════════════════════
const scenes = {
  exterior: {
    label: 'ΤΟ ΣΠΙΤΙ — ΓΑΛΑΞΙΔΙ', bg: 'bg-exterior',
    charPos: {
      ntemis: { x: 290, y: 340 },
      ajax:   { x: 370, y: 348 },
      clio:   { x: 210, y: 348 },
    },
    objects: [
      { id:'door', x:115, y:100, w:70, h:120, label:'Πόρτα',
        verbs: { look:[{s:'',t:'Ξύλινη πόρτα βαμμένη μπλε. Το χρώμα του Αιγαίου.'}],
                 open:[{s:'ΝΤΕΜΗΣ',t:'Ας μπούμε μέσα.'}], walk:'kitchen', use:'kitchen' }},
      { id:'bougainvillea', x:175, y:20, w:150, h:120, label:'Μπουκαμβίλιες',
        verbs: { look:[{s:'',t:'Ροζ μπουκαμβίλιες σκαρφαλώνουν στον τοίχο. Εδώ το καλοκαίρι αρνείται να φύγει.'}],
                 pick:[{s:'ΚΛΕΙΩ',t:'Μπαμπά, μην τις κόβεις! Είναι τέλειες έτσι.'}] }},
      { id:'flowerpots', x:75, y:195, w:65, h:55, label:'Γλάστρες',
        verbs: { look:[{s:'',t:'Πήλινες γλάστρες με βασιλικό. Κάποιος τα περιποιείται ακόμα κι όταν το σπίτι μένει κλειστό.'}] }},
      { id:'barrel', x:245, y:180, w:55, h:60, label:'Βαρέλι',
        verbs: { look:[{s:'',t:'Ένα παλιό ξύλινο βαρέλι. Μυρίζει κρασί και αλμύρα.'}],
                 open:[{s:'ΑΙΑΣ',t:'Άδειο. Κρίμα!'}] }},
      { id:'boats', x:380, y:120, w:140, h:80, label:'Ψαροκάικα',
        verbs: { look:[{s:'',t:'Χρωματιστά ψαροκάικα δεμένα στο λιμάνι. Κουνιούνται αργά στο απογευματινό φως.'},{s:'ΑΙΑΣ',t:'Μπαμπά, θα πάμε βόλτα με βάρκα;'}] }},
      { id:'sea', x:350, y:60, w:230, h:60, label:'Η θάλασσα',
        verbs: { look:[{s:'',t:'Ο Κορινθιακός κόλπος λάμπει χρυσαφί στο ηλιοβασίλεμα. Μαγικό.'}] }},
    ],
    exits: [
      { side:'right', target:'terrace', label:'Βεράντα →' },
      { side:'left', target:'port', label:'← Λιμάνι' },
    ],
    entry: [
      {s:'',t:'Ο ήλιος βάφει χρυσά τα καλντερίμια. Μυρωδιά πεύκου ανακατεμένη με θαλασσινό αλάτι.'},
      {s:'ΝΤΕΜΗΣ',t:'Φτάσαμε, παιδιά. Αυτό είναι το σπίτι μας για το Σαββατοκύριακο.'},
      {s:'ΑΙΑΣ',t:'Τέλειο! Πάμε κατευθείαν στο λιμάνι;'},
      {s:'ΚΛΕΙΩ',t:'Πρώτα ας αφήσουμε τις βαλίτσες. Θέλω να δω τη βεράντα.'},
    ],
  },
  terrace: {
    label: 'Η ΒΕΡΑΝΤΑ', bg: 'bg-terrace',
    charPos: {
      ntemis: { x: 320, y: 345 },
      ajax:   { x: 420, y: 350 },
      clio:   { x: 225, y: 350 },
    },
    objects: [
      { id:'harbor', x:140, y:120, w:280, h:100, label:'Το λιμάνι',
        verbs: { look:()=>{
          if(!state.flags.dolphins){state.flags.dolphins=1;return[
            {s:'',t:'Ο Κορινθιακός λάμπει σαν λιωμένο χρυσάφι. Ψαροκάικα κουνιούνται αργά στο λιμάνι.'},
            {s:'ΚΛΕΙΩ',t:'Μπαμπά, κοίτα! Δελφίνια!'},
            {s:'',t:'Τρία δελφίνια κόβουν βόλτες στο λιμάνι.'},
            {s:'ΑΙΑΣ',t:'Δελφίνια μέσα στο λιμάνι; Αυτό δεν είναι συνηθισμένο...'}];}
          return[{s:'',t:'Τα δελφίνια συνεχίζουν τους κύκλους τους. Σαν να φυλάνε κάτι.'}];}}},
      { id:'rooftops', x:30, y:80, w:130, h:100, label:'Σκεπές',
        verbs: { look:[{s:'',t:'Κεραμίδια, σκεπές, καμινάδες. Κάθε σπίτι κι ένας καπετάνιος κάποτε.'}] }},
      { id:'mountains', x:250, y:12, w:300, h:80, label:'Παρνασσός',
        verbs: { look:[{s:'',t:'Ο Παρνασσός στο βάθος. Οι Δελφοί κάπου εκεί πάνω.'},{s:'ΚΛΕΙΩ',t:'Οι Αμφικτίονες ξεκινούσαν από τους Δελφούς... Το Γαλαξίδι ήταν λιμάνι τους.'}] }},
      { id:'balustrade', x:90, y:240, w:370, h:40, label:'Κάγκελο',
        verbs: { look:[{s:'',t:'Πέτρινο κάγκελο με θέα ολόκληρο το Γαλαξίδι. Θα μπορούσες να κάτσεις εδώ ώρες.'}],
                 push:[{s:'ΚΛΕΙΩ',t:'Μπαμπά, μην ακουμπάς, φαίνεται παλιό!'}] }},
      { id:'flowerpot', x:10, y:220, w:65, h:60, label:'Γλάστρα',
        verbs: { look:[{s:'',t:'Γεράνια σε πήλινη γλάστρα. Τα χρώματα λάμπουν στο ηλιοβασίλεμα.'}] }},
    ],
    exits: [{ side:'left', target:'exterior', label:'← Σπίτι' }],
    entry: [
      {s:'',t:'Η θέα κόβει την ανάσα.'},
      {s:'ΚΛΕΙΩ',t:'Αυτό είναι το πιο όμορφο μέρος στον κόσμο.'},
      {s:'ΝΤΕΜΗΣ',t:'Καλωσορίσατε στο Γαλαξίδι.'},
    ],
  },
  kitchen: {
    label: 'Η ΚΟΥΖΙΝΑ', bg: 'bg-kitchen',
    charPos: {
      ntemis: { x: 350, y: 340 },
      ajax:   { x: 450, y: 345 },
      clio:   { x: 100, y: 345 },
    },
    objects: [
      { id:'figs', x:180, y:175, w:100, h:55, label:'Σύκα',
        verbs: { look:[{s:'',t:'Φρέσκα σύκα σε πήλινο μπολ. Η μυρωδιά γεμίζει το δωμάτιο.'}],
                 pick:[{s:'ΑΙΑΣ',t:'Μπαμπά, μπορώ να φάω ένα;'},{s:'ΝΤΕΜΗΣ',t:'Φυσικά.'}],
                 use:[{s:'',t:'Τρως ένα σύκο. Γλυκό σαν μέλι.'}] }},
      { id:'satchel', x:340, y:168, w:80, h:85, label:'Δερμάτινη τσάντα',
        verbs: {
          look:()=>{if(!state.flags.note)return[{s:'',t:'Μια παλιά δερμάτινη τσάντα πάνω στην καρέκλα. Δεν είναι δική σας.'},{s:'ΚΛΕΙΩ',t:'Μπαμπά, κοίτα — υπάρχει κάτι μέσα.'}];return[{s:'',t:'Η τσάντα είναι άδεια τώρα.'}];},
          open:()=>{if(!state.flags.note){state.flags.note=1;addInv({id:'note',label:'Σημείωμα'});return[{s:'',t:'Ανοίγεις την τσάντα. Μέσα βρίσκεις ένα σημείωμα.'},{s:'ΚΛΕΙΩ',t:'Διάβασέ το!'},{s:'',t:'«Σας περιμέναμε. Ελάτε στο λιμάνι απόψε. Τραπέζι για τρεις. — Γ.»'},{s:'ΑΙΑΣ',t:'Ποιος είναι ο «Γ.»;'},{s:'ΝΤΕΜΗΣ',t:'Και πώς ξέρει ότι είμαστε τρεις;'}];}return[{s:'',t:'Η τσάντα είναι πλέον άδεια.'}];},
          pick:[{s:'ΝΤΕΜΗΣ',t:'Δεν είναι δική μας. Ας κοιτάξω μέσα πρώτα.'}] }},
      { id:'window', x:455, y:50, w:95, h:115, label:'Παράθυρο',
        verbs: { look:[{s:'',t:'Απογευματινό φως μέσα από γαλάζια πατζούρια. Σκιές χορεύουν στον τοίχο.'}],
                 open:[{s:'',t:'Ανοίγεις τα πατζούρια. Μυρωδιά θυμαριού και τζιτζίκια.'}] }},
      { id:'pots', x:150, y:35, w:240, h:65, label:'Χάλκινα σκεύη',
        verbs: { look:[{s:'',t:'Χάλκινα σκεύη κρεμασμένα στον τοίχο. Κάποτε τάιζαν οικογένειες ναυτικών.'}] }},
      { id:'fireplace', x:0, y:75, w:95, h:145, label:'Τζάκι',
        verbs: { look:[{s:'',t:'Πέτρινο τζάκι. Μέσα υπάρχουν ακόμα στάχτες από τον τελευταίο χειμώνα.'}] }},
    ],
    exits: [{ side:'left', target:'exterior', label:'← Έξω' }],
    entry: [
      {s:'',t:'Η κουζίνα μυρίζει θυμάρι και παλιό ξύλο.'},
      {s:'ΚΛΕΙΩ',t:'Κοιτάξτε — κάποιος μας άφησε σύκα!'},
      {s:'ΑΙΑΣ',t:'Και κάτι πάνω στην καρέκλα... μια τσάντα;'},
    ],
  },


  // ── SCENE 2: THE PORT ──
  port: {
    label: 'ΤΟ ΛΙΜΑΝΙ', bg: 'bg-port',
    charPos: { ntemis: { x: 320, y: 340 }, ajax: { x: 400, y: 345 }, clio: { x: 240, y: 345 } },
    objects: [
      { id:'boats_port', x:120, y:80, w:200, h:100, label:'Ψαρόβαρκες',
        verbs: { look:[{s:'',t:'Χρωματιστά καΐκια δεμένα στα μπαλόνια. Η μπογιά ξεφλουδίζει — αλμύρα και χρόνια.'},{s:'ΑΙΑΣ',t:'Μπαμπά, μπορώ να πηδήξω σε κάποιο;'},{s:'ΝΤΕΜΗΣ',t:'Μπορείς να κοιτάξεις. Από εδώ.'}] }},
      { id:'bollards', x:380, y:250, w:80, h:60, label:'Δέστρες',
        verbs: { look:[{s:'',t:'Μεταλλικές δέστρες ψηλότερες από την Κλειώ. Φτιαγμένες για τρικάταρτα, όχι για βαρκούλες.'},{s:'ΚΛΕΙΩ',t:'Γιατί είναι τόσο μεγάλες;'},{s:'ΝΤΕΜΗΣ',t:'Γιατί κάποτε εδώ δένανε ιστιοφόρα πενήντα μέτρων.'}] }},
      { id:'nets', x:30, y:200, w:100, h:100, label:'Δίχτυα',
        verbs: { look:[{s:'',t:'Ένας ψαράς μπαλώνει τα δίχτυα του. Τα χέρια του κινούνται αυτόματα — πενήντα χρόνια πρακτική.'}],
                 talk:[{s:'ΝΤΕΜΗΣ',t:'Καλησπέρα! Πολύ ψάρι σήμερα;'},{s:'',t:'Ο ψαράς σηκώνει το βλέμμα. Τα μάτια του είναι γαλάζια σαν τον κόλπο.'},{s:'',t:'«Ψάρι λίγο. Ιστορίες πολλές. Κάτσε να σου πω.»'}] }},
      { id:'warehouses', x:450, y:60, w:150, h:140, label:'Αποθήκες',
        verbs: { look:[{s:'',t:'Πέτρινες αποθήκες με σιδερένιες πόρτες. Κάποτε γεμάτες σταφίδα και λάδι για εξαγωγή. Τώρα σιωπή.'}] }},
      { id:'seagulls', x:300, y:10, w:150, h:50, label:'Γλάροι',
        verbs: { look:[{s:'',t:'Γλάροι κράζουν πάνω από το λιμάνι. Αιώνιοι κάτοικοι.'},{s:'ΚΛΕΙΩ',t:'Αυτοί ξέρουν τα πάντα. Αν μιλούσαν...'}] }},
      { id:'cats', x:500, y:290, w:60, h:50, label:'Γάτες',
        verbs: { look:[{s:'',t:'Τρεις γάτες ξαπλωμένες στον ήλιο. Σε κοιτάνε με αδιαφορία.'},{s:'ΚΛΕΙΩ',t:'Πόσο τέλεια! Αυτή η πορτοκαλί μου αρέσει πολύ.'}] }},
    ],
    exits: [{ side:'right', target:'exterior', label:'Σπίτι →' }, { side:'left', target:'museum', label:'← Μουσείο' }],
    entry: [
      {s:'',t:'Το λιμάνι του Γαλαξειδίου. Μισοφέγγαρο από πέτρα, κυμαρισμένο φως, μυρωδιά αλμύρας.'},
      {s:'ΑΙΑΣ',t:'Αυτό το λιμάνι φαίνεται τεράστιο για τόσο μικρό χωριό.'},
      {s:'ΝΤΕΜΗΣ',t:'Γιατί κάποτε δεν ήταν μικρό χωριό. Ήταν ναυτική δύναμη.'},
      {s:'ΚΛΕΙΩ',t:'Τριακόσια καράβια, μπαμπά. Το διάβασα.'},
    ],
  },

  // ── SCENE 3: THE NAUTICAL MUSEUM ──
  museum: {
    label: 'ΤΟ ΝΑΥΤΙΚΟ ΜΟΥΣΕΙΟ', bg: 'bg-museum',
    charPos: { ntemis: { x: 320, y: 345 }, ajax: { x: 420, y: 348 }, clio: { x: 200, y: 348 } },
    objects: [
      { id:'model_ship', x:20, y:100, w:180, h:150, label:'Μοντέλο ιστιοφόρου',
        verbs: { look:[{s:'',t:'Ένα πανέμορφο μοντέλο τρικάταρτου μέσα σε γυάλινη βιτρίνα. Κάθε λεπτομέρεια τέλεια.'},{s:'ΚΛΕΙΩ',t:'Κοιτάξτε τα πανιά! Ένα-ένα ραμμένα.'},{s:'',t:'Η πινακίδα γράφει: «Σκούνα Χρυσούλα, 1904 — το τελευταίο ιστιοφόρο του Γαλαξειδίου.»'}] }},
      { id:'steamship', x:380, y:100, w:180, h:150, label:'Ατμόπλοιο',
        verbs: { look:[{s:'',t:'Μια γωνιά αφιερωμένη στα ατμόπλοια. Ένα σιδερένιο μοντέλο, μικρότερο, λιγότερο εντυπωσιακό.'},{s:'ΝΤΕΜΗΣ',t:'Αυτό ήταν το μέλλον. Και το Γαλαξίδι δεν το είδε.'},{s:'ΑΙΑΣ',t:'Γιατί; Ήταν χαζοί;'},{s:'ΝΤΕΜΗΣ',t:'Όχι. Ήταν οι καλύτεροι στα πανιά. Γι\u0027 αυτό ακριβώς δεν άλλαξαν.'}] }},
      { id:'portraits_mus', x:200, y:20, w:180, h:100, label:'Πορτρέτα καπεταναίων',
        verbs: { look:[{s:'',t:'Πορτρέτα σε χρυσές κορνίζες. Σοβαρά πρόσωπα, κομψά μουστάκια, μάτια που έχουν δει θάλασσα.'},{s:'ΚΛΕΙΩ',t:'Αυτός μοιάζει λίγο με τον μπαμπά.'},{s:'ΑΙΑΣ',t:'Ε, λίγο μόνο.'},{s:'ΝΤΕΜΗΣ',t:'Ευχαριστώ, νομίζω.'}] }},
      { id:'instruments', x:30, y:310, w:150, h:60, label:'Ναυτικά όργανα',
        verbs: { look:[{s:'',t:'Πυξίδες, εξάντες, χάρτες. Τα εργαλεία που οδηγούσαν τα πλοία σε κάθε γωνιά της Μεσογείου.'},{s:'ΚΛΕΙΩ',t:'Χωρίς GPS; Πώς;'},{s:'ΝΤΕΜΗΣ',t:'Αστέρια, εμπειρία, και θάρρος.'}] }},
      { id:'flags', x:100, y:5, w:400, h:40, label:'Σημαίες',
        verbs: { look:[{s:'',t:'Ναυτικές σημαίες κρέμονται από το ταβάνι. Ελληνική, γαλλική, ρωσική — τα λιμάνια που γνώριζαν.'}] }},
      { id:'map_table', x:350, y:300, w:120, h:60, label:'Χάρτης',
        verbs: { look:[{s:'',t:'Ένας παλιός χάρτης του Κορινθιακού ξαπλωμένος σε τραπέζι. Σημειώσεις με μελάνι — δρόμοι ναυσιπλοΐας.'},{s:'ΚΛΕΙΩ',t:'Μπαμπά, σημείωσε αυτό. Μπορεί να μας χρειαστεί.'}] }},
    ],
    exits: [{ side:'right', target:'port', label:'Λιμάνι →' }, { side:'left', target:'liotrivi', label:'← Λιοτρίβι' }],
    entry: [
      {s:'',t:'Το Ναυτικό Μουσείο του Γαλαξειδίου. Μυρωδιά ξύλου και παλιού χαρτιού.'},
      {s:'ΚΛΕΙΩ',t:'Πόσα μοντέλα! Θέλω να τα δω ΟΛΑ.'},
      {s:'ΑΙΑΣ',t:'Εγώ θέλω να δω αν έχει κανόνια.'},
      {s:'ΝΤΕΜΗΣ',t:'Σσσ. Μουσείο, παιδιά. Ησυχία.'},
    ],
  },

  // ── SCENE 4: LIOTRIVI BAR ──
  liotrivi: {
    label: 'ΛΙΟΤΡΙΒΙ', bg: 'bg-liotrivi',
    charPos: { ntemis: { x: 320, y: 340 }, ajax: { x: 400, y: 345 }, clio: { x: 240, y: 345 } },
    objects: [
      { id:'olive_press', x:10, y:80, w:140, h:180, label:'Ελαιοτριβείο',
        verbs: { look:[{s:'',t:'Το παλιό ελαιοτριβείο — πέτρα και ξύλο. Κάποτε έβγαζε λάδι, τώρα βγάζει ιστορίες.'},{s:'ΚΛΕΙΩ',t:'Φανταστείτε πόσα χέρια το γύρισαν.'}] }},
      { id:'bar_counter', x:200, y:80, w:180, h:120, label:'Μπαρ',
        verbs: { look:[{s:'',t:'Ξύλινο μπαρ γεμάτο μπουκάλια. Τσίπουρο, ρακή, κρασιά ντόπια. Φανάρια ρίχνουν ζεστό φως.'},{s:'ΑΙΑΣ',t:'Εγώ μπορώ να πάρω λεμονάδα;'}] }},
      { id:'window_liot', x:420, y:50, w:130, h:140, label:'Παράθυρο',
        verbs: { look:[{s:'',t:'Γαλάζια πατζούρια ανοιχτά στο φεγγαρόφωτο. Το λιμάνι λάμπει ασημί.'},{s:'ΚΛΕΙΩ',t:'Μαγικό. Σαν πίνακας ζωγραφικής.'}] }},
      { id:'photos_liot', x:150, y:20, w:100, h:60, label:'Παλιές φωτογραφίες',
        verbs: { look:[{s:'',t:'Ασπρόμαυρες φωτογραφίες στον τοίχο. Ψαράδες, καπετάνιοι, γυναίκες που περίμεναν.'},{s:'ΝΤΕΜΗΣ',t:'Κάθε φωτογραφία και μια ιστορία. Κάθε πρόσωπο και μια ζωή.'}] }},
      { id:'stools', x:280, y:250, w:80, h:60, label:'Σκαμπό',
        verbs: { look:[{s:'',t:'Ξύλινα σκαμπό τριγμένα από χρόνια. Πόσες κουβέντες έχουν ακούσει.'}],
                 use:[{s:'ΝΤΕΜΗΣ',t:'Κάτσε. Ξεκουράσου. Η νύχτα είναι μακριά.'}] }},
      { id:'checkered_floor', x:100, y:300, w:400, h:80, label:'Πλακάκια',
        verbs: { look:[{s:'',t:'Πλακάκια σε σκακιέρα — κίτρινα και καφέ. Λαμπυρίζουν στο φως των φαναριών.'}] }},
    ],
    exits: [{ side:'right', target:'museum', label:'Μουσείο →' }, { side:'left', target:'church', label:'← Εκκλησία' }],
    entry: [
      {s:'',t:'Το Λιοτρίβι. Πέτρα, ξύλο, ζεστό φως. Μυρωδιά τσίπουρου και ελιάς.'},
      {s:'ΑΙΑΣ',t:'Αυτό μοιάζει σαν πειρατικό καπηλειό!'},
      {s:'ΚΛΕΙΩ',t:'Μυρίζει ωραία. Σαν τη γιαγιά.'},
      {s:'ΝΤΕΜΗΣ',t:'Ελάτε, ας δούμε ποιος είναι εδώ.'},
    ],
  },

  // ── SCENE 5: THE CAVE ──
  cave: {
    label: 'ΤΟ ΣΠΗΛΑΙΟ — ΠΛΑΤΕΙΑ ΜΑΜΑ', bg: 'bg-cave',
    charPos: { ntemis: { x: 320, y: 350 }, ajax: { x: 420, y: 355 }, clio: { x: 220, y: 355 } },
    objects: [
      { id:'stone_door', x:160, y:40, w:250, h:250, label:'Πέτρινη πόρτα',
        verbs: { look:[{s:'',t:'Μια τεράστια πέτρινη πόρτα με δώδεκα κυκλικές εσοχές. Σχήμα τιμονιού.'},{s:'ΚΛΕΙΩ',t:'Δώδεκα θέσεις. Σαν ρολόι.'},{s:'ΑΙΑΣ',t:'Ή σαν τιμόνι καραβιού!'},{s:'ΝΤΕΜΗΣ',t:'Κάτι πρέπει να μπει σε κάθε εσοχή. Αλλά τι;'}],
                 open:[{s:'ΝΤΕΜΗΣ',t:'Δεν κουνιέται. Χρειαζόμαστε κάτι για τις εσοχές.'}],
                 use:[{s:'ΝΤΕΜΗΣ',t:'Δεν έχουμε αρκετά ακόμα. Πρέπει να ψάξουμε περισσότερο.'}] }},
      { id:'captain_marks', x:20, y:60, w:100, h:150, label:'Σημάδια στον τοίχο',
        verbs: { look:[{s:'',t:'Χαραγμένα σύμβολα στον βράχο. Νεκροκεφαλή, ψάρι, άγκυρα, μάτι.'},{s:'ΚΛΕΙΩ',t:'Αυτά δεν είναι πειρατικά. Είναι σημάδια καπεταναίων!'},{s:'ΝΤΕΜΗΣ',t:'Σωστά. Κάθε καπετάνιος είχε το δικό του σήμα.'}] }},
      { id:'cave_water', x:100, y:300, w:400, h:80, label:'Νερό',
        verbs: { look:[{s:'',t:'Τυρκουάζ νερό λάμπει από το φως της εισόδου. Κρυστάλλινο.'},{s:'ΑΙΑΣ',t:'Μπορώ να κολυμπήσω;'},{s:'ΝΤΕΜΗΣ',t:'Όχι τώρα, Αία.'}] }},
      { id:'stalactites', x:150, y:0, w:300, h:40, label:'Σταλακτίτες',
        verbs: { look:[{s:'',t:'Σταλακτίτες κρέμονται σαν δάχτυλα. Χιλιάδες χρόνια σε κάθε σταγόνα.'}] }},
      { id:'barrel_cave', x:0, y:200, w:60, h:80, label:'Βαρέλι',
        verbs: { look:[{s:'',t:'Ένα σάπιο βαρέλι. Πόσα χρόνια εδώ μέσα;'}],
                 open:[{s:'',t:'Άδειο, εκτός από αλμύρα και σκόνη.'}] }},
    ],
    exits: [{ side:'right', target:'church', label:'Έξοδος →' }],
    entry: [
      {s:'',t:'Σκοτάδι, υγρασία, και ένα αίσθημα μυστηρίου. Δαυλοί φωτίζουν τον χώρο.'},
      {s:'ΚΛΕΙΩ',t:'Μπαμπά... αυτό δεν μοιάζει φυσικό σπήλαιο.'},
      {s:'ΑΙΑΣ',t:'Η πόρτα! Κοιτάξτε αυτή την πόρτα!'},
      {s:'ΝΤΕΜΗΣ',t:'Δώδεκα εσοχές. Κάτι μας λείπει.'},
    ],
  },

  // ── SCENE 6: CHURCH OF AGIOS NIKOLAOS ──
  church: {
    label: 'ΑΓΙΟΣ ΝΙΚΟΛΑΟΣ', bg: 'bg-church',
    charPos: { ntemis: { x: 300, y: 340 }, ajax: { x: 390, y: 345 }, clio: { x: 210, y: 345 } },
    objects: [
      { id:'fountain', x:200, y:180, w:130, h:140, label:'Σιντριβάνι',
        verbs: { look:[{s:'',t:'Πέτρινο σιντριβάνι στην πλατεία. Το νερό τρέχει αθόρυβα.'},{s:'ΚΛΕΙΩ',t:'Ρίχνω ένα νόμισμα;'},{s:'ΝΤΕΜΗΣ',t:'Γιατί όχι; Κάνε μια ευχή.'}] }},
      { id:'church_dome', x:250, y:10, w:160, h:120, label:'Εκκλησία',
        verbs: { look:[{s:'',t:'Ο Άγιος Νικόλαος — προστάτης των ναυτικών. Ο τρούλος λάμπει κόκκινος στον ήλιο.'},{s:'ΝΤΕΜΗΣ',t:'Κάθε καπετάνιος προσευχόταν εδώ πριν φύγει. Και η οικογένειά του μετά.'}] }},
      { id:'bougainvillea_ch', x:0, y:60, w:90, h:180, label:'Μπουκαμβίλιες',
        verbs: { look:[{s:'',t:'Φούξια μπουκαμβίλιες σκεπάζουν τον τοίχο. Χρώμα που αψηφά τον χρόνο.'}] }},
      { id:'cat_church', x:420, y:300, w:60, h:40, label:'Γάτα',
        verbs: { look:[{s:'',t:'Μια πορτοκαλί γάτα κοιμάται αράχτη στα πλακάκια.'},{s:'ΚΛΕΙΩ',t:'Την ξαναβρήκα! Αυτή είναι η ίδια από το λιμάνι.'}],
                 talk:[{s:'ΚΛΕΙΩ',t:'Γεια σου, μικρούλα. Με ακολουθείς;'},{s:'',t:'Η γάτα νιαουρίζει απαλά.'}] }},
      { id:'benches', x:50, y:270, w:120, h:50, label:'Παγκάκια',
        verbs: { look:[{s:'',t:'Πέτρινα παγκάκια στη σκιά. Γέροι κάθονταν εδώ κάθε απόγευμα, εδώ και δεκαετίες.'}] }},
      { id:'pots_church', x:480, y:180, w:80, h:100, label:'Γλάστρες',
        verbs: { look:[{s:'',t:'Γλάστρες με γεράνια και λουλούδια. Κάποιος φροντίζει αυτή την πλατεία με αγάπη.'}] }},
    ],
    exits: [{ side:'right', target:'liotrivi', label:'Λιοτρίβι →' }, { side:'left', target:'cave', label:'← Σπήλαιο' }],
    entry: [
      {s:'',t:'Η πλατεία του Αγίου Νικολάου. Ησυχία, λουλούδια, και ήχος νερού.'},
      {s:'ΚΛΕΙΩ',t:'Τι ωραία πλατεία! Και γάτα!'},
      {s:'ΑΙΑΣ',t:'Πάλι γάτα;'},
      {s:'ΝΤΕΜΗΣ',t:'Ο Άγιος Νικόλαος. Προστάτης των ναυτικών. Κατάλληλος για το Γαλαξίδι.'},
    ],
  },

  // ── SCENE 7: THE WINDMILL ──
  windmill: {
    label: 'Ο ΜΥΛΟΣ', bg: 'bg-windmill',
    charPos: { ntemis: { x: 350, y: 345 }, ajax: { x: 440, y: 348 }, clio: { x: 260, y: 348 } },
    objects: [
      { id:'telescope', x:60, y:140, w:80, h:120, label:'Τηλεσκόπιο',
        verbs: { look:[{s:'',t:'Ένα παλιό ορειχάλκινο τηλεσκόπιο. Κάποιος το άφησε εδώ;'},{s:'ΚΛΕΙΩ',t:'Αφήστε με να κοιτάξω!'}],
                 use:[{s:'ΚΛΕΙΩ',t:'Βλέπω... το λιμάνι! Και κάτι στο νερό...'},{s:'ΑΙΑΣ',t:'Τι; Τι βλέπεις;'},{s:'ΚΛΕΙΩ',t:'Ένα σημάδι στην προβλήτα. Σαν αστέρι.'},{s:'ΝΤΕΜΗΣ',t:'Σημείωσέ το, Κλειώ.'}] }},
      { id:'panorama', x:0, y:20, w:640, h:100, label:'Πανόραμα',
        verbs: { look:[{s:'',t:'Η θέα κόβει την ανάσα. Ολόκληρο το Γαλαξίδι, ο κόλπος, τα βουνά. Από εδώ βλέπεις τα πάντα.'},{s:'ΑΙΑΣ',t:'Μπαμπά, βλέπω μέχρι την Ιτέα!'},{s:'ΚΛΕΙΩ',t:'Και τους Δελφούς! Εκεί πάνω!'}] }},
      { id:'ruins', x:470, y:130, w:120, h:130, label:'Ερείπια',
        verbs: { look:[{s:'',t:'Πέτρινα ερείπια — ίσως ο παλιός μύλος. Αψίδα ακόμα όρθια, αψηφώντας τον χρόνο.'}] }},
      { id:'wildflowers', x:150, y:250, w:200, h:80, label:'Αγριολούλουδα',
        verbs: { look:[{s:'',t:'Παπαρούνες, μαργαρίτες, θυμάρι. Ο λόφος μυρίζει μέλι και καλοκαίρι.'},{s:'ΚΛΕΙΩ',t:'Θέλω να ζωγραφίσω αυτά.'}] }},
      { id:'stone_path_wm', x:300, y:300, w:200, h:60, label:'Μονοπάτι',
        verbs: { look:[{s:'',t:'Πέτρινο καλντερίμι ανεβαίνει τον λόφο. Λειασμένο από πόδια αιώνων.'}] }},
    ],
    exits: [{ side:'right', target:'graveyard', label:'Νεκροταφείο →' }, { side:'left', target:'church', label:'← Εκκλησία' }],
    entry: [
      {s:'',t:'Η κορυφή του λόφου. Αέρας, φως, και θέα που δεν τελειώνει.'},
      {s:'ΑΙΑΣ',t:'ΤΕΛΕΙΟ! Βλέπω τα πάντα από εδώ!'},
      {s:'ΚΛΕΙΩ',t:'Μπαμπά, κοίτα — ένα τηλεσκόπιο!'},
      {s:'ΝΤΕΜΗΣ',t:'Ένα σημείο παρατήρησης. Κάποιος παρακολουθούσε τα πλοία από εδώ.'},
    ],
  },

  // ── SCENE 8: THE BOAT (ELPIDA) ──
  boat: {
    label: 'ΤΟ ΚΑΡΑΒΙ — ΕΛΠΙΔΑ', bg: 'bg-boat',
    charPos: { ntemis: { x: 350, y: 340 }, ajax: { x: 430, y: 345 }, clio: { x: 270, y: 345 } },
    objects: [
      { id:'nameplate', x:50, y:310, w:120, h:40, label:'ΕΛΠΙΔΑ',
        verbs: { look:[{s:'',t:'«ΕΛΠΙΔΑ» — χρυσά γράμματα σε ξεφλουδισμένο μπλε ξύλο.'},{s:'ΝΤΕΜΗΣ',t:'Ελπίδα. Πάντα υπάρχει ελπίδα.'}] }},
      { id:'chapel', x:30, y:60, w:150, h:150, label:'Παρεκκλήσι',
        verbs: { look:[{s:'',t:'Ένα μικρό λευκό παρεκκλήσι πάνω στον βράχο. Ελληνική σημαία κυματίζει.'},{s:'ΚΛΕΙΩ',t:'Ποιος πάει εκεί πάνω για λειτουργία;'},{s:'ΝΤΕΜΗΣ',t:'Οι ψαράδες. Πριν και μετά το ταξίδι.'}] }},
      { id:'sunset_sea', x:200, y:20, w:400, h:120, label:'Ηλιοβασίλεμα',
        verbs: { look:[{s:'',t:'Ο ήλιος βυθίζεται στον Κορινθιακό. Χρυσό, πορτοκαλί, ροζ. Τα βουνά γίνονται σκιές.'},{s:'',t:'Κανείς δεν μιλάει. Δεν χρειάζεται.'}] }},
      { id:'rope', x:350, y:250, w:80, h:60, label:'Σχοινιά',
        verbs: { look:[{s:'',t:'Σχοινιά τυλιγμένα στο κατάστρωμα. Μυρίζουν θάλασσα και πεύκο.'}],
                 use:[{s:'ΑΙΑΣ',t:'Ξέρω κόμπους! Ο παππούς μου έμαθε.'},{s:'ΝΤΕΜΗΣ',t:'Δείξε μας.'}] }},
      { id:'lifebuoy', x:460, y:290, w:60, h:60, label:'Σωσίβιο',
        verbs: { look:[{s:'',t:'Πορτοκαλί σωσίβιο. Λευκά γράμματα: ΕΛΠΙΔΑ — ΓΑΛΑΞΙΔΙ.'}] }},
      { id:'galaxidi_view', x:400, y:80, w:200, h:100, label:'Γαλαξίδι στο βάθος',
        verbs: { look:[{s:'',t:'Το Γαλαξίδι λάμπει στον ήλιο του δειλινού. Σπίτια, εκκλησίες, το λιμάνι — σαν μακέτα.'},{s:'ΚΛΕΙΩ',t:'Από εδώ φαίνεται σαν παραμύθι.'}] }},
    ],
    exits: [{ side:'left', target:'port', label:'← Λιμάνι' }],
    entry: [
      {s:'',t:'Η Ελπίδα πλέει αργά στον Κορινθιακό. Ο κόσμος σταμάτησε.'},
      {s:'ΚΛΕΙΩ',t:'Αυτό... αυτό είναι τέλειο.'},
      {s:'ΑΙΑΣ',t:'Μπαμπά, μπορούμε να μείνουμε για πάντα εδώ;'},
      {s:'ΝΤΕΜΗΣ',t:'Για λίγο ακόμα. Κοιτάξτε τον ήλιο.'},
    ],
  },

  // ── SCENE 9: THE GRAVEYARD ──
  graveyard: {
    label: 'ΤΟ ΝΕΚΡΟΤΑΦΕΙΟ', bg: 'bg-graveyard',
    charPos: { ntemis: { x: 300, y: 345 }, ajax: { x: 390, y: 348 }, clio: { x: 210, y: 348 } },
    objects: [
      { id:'headstones', x:100, y:100, w:200, h:150, label:'Ταφόπλακες',
        verbs: { look:[{s:'',t:'Μαρμάρινοι σταυροί και πλάκες. Ονόματα καπεταναίων: Τσώνης, Ρήγας, Μαμάς, Χρυσοβαλάντου.'},{s:'ΚΛΕΙΩ',t:'Κάθε πέτρα και ένα ταξίδι.'},{s:'ΝΤΕΜΗΣ',t:'Κάθε πέτρα και μια οικογένεια που περίμενε.'}] }},
      { id:'cypress', x:0, y:20, w:60, h:300, label:'Κυπαρίσσια',
        verbs: { look:[{s:'',t:'Κυπαρίσσια ψηλά σαν κατάρτια. Φρουροί αιώνιοι.'}] }},
      { id:'poppies_gr', x:300, y:200, w:150, h:100, label:'Παπαρούνες',
        verbs: { look:[{s:'',t:'Κόκκινες παπαρούνες ανάμεσα στους τάφους. Η ζωή εκεί που αναπαύεται ο θάνατος.'},{s:'ΚΛΕΙΩ',t:'Μπαμπά, δεν είναι τρομακτικό. Είναι... ωραίο.'}] }},
      { id:'sea_view_gr', x:350, y:30, w:250, h:100, label:'Θέα στη θάλασσα',
        verbs: { look:[{s:'',t:'Η θάλασσα λάμπει χρυσή από το ηλιοβασίλεμα. Ακόμα και μετά θάνατον, οι καπετάνιοι βλέπουν τη θάλασσα.'},{s:'ΑΙΑΣ',t:'Τους έβαλαν εδώ επίτηδες. Να βλέπουν.'}] }},
      { id:'sailboat_dist', x:500, y:80, w:60, h:40, label:'Ιστιοφόρο στο βάθος',
        verbs: { look:[{s:'',t:'Ένα ιστιοφόρο στον ορίζοντα. Σαν φάντασμα του παρελθόντος.'}] }},
      { id:'path_stones_gr', x:150, y:280, w:200, h:60, label:'Πέτρινο μονοπάτι',
        verbs: { look:[{s:'',t:'Πλακόστρωτο μονοπάτι ανάμεσα στους τάφους. Λειασμένο από χιλιάδες επισκέψεις.'}] }},
    ],
    exits: [{ side:'left', target:'windmill', label:'← Μύλος' }],
    entry: [
      {s:'',t:'Το παλιό νεκροταφείο. Θέα στη θάλασσα, μυρωδιά θυμαριού, ησυχία.'},
      {s:'ΚΛΕΙΩ',t:'Μπαμπά... δεν μου αρέσουν τα νεκροταφεία.'},
      {s:'ΝΤΕΜΗΣ',t:'Αυτό δεν είναι τρομακτικό. Είναι γεμάτο ιστορίες.'},
      {s:'ΑΙΑΣ',t:'Κοίτα — βλέπεις τη θάλασσα από κάθε τάφο. Αυτό ήθελαν.'},
    ],
  },

};

// ════════════════════════════════════════════════════════════
// INTRO PAGES
// ════════════════════════════════════════════════════════════
const introPages = [
  'Γαλαξίδι.\nΤέλη Σεπτεμβρίου, 2026.',
  'Ένα μικρό λιμάνι\nστον Κορινθιακό κόλπο.\n\nΕκεί που κάποτε ξεκινούσαν\nτα πιο τολμηρά καράβια\nτης Ελλάδας.',
  'Ο Ντέμης έφτασε\nμε τα δυο του παιδιά\nγια ένα ήσυχο\nΣαββατοκύριακο.\n\nΤουλάχιστον,\nαυτό νόμιζε.',
];

// ════════════════════════════════════════════════════════════
// EASING
// ════════════════════════════════════════════════════════════
function easeInOutCubic(t) { return t < .5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3)/2; }

// ════════════════════════════════════════════════════════════
// COORDINATE CONVERSION
// ════════════════════════════════════════════════════════════
function screenToGame(sx, sy) {
  const rect = CVS.getBoundingClientRect();
  const scaleX = GW / rect.width;
  const scaleY = GH / rect.height;
  return { x: (sx - rect.left) * scaleX, y: (sy - rect.top) * scaleY };
}

// ════════════════════════════════════════════════════════════
// DUST PARTICLES (canvas-drawn)
// ════════════════════════════════════════════════════════════
const particles = [];
function initParticles() {
  particles.length = 0;
  const isExterior = (state.scene === 'exterior' || state.scene === 'terrace');
  const count = isExterior ? 30 : 20;
  for (let i = 0; i < count; i++) {
    if (isExterior) {
      // Golden motes drifting in the light shaft (upper-right to lower-left)
      const startX = GW * 0.4 + Math.random() * GW * 0.6;
      particles.push({
        x: startX,
        y: Math.random() * GH * 0.7,
        vx: -0.05 - Math.random() * 0.15,
        vy: 0.03 + Math.random() * 0.08,
        size: 0.6 + Math.random() * 1.5,
        alpha: 0,
        maxAlpha: 0.15 + Math.random() * 0.25,
        life: Math.random() * 700,
        maxLife: 600 + Math.random() * 500,
        glow: Math.random() < 0.3,
      });
    } else {
      particles.push({
        x: Math.random() * GW,
        y: 60 + Math.random() * 240,
        vx: 0.1 + Math.random() * 0.25,
        vy: -0.05 - Math.random() * 0.12,
        size: 0.8 + Math.random() * 1.8,
        alpha: 0,
        maxAlpha: 0.12 + Math.random() * 0.18,
        life: Math.random() * 700,
        maxLife: 500 + Math.random() * 400,
      });
    }
  }
}

function updateParticles() {
  for (const p of particles) {
    p.x += p.vx;
    p.y += p.vy;
    p.life++;
    const prog = p.life / p.maxLife;
    if (prog < 0.3) p.alpha = p.maxAlpha * (prog / 0.3) * (prog / 0.3); // quadratic fade-in
    else if (prog > 0.7) { const f = (prog - 0.7) / 0.3; p.alpha = p.maxAlpha * (1 - f * f); } // quadratic fade-out
    else p.alpha = p.maxAlpha;
    if (p.life >= p.maxLife || p.x > GW + 10 || p.x < -10 || p.y < -10 || p.y > GH + 10) {
      const isExterior = (state.scene === 'exterior' || state.scene === 'terrace');
      if (isExterior) {
        p.x = GW * 0.4 + Math.random() * GW * 0.6;
        p.y = -5 + Math.random() * 30;
      } else {
        p.x = -5 + Math.random() * 20;
        p.y = 80 + Math.random() * 200;
      }
      p.life = 0;
      p.alpha = 0;
    }
  }
}

function drawParticles() {
  for (const p of particles) {
    if (p.alpha <= 0) continue;
    ctx.save();
    ctx.globalAlpha = p.alpha;
    if (p.glow) {
      // Glowing golden mote
      ctx.shadowColor = 'rgba(255,200,60,0.6)';
      ctx.shadowBlur = 4;
      ctx.fillStyle = '#FFD860';
    } else {
      ctx.fillStyle = '#D4A03C';
    }
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

// ════════════════════════════════════════════════════════════
// SCENE AMBIENCE — per-scene visual & audio layers
// ════════════════════════════════════════════════════════════


// ── Sea Shimmer ──
function drawSeaShimmer(tick) {
  const t = tick * 0.02;
  ctx.save();
  // Water area on exterior scene (right side, harbor)
  for (let ry = 75; ry < 140; ry += 2) {
    const d = (ry - 75) / 65;
    // Golden reflections
    ctx.fillStyle = `rgba(230,180,60,${0.04 + d * 0.03})`;
    for (let rx = 360; rx < 580; rx += 4) {
      const shimmer = Math.sin(rx * 0.05 + ry * 0.08 + t * 1.8) * 0.5 + 0.5;
      if (shimmer > 0.55) {
        ctx.fillRect(rx, ry, 2 + Math.floor(shimmer * 3), 1);
      }
    }
    // Dark wave troughs
    ctx.fillStyle = `rgba(0,20,40,${0.03 + d * 0.02})`;
    for (let rx = 360; rx < 580; rx += 6) {
      if (Math.sin(rx * 0.07 + ry * 0.12 - t * 1.1) > 0.4) {
        ctx.fillRect(rx, ry + 1, 3, 1);
      }
    }
  }
  ctx.restore();
}

// ── Bougainvillea Petals ──
const petals = [];
function initPetals() {
  petals.length = 0;
  for (let i = 0; i < 12; i++) {
    petals.push(newPetal());
  }
}
function newPetal() {
  return {
    x: 175 + Math.random() * 150,
    y: 20 + Math.random() * 40,
    vx: 0.1 + Math.random() * 0.3,
    vy: 0.2 + Math.random() * 0.4,
    rot: Math.random() * Math.PI * 2,
    rotV: (Math.random() - 0.5) * 0.05,
    size: 1.5 + Math.random() * 1.5,
    wobble: Math.random() * Math.PI * 2,
    wobbleSpeed: 0.02 + Math.random() * 0.02,
    alpha: 0.5 + Math.random() * 0.4,
    color: Math.random() < 0.7 ? '#E0489A' : (Math.random() < 0.5 ? '#D03878' : '#C83068'),
  };
}
function updatePetals() {
  for (const p of petals) {
    p.wobble += p.wobbleSpeed;
    p.x += p.vx + Math.sin(p.wobble) * 0.3;
    p.y += p.vy;
    p.rot += p.rotV;
    if (p.y > 380 || p.x > GW + 10) {
      Object.assign(p, newPetal());
    }
  }
}
function drawPetals() {
  for (const p of petals) {
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(p.rot);
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.ellipse(0, 0, p.size, p.size * 0.5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}


// ── Orange Cat ──
const cat = { x: 95, y: 243, phase: 0, blinkTimer: 0, blinking: false, tailPhase: 0 };
function updateCat(dt) {
  cat.phase += dt;
  cat.tailPhase += dt * 2.5;
  cat.blinkTimer += dt;
  if (!cat.blinking && cat.blinkTimer > 3 + Math.random() * 4) {
    cat.blinking = true;
    cat.blinkTimer = 0;
  }
  if (cat.blinking && cat.blinkTimer > 0.15) {
    cat.blinking = false;
    cat.blinkTimer = 0;
  }
}
function drawCat() {
  const cx = cat.x, cy = cat.y;
  ctx.save();
  ctx.imageSmoothingEnabled = false;
  // Body (sitting loaf shape)
  ctx.fillStyle = '#D08030';
  ctx.fillRect(cx, cy, 10, 6);       // body
  ctx.fillRect(cx + 1, cy - 1, 8, 1); // back curve
  // Head
  ctx.fillRect(cx + 8, cy - 4, 6, 5); // head
  ctx.fillStyle = '#E09040';
  ctx.fillRect(cx + 9, cy - 3, 4, 3); // face highlight
  // Ears
  ctx.fillStyle = '#D08030';
  ctx.fillRect(cx + 8, cy - 6, 2, 2);  // left ear
  ctx.fillRect(cx + 12, cy - 6, 2, 2); // right ear
  ctx.fillStyle = '#E8A060';
  ctx.fillRect(cx + 9, cy - 5, 1, 1);  // inner ear
  ctx.fillRect(cx + 12, cy - 5, 1, 1);
  // Eyes
  if (!cat.blinking) {
    ctx.fillStyle = '#40A040';
    ctx.fillRect(cx + 9, cy - 2, 1, 1);
    ctx.fillRect(cx + 12, cy - 2, 1, 1);
  } else {
    ctx.fillStyle = '#D08030';
    ctx.fillRect(cx + 9, cy - 2, 1, 1);
    ctx.fillRect(cx + 12, cy - 2, 1, 1);
  }
  // Nose
  ctx.fillStyle = '#E07890';
  ctx.fillRect(cx + 11, cy - 1, 1, 1);
  // Stripes
  ctx.fillStyle = '#B06820';
  ctx.fillRect(cx + 2, cy, 1, 5);
  ctx.fillRect(cx + 5, cy, 1, 5);
  ctx.fillRect(cx + 10, cy - 4, 1, 2);
  // Tail (swishing)
  const tailSwing = Math.sin(cat.tailPhase) * 4;
  ctx.fillStyle = '#D08030';
  ctx.fillRect(cx - 1, cy + 3, 1, 1);
  ctx.fillRect(cx - 2, cy + 2 + tailSwing * 0.2, 1, 1);
  ctx.fillRect(cx - 3, cy + 1 + tailSwing * 0.4, 1, 1);
  ctx.fillRect(cx - 4, cy + tailSwing * 0.5, 1, 1);
  // Tip darker
  ctx.fillStyle = '#B06820';
  ctx.fillRect(cx - 4, cy + tailSwing * 0.5, 1, 1);
  // Paws
  ctx.fillStyle = '#E0A060';
  ctx.fillRect(cx + 1, cy + 5, 2, 1);
  ctx.fillRect(cx + 7, cy + 5, 2, 1);
  ctx.restore();
}

// ── Golden Hour Light Shaft ──
function drawLightShaft(tick) {
  ctx.save();
  const t = tick * 0.005;
  // Diagonal warm light from upper-right
  const lg = ctx.createLinearGradient(GW, 0, GW * 0.3, GH * 0.6);
  lg.addColorStop(0, `rgba(255,200,80,${0.04 + Math.sin(t) * 0.01})`);
  lg.addColorStop(0.4, `rgba(255,180,60,${0.02 + Math.sin(t + 1) * 0.005})`);
  lg.addColorStop(1, 'rgba(255,180,60,0)');
  ctx.fillStyle = lg;
  ctx.fillRect(0, 0, GW, GH);
  // Light beam rays (subtle streaks)
  ctx.globalAlpha = 0.015 + Math.sin(t * 0.7) * 0.005;
  ctx.fillStyle = '#FFD060';
  ctx.beginPath();
  ctx.moveTo(GW, 0);
  ctx.lineTo(GW * 0.55, GH * 0.7);
  ctx.lineTo(GW * 0.65, GH * 0.7);
  ctx.lineTo(GW, 20);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(GW - 40, 0);
  ctx.lineTo(GW * 0.4, GH * 0.5);
  ctx.lineTo(GW * 0.48, GH * 0.5);
  ctx.lineTo(GW - 10, 0);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

// ── Heat Haze ──
function drawHeatHaze(tick) {
  ctx.save();
  const t = tick * 0.03;
  ctx.globalAlpha = 0.02;
  for (let x = 50; x < GW - 50; x += 8) {
    const shift = Math.sin(x * 0.05 + t) * 1.5;
    ctx.fillStyle = '#FFD090';
    ctx.fillRect(x, 360 + shift, 4, 1);
  }
  ctx.restore();
}

// ── Ambient Sound Manager (Web Audio API — procedural, no files) ──
let audioCtx = null;
const ambientSounds = {
  wavesNode: null, cicadasNode: null, bellPlayed: false,
  gullTimer: 0, gullInterval: 10, masterGain: null, active: false,
};

function getAudioCtx() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    ambientSounds.masterGain = audioCtx.createGain();
    ambientSounds.masterGain.gain.value = 1;
    ambientSounds.masterGain.connect(audioCtx.destination);
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}

function createWavesLoop() {
  const ctx = getAudioCtx();
  const bufferSize = ctx.sampleRate * 4;
  const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
  const data = buffer.getChannelData(0);
  let last = 0;
  for (let i = 0; i < bufferSize; i++) {
    const white = Math.random() * 2 - 1;
    last = (last + (0.02 * white)) / 1.02;
    const waveMod = 0.5 + 0.5 * Math.sin(i / ctx.sampleRate * Math.PI * 0.3);
    data[i] = last * 3.5 * waveMod;
  }
  const src = ctx.createBufferSource();
  src.buffer = buffer;
  src.loop = true;
  const lp = ctx.createBiquadFilter();
  lp.type = 'lowpass';
  lp.frequency.value = 400;
  const gain = ctx.createGain();
  gain.gain.value = 0.12;
  src.connect(lp);
  lp.connect(gain);
  gain.connect(ambientSounds.masterGain);
  src.start();
  return { src, gain };
}

function createCicadasLoop() {
  const ctx = getAudioCtx();
  const merger = ctx.createGain();
  merger.gain.value = 0;
  const oscs = [];
  const freqs = [4200, 4800, 5100, 5600, 6200];
  for (const f of freqs) {
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = f + (Math.random() - 0.5) * 200;
    const am = ctx.createGain();
    const lfo = ctx.createOscillator();
    lfo.frequency.value = 8 + Math.random() * 12;
    const lfoGain = ctx.createGain();
    lfoGain.gain.value = 0.5;
    lfo.connect(lfoGain);
    lfoGain.connect(am.gain);
    am.gain.value = 0.5;
    osc.connect(am);
    am.connect(merger);
    osc.start();
    lfo.start();
    oscs.push({ osc, lfo });
  }
  const bp = ctx.createBiquadFilter();
  bp.type = 'bandpass';
  bp.frequency.value = 5000;
  bp.Q.value = 2;
  const gain = ctx.createGain();
  gain.gain.value = 0.04;
  merger.connect(bp);
  bp.connect(gain);
  gain.connect(ambientSounds.masterGain);
  return { oscs, merger, gain };
}

function playSeagullCry() {
  const ctx = getAudioCtx();
  const now = ctx.currentTime;
  const osc = ctx.createOscillator();
  osc.type = 'sine';
  const baseF = 1800 + Math.random() * 600;
  osc.frequency.setValueAtTime(baseF, now);
  osc.frequency.linearRampToValueAtTime(baseF * 0.6, now + 0.15);
  osc.frequency.linearRampToValueAtTime(baseF * 1.1, now + 0.35);
  osc.frequency.linearRampToValueAtTime(baseF * 0.5, now + 0.6);
  const osc2 = ctx.createOscillator();
  osc2.type = 'sine';
  osc2.frequency.setValueAtTime(baseF * 1.5, now);
  osc2.frequency.linearRampToValueAtTime(baseF * 0.9, now + 0.15);
  osc2.frequency.linearRampToValueAtTime(baseF * 1.6, now + 0.35);
  osc2.frequency.linearRampToValueAtTime(baseF * 0.75, now + 0.6);
  const vib = ctx.createOscillator();
  vib.frequency.value = 20 + Math.random() * 15;
  const vibGain = ctx.createGain();
  vibGain.gain.value = 40;
  vib.connect(vibGain);
  vibGain.connect(osc.frequency);
  vibGain.connect(osc2.frequency);
  const env = ctx.createGain();
  env.gain.setValueAtTime(0, now);
  env.gain.linearRampToValueAtTime(0.06 + Math.random() * 0.04, now + 0.05);
  env.gain.setValueAtTime(0.06, now + 0.35);
  env.gain.linearRampToValueAtTime(0, now + 0.7);
  const noiseLen = ctx.sampleRate;
  const noiseBuf = ctx.createBuffer(1, noiseLen, ctx.sampleRate);
  const nd = noiseBuf.getChannelData(0);
  for (let i = 0; i < noiseLen; i++) nd[i] = Math.random() * 2 - 1;
  const noiseSrc = ctx.createBufferSource();
  noiseSrc.buffer = noiseBuf;
  const noiseBP = ctx.createBiquadFilter();
  noiseBP.type = 'bandpass';
  noiseBP.frequency.value = 2000;
  noiseBP.Q.value = 3;
  const noiseGain = ctx.createGain();
  noiseGain.gain.setValueAtTime(0, now);
  noiseGain.gain.linearRampToValueAtTime(0.015, now + 0.05);
  noiseGain.gain.linearRampToValueAtTime(0, now + 0.7);
  noiseSrc.connect(noiseBP);
  noiseBP.connect(noiseGain);
  noiseGain.connect(ambientSounds.masterGain);
  osc.connect(env);
  osc2.connect(env);
  env.connect(ambientSounds.masterGain);
  osc.start(now);
  osc2.start(now);
  vib.start(now);
  noiseSrc.start(now);
  osc.stop(now + 0.75);
  osc2.stop(now + 0.75);
  vib.stop(now + 0.75);
  noiseSrc.stop(now + 0.75);
}

function playChurchBell() {
  const ctx = getAudioCtx();
  const now = ctx.currentTime;
  const partials = [1, 2.0, 2.98, 4.07, 5.2, 6.5];
  const baseF = 280;
  const mix = ctx.createGain();
  mix.gain.value = 0.12;
  for (let i = 0; i < partials.length; i++) {
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = baseF * partials[i];
    const g = ctx.createGain();
    const amp = 1 / (i + 1);
    const decay = 3 - i * 0.3;
    g.gain.setValueAtTime(amp, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + Math.max(0.5, decay));
    osc.connect(g);
    g.connect(mix);
    osc.start(now);
    osc.stop(now + 4);
  }
  mix.connect(ambientSounds.masterGain);
}

function initAmbientSound() {
  ambientSounds.gullTimer = 0;
  ambientSounds.gullInterval = 8 + Math.random() * 7;
}

function startSceneAmbience(sceneId) {
  if (sceneId === 'exterior' || sceneId === 'terrace') {
    try {
      if (!ambientSounds.wavesNode) {
        ambientSounds.wavesNode = createWavesLoop();
      }
      // Cicadas disabled

      if (!ambientSounds.bellPlayed && sceneId === 'exterior') {
        ambientSounds.bellPlayed = true;
        setTimeout(() => playChurchBell(), 2500);
      }
    } catch (e) { /* Web Audio not available */ }
    initPetals();
    ambientSounds.active = true;
  } else {
    stopSceneAmbience();
  }
}

function stopSceneAmbience() {
  if (ambientSounds.wavesNode) {
    try { ambientSounds.wavesNode.src.stop(); } catch (e) {}
    ambientSounds.wavesNode = null;
  }
  if (ambientSounds.cicadasNode) {
    try {
      for (const o of ambientSounds.cicadasNode.oscs) { o.osc.stop(); o.lfo.stop(); }
    } catch (e) {}
    ambientSounds.cicadasNode = null;
  }
  petals.length = 0;
  ambientSounds.active = false;
}

function updateAmbientSound(dt) {
  if (!ambientSounds.active) return;
  if (state.scene !== 'exterior' && state.scene !== 'terrace') return;
  ambientSounds.gullTimer += dt;
  if (ambientSounds.gullTimer >= ambientSounds.gullInterval) {
    ambientSounds.gullTimer = 0;
    ambientSounds.gullInterval = 8 + Math.random() * 7;
    // Seagull cries disabled — too synthetic
  }
}

// ── Master draw/update for scene ambience ──
function updateSceneAmbience(dt) {
  if (state.scene === 'exterior') {
    updatePetals();
    updateCat(dt);
    updateAmbientSound(dt);
  } else if (state.scene === 'terrace') {
    updateAmbientSound(dt);
  }
}

function drawSceneAmbience(tick) {
  if (state.scene === 'exterior') {
    drawSeaShimmer(tick);
    drawLightShaft(tick);
    drawPetals();
    drawCat();
    drawHeatHaze(tick);
  } else if (state.scene === 'terrace') {
    drawSeaShimmer(tick);
    drawLightShaft(tick);
  }
}

// ════════════════════════════════════════════════════════════
// CHARACTER RENDERING (ported from Galaxidi Adventure)
// ════════════════════════════════════════════════════════════
const CHAR_HEIGHTS = { ntemis: 118, ajax: 84, clio: 92 };

// Per-character anatomy: waist split ratio & max leg stride (pixels)
const WALK_ANATOMY = {
  ntemis: { waist: 0.62, stride: 7 },
  ajax:   { waist: 0.58, stride: 6 },
  clio:   { waist: 0.60, stride: 6 },
};

function drawSprite(who, gx, gy, dir, walking, frame, tick, frameOffset) {
  const img = CHAR_IMGS[who];
  if (!img || !img.complete || !img.naturalWidth) {
    drawFallbackPerson(gx, gy, who);
    return;
  }
  const sprW = img.naturalWidth;
  const sprH = img.naturalHeight;
  const anat = WALK_ANATOMY[who] || { waist: 0.60, stride: 6 };

  if (walking) {
    // ── WALK PHASE ──
    const walkPhase = frame * Math.PI * 3 + frameOffset * Math.PI / 3;
    const bob = -Math.abs(Math.sin(walkPhase)) * 3;
    const lean = dir * 0.025;
    const strideDir = Math.sin(walkPhase); // -1 to 1

    const waistY = Math.floor(sprH * anat.waist);
    const legH = sprH - waistY;
    const maxStride = anat.stride;

    // Ground shadow (stretches with stride)
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = '#4A3A28';
    const sw = sprW * 0.6 + Math.abs(strideDir) * 3;
    ctx.beginPath();
    ctx.ellipse(gx, gy + 3, sw, 3.5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.translate(gx, gy + bob);
    if (dir < 0) ctx.scale(-1, 1);
    ctx.rotate(lean);

    // ── UPPER BODY (slight counter-sway) ──
    const counterSway = -strideDir * 1.5;
    ctx.drawImage(img,
      0, 0, sprW, waistY,
      -sprW/2 + counterSway, -sprH, sprW, waistY
    );

    // ── BACK LEG (drawn first, darker, shifted opposite, lifted) ──
    const bandH = 2;
    ctx.save();
    ctx.globalAlpha = 0.7;
    for (let y = 0; y < legH; y += bandH) {
      const progress = y / Math.max(1, legH - 1);
      const backOff = -strideDir * maxStride * 0.7 * (0.3 + 0.7 * progress);
      const lift = Math.abs(strideDir) * 3 * progress;
      const h = Math.min(bandH, legH - y);
      ctx.drawImage(img,
        0, waistY + y, sprW, h,
        -sprW/2 + backOff, -sprH + waistY + y - lift, sprW, h
      );
    }
    ctx.restore();

    // ── FRONT LEG (on top, full brightness, shifted forward) ──
    for (let y = 0; y < legH; y += bandH) {
      const progress = y / Math.max(1, legH - 1);
      const frontOff = strideDir * maxStride * (0.3 + 0.7 * progress);
      const h = Math.min(bandH, legH - y);
      ctx.drawImage(img,
        0, waistY + y, sprW, h,
        -sprW/2 + frontOff, -sprH + waistY + y, sprW, h
      );
    }

    ctx.restore();

  } else {
    // ── IDLE ANIMATION ──
    const bp = tick * 0.03 + frameOffset * 3;
    const breathe = Math.sin(bp) * 1.0 + Math.sin(bp * 0.6 + 0.5) * 0.4;
    const sway = Math.sin(tick * 0.01 + frameOffset * 2.5) * 0.008
               + Math.sin(tick * 0.023 + frameOffset) * 0.003;
    const bc = Math.sin(bp);
    const squashX = 1 + bc * 0.005;
    const squashY = 1 - bc * 0.005;

    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = '#4A3A28';
    ctx.beginPath();
    ctx.ellipse(gx, gy + 3, sprW * 0.6, 4, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.translate(gx, gy + breathe);
    if (dir < 0) ctx.scale(-1, 1);
    ctx.rotate(sway);
    ctx.scale(squashX, squashY);
    ctx.drawImage(img, -sprW/2, -sprH);
    ctx.restore();
  }
}

function drawFallbackPerson(x, y, who) {
  const colors = {
    ntemis: { shirt: '#2A4466', pants: '#1a2a3a', skin: '#DDAA88' },
    ajax:   { shirt: '#4A6644', pants: '#2a3a2a', skin: '#DDBB99' },
    clio:   { shirt: '#664466', pants: '#3a2a3a', skin: '#DDC0A0' },
  };
  const c = colors[who] || colors.ntemis;
  const h = who === 'ntemis' ? 40 : 32;
  // Simple rectangle person
  ctx.fillStyle = c.skin;
  ctx.fillRect(x - 4, y - h, 8, 10); // head
  ctx.fillStyle = c.shirt;
  ctx.fillRect(x - 6, y - h + 10, 12, 14); // body
  ctx.fillStyle = c.pants;
  ctx.fillRect(x - 5, y - h + 24, 10, h - 24); // legs
}

function drawCharacter(who, tick) {
  const c = chars[who];
  if (!c.visible) return;
  const offsets = { ntemis: 0, ajax: 1.05, clio: 2.1 };
  // Fade-in alpha with smoothstep
  let alpha = Math.min(1, c.fadeIn);
  if (alpha < 1) {
    alpha = alpha * alpha * (3 - 2 * alpha); // smoothstep
    ctx.save();
    ctx.globalAlpha = alpha;
  }
  drawSprite(who, c.x, c.y, c.dir, c.walking, c.frame, tick, offsets[who]);
  if (alpha < 1) ctx.restore();
}

// ════════════════════════════════════════════════════════════
// WALKING SYSTEM
// ════════════════════════════════════════════════════════════
function startWalk(who, targetX, cb) {
  const c = chars[who];
  const dist = Math.abs(targetX - c.x);
  if (dist < 5) { if (cb) cb(); return; }
  targetX = Math.max(30, Math.min(GW - 30, targetX));
  c.dir = targetX > c.x ? 1 : -1;
  c.walking = true;
  c.startX = c.x;
  c.targetX = targetX;
  c.walkT = 0;
  c.walkDur = Math.max(0.4, Math.min(2.0, (dist / GW) * 2.5));
  c.frame = 0;
  walkDoneCallback = cb;
}

function updateWalking(dt) {
  for (const who of ['ntemis','ajax','clio']) {
    const c = chars[who];
    if (!c.walking) continue;
    c.walkT += dt;
    const p = Math.min(1, c.walkT / c.walkDur);
    const ep = easeInOutCubic(p);
    c.x = c.startX + (c.targetX - c.startX) * ep;

    // Store raw walk time for smooth interpolation in drawSprite
    c.frame = c.walkT;

    if (p >= 1) {
      c.x = c.targetX;
      c.walking = false;
      c.targetX = null;
      c.dir = 1;
      if (who === 'ntemis' && walkDoneCallback) {
        const cb = walkDoneCallback;
        walkDoneCallback = null;
        cb();
      }
    }
  }
}

// Family follow: Ajax and Clio follow Ntemis with offset
function familyFollow(targetX) {
  const nX = targetX;
  // Ajax follows to the right, Clio to the left
  const ajaxTarget = Math.min(GW - 30, nX + 70);
  const clioTarget = Math.max(30, nX - 70);
  setTimeout(() => startWalk('ajax', ajaxTarget), 150);
  setTimeout(() => startWalk('clio', clioTarget), 280);
}

// ════════════════════════════════════════════════════════════
// HOTSPOT HIT TESTING
// ════════════════════════════════════════════════════════════
function hitTestObj(gx, gy) {
  if (!state.scene) return null;
  const sc = scenes[state.scene];
  for (const obj of sc.objects) {
    if (gx >= obj.x && gx <= obj.x + obj.w && gy >= obj.y && gy <= obj.y + obj.h) {
      return obj;
    }
  }
  return null;
}

function hitTestExit(gx, gy) {
  if (!state.scene) return null;
  const sc = scenes[state.scene];
  if (!sc.exits) return null;
  for (const exit of sc.exits) {
    if (exit.side === 'left' && gx < 25) return exit;
    if (exit.side === 'right' && gx > GW - 25) return exit;
  }
  return null;
}

// ════════════════════════════════════════════════════════════
// VOICE SYSTEM
// ════════════════════════════════════════════════════════════
const voiceAudio = new Audio();
voiceAudio.volume = 0.8;

const VOICE_MAP = {
  // ── Ntemis (Eric) ──
  'Φτάσαμε, παιδιά. Αυτό είναι το σπίτι μας για το Σαββατοκύριακο.': 'music/voices/ntemis/01-ftasame.mp3',
  'Ας μπούμε μέσα.': 'music/voices/ntemis/02-as-mpoume.mp3',
  'Καλωσορίσατε στο Γαλαξίδι.': 'music/voices/ntemis/03-kalosorisate.mp3',
  'Δεν μπορώ να μιλήσω σε αυτό.': 'music/voices/ntemis/04-den-mporo.mp3',
  'Δεν ανοίγει.': 'music/voices/ntemis/05-den-anoigei.mp3',
  'Δεν ξέρω πώς.': 'music/voices/ntemis/06-den-xero.mp3',
  'Φυσικά.': 'music/voices/ntemis/07-fysika.mp3',
  'Δεν είναι δική μας. Ας κοιτάξω μέσα πρώτα.': 'music/voices/ntemis/08-den-einai-diki.mp3',
  '«Σας περιμέναμε»... Ποιος μας περιμένει;': 'music/voices/ntemis/09-sas-perimenavame.mp3',
  // ── Ajax (Charlie) ──
  'Τέλειο! Πάμε κατευθείαν στο λιμάνι;': 'music/voices/ajax/01-teleio-pame.mp3',
  'Μπαμπά, θα πάμε βόλτα με βάρκα;': 'music/voices/ajax/02-volta-varka.mp3',
  'Άδειο. Κρίμα!': 'music/voices/ajax/03-adeio-krima.mp3',
  'Δελφίνια μέσα στο λιμάνι; Αυτό δεν είναι συνηθισμένο...': 'music/voices/ajax/04-delfinia.mp3',
  'Μπαμπά, μπορώ να φάω ένα;': 'music/voices/ajax/05-fao-ena.mp3',
  'Και κάτι πάνω στην καρέκλα... μια τσάντα;': 'music/voices/ajax/06-tsanta.mp3',
  'Πάμε στο λιμάνι!': 'music/voices/ajax/07-pame-limani.mp3',
  // ── Clio (Jessica) ──
  'Πρώτα ας αφήσουμε τις βαλίτσες. Θέλω να δω τη βεράντα.': 'music/voices/clio/01-valitses.mp3',
  'Μπαμπά, μην τις κόβεις! Είναι τέλειες έτσι.': 'music/voices/clio/02-min-tis-koveis.mp3',
  'Μπαμπά, κοίτα! Δελφίνια!': 'music/voices/clio/03-delfinia.mp3',
  'Αυτό είναι το πιο όμορφο μέρος στον κόσμο.': 'music/voices/clio/04-pio-omorfo.mp3',
  'Μπαμπά, κοίτα — υπάρχει κάτι μέσα.': 'music/voices/clio/05-kati-mesa.mp3',
  'Κοιτάξτε — κάποιος μας άφησε σύκα!': 'music/voices/clio/06-syka.mp3',
  'Ο «Γ.» ξέρει ότι είμαστε τρεις. Πρέπει να πάμε.': 'music/voices/clio/07-gamma-xerei.mp3',
  'Οι Αμφικτίονες ξεκινούσαν από τους Δελφούς... Το Γαλαξίδι ήταν λιμάνι τους.': 'music/voices/clio/08-amfiktiones.mp3',
  'Μπαμπά, μην ακουμπάς, φαίνεται παλιό!': 'music/voices/clio/09-min-akoumpas.mp3',
  // ── Narrator (George) ──
  'Ξύλινη πόρτα βαμμένη μπλε. Το χρώμα του Αιγαίου.': 'music/voices/narrator/01-porta-mple.mp3',
  'Ροζ μπουκαμβίλιες σκαρφαλώνουν στον τοίχο. Εδώ το καλοκαίρι αρνείται να φύγει.': 'music/voices/narrator/02-boukamvilies.mp3',
  'Πήλινες γλάστρες με βασιλικό. Κάποιος τα περιποιείται ακόμα κι όταν το σπίτι μένει κλειστό.': 'music/voices/narrator/03-vasiliko.mp3',
  'Ένα παλιό ξύλινο βαρέλι. Μυρίζει κρασί και αλμύρα.': 'music/voices/narrator/04-vareli.mp3',
  'Χρωματιστά ψαροκάικα δεμένα στο λιμάνι. Κουνιούνται αργά στο απογευματινό φως.': 'music/voices/narrator/05-korinthiakos.mp3',
  'Ο Κορινθιακός κόλπος λάμπει χρυσαφί στο ηλιοβασίλεμα. Μαγικό.': 'music/voices/narrator/05-korinthiakos.mp3',
  'Ο ήλιος βάφει χρυσά τα καλντερίμια. Μυρωδιά πεύκου ανακατεμένη με θαλασσινό αλάτι.': 'music/voices/narrator/06-ilios-kalderimia.mp3',
  'Τρία δελφίνια κόβουν βόλτες στο λιμάνι.': 'music/voices/narrator/07-delfinia.mp3',
  'Τα δελφίνια συνεχίζουν τους κύκλους τους. Σαν να φυλάνε κάτι.': 'music/voices/narrator/08-delfinia-kyklous.mp3',
  'Κεραμίδια, σκεπές, καμινάδες. Κάθε σπίτι κι ένας καπετάνιος κάποτε.': 'music/voices/narrator/09-keramidia.mp3',
  'Ο Παρνασσός στο βάθος. Οι Δελφοί κάπου εκεί πάνω.': 'music/voices/narrator/10-parnassos.mp3',
  'Πέτρινο κάγκελο με θέα ολόκληρο το Γαλαξίδι. Θα μπορούσες να κάτσεις εδώ ώρες.': 'music/voices/narrator/11-kagelo.mp3',
  'Η θέα κόβει την ανάσα.': 'music/voices/narrator/12-thea-kovei.mp3',
  'Φρέσκα σύκα σε πήλινο μπολ. Η μυρωδιά γεμίζει το δωμάτιο.': 'music/voices/narrator/13-syka.mp3',
  'Τρως ένα σύκο. Γλυκό σαν μέλι.': 'music/voices/narrator/14-syko-meli.mp3',
  'Μια παλιά δερμάτινη τσάντα πάνω στην καρέκλα. Δεν είναι δική σας.': 'music/voices/narrator/15-tsanta.mp3',
  'Η τσάντα είναι άδεια τώρα.': 'music/voices/narrator/16-tsanta-adeia.mp3',
  'Απογευματινό φως μέσα από γαλάζια πατζούρια. Σκιές χορεύουν στον τοίχο.': 'music/voices/narrator/17-patzouria.mp3',
  'Ανοίγεις τα πατζούρια. Μυρωδιά θυμαριού και τζιτζίκια.': 'music/voices/narrator/18-anoigeis-patzouria.mp3',
  'Χάλκινα σκεύη κρεμασμένα στον τοίχο. Κάποτε τάιζαν οικογένειες ναυτικών.': 'music/voices/narrator/19-halkina.mp3',
  'Πέτρινο τζάκι. Μέσα υπάρχουν ακόμα στάχτες από τον τελευταίο χειμώνα.': 'music/voices/narrator/20-tzaki.mp3',
  'Η κουζίνα μυρίζει θυμάρι και παλιό ξύλο.': 'music/voices/narrator/21-kouzina.mp3',
  'Τίποτα ιδιαίτερο.': 'music/voices/narrator/22-tipota.mp3',
  '«Σας περιμέναμε. Ελάτε στο λιμάνι απόψε. Τραπέζι για τρεις. — Γ.»': 'music/voices/narrator/23-sas-perimenavame.mp3',
  'Το χαρτί μυρίζει θάλασσα. Παλιομοδίτικο γράψιμο.': 'music/voices/narrator/24-harti-thalassa.mp3',
  'Ο ήλιος βυθίζεται πίσω από τα βουνά. Το λιμάνι περιμένει.': 'music/voices/narrator/25-ilios-vythizetai.mp3',
  'Γεράνια σε πήλινη γλάστρα. Τα χρώματα λάμπουν στο ηλιοβασίλεμα.': 'music/voices/narrator/26-gerania.mp3',
  'Ο Κορινθιακός λάμπει σαν λιωμένο χρυσάφι. Ψαροκάικα κουνιούνται αργά στο λιμάνι.': 'music/voices/narrator/27-korinthiakos-hrysafi.mp3',
};

function playVoice(text) {
  voiceAudio.pause();
  voiceAudio.currentTime = 0;
  const src = VOICE_MAP[text];
  if (src) {
    voiceAudio.src = src;
    voiceAudio.play().catch(() => {});
  }
}

function stopVoice() {
  voiceAudio.pause();
  voiceAudio.currentTime = 0;
}

// ════════════════════════════════════════════════════════════
// DIALOGUE SYSTEM
// ════════════════════════════════════════════════════════════
function showDlg(lines, cb) {
  const filtered = lines.filter(l => l.t);
  if (!filtered.length) { if (cb) cb(); return; }
  state.dlg.queue = [...filtered];
  state.dlg.active = true;
  state.dlg.cb = cb || null;
  nextDlgLine();
}

function nextDlgLine() {
  if (!state.dlg.queue.length) { closeDlg(); return; }
  const l = state.dlg.queue.shift();
  state.dlg.speaker = l.s || '';
  state.dlg.text = l.t;
  state.dlg.displayed = '';
  state.dlg.charIdx = 0;
  state.dlg.timer = 0;
  playVoice(l.t);
}

function updateDlg(dt) {
  if (!state.dlg.active) return;
  if (state.dlg.charIdx < state.dlg.text.length) {
    state.dlg.timer += dt;
    while (state.dlg.timer >= 0.03 && state.dlg.charIdx < state.dlg.text.length) {
      state.dlg.timer -= 0.03;
      state.dlg.charIdx++;
      state.dlg.displayed = state.dlg.text.substring(0, state.dlg.charIdx);
    }
  }
}

function advanceDlg() {
  if (!state.dlg.active) return;
  if (state.dlg.charIdx < state.dlg.text.length) {
    // Skip typewriter
    state.dlg.charIdx = state.dlg.text.length;
    state.dlg.displayed = state.dlg.text;
  } else {
    nextDlgLine();
  }
}

function closeDlg() {
  state.dlg.active = false;
  state.dlg.queue = [];
  stopVoice();
  if (state.dlg.cb) { const cb = state.dlg.cb; state.dlg.cb = null; cb(); }
  checkEnd();
}

function drawDialogue() {
  if (!state.dlg.active) return;
  const boxH = 90;
  const boxY = GH - boxH;

  // Background
  ctx.save();
  ctx.globalAlpha = 0.92;
  ctx.fillStyle = '#0a0806';
  ctx.fillRect(0, boxY, GW, boxH);
  ctx.restore();

  // Top border
  ctx.fillStyle = '#D4A03C';
  ctx.fillRect(0, boxY, GW, 2);

  // Portrait — only show for named speakers
  const portSize = 56;
  const portX = 12;
  const portY = boxY + 8;
  const hasSpeaker = !!state.dlg.speaker;

  let textX;
  if (hasSpeaker) {
    ctx.strokeStyle = '#D4A03C';
    ctx.lineWidth = 2;
    ctx.strokeRect(portX, portY, portSize, portSize);
    ctx.fillStyle = '#1a1714';
    ctx.fillRect(portX + 1, portY + 1, portSize - 2, portSize - 2);

    const portImg = PORTRAITS[state.dlg.speaker];
    if (portImg && portImg.complete) {
      ctx.drawImage(portImg, portX + 2, portY + 2, portSize - 4, portSize - 4);
    } else {
      ctx.fillStyle = '#4a4a4a';
      ctx.font = '16px serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('?', portX + portSize/2, portY + portSize/2);
    }

    textX = portX + portSize + 12;

    ctx.fillStyle = '#D4A03C';
    ctx.font = '9px "Press Start 2P", monospace';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText(state.dlg.speaker, textX, portY + 2);
  } else {
    // Narration — no portrait box, full width
    textX = 16;
  }

  // Dialogue text with word wrapping
  ctx.fillStyle = hasSpeaker ? '#e8dcc8' : '#D4A03C';
  ctx.font = '8px "Press Start 2P", monospace';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  const maxW = GW - textX - 16;
  const lineH = 16;
  const startY = portY + (state.dlg.speaker ? 18 : 6);
  wrapText(state.dlg.displayed, textX, startY, maxW, lineH);

  // Continue indicator
  if (state.dlg.charIdx >= state.dlg.text.length) {
    const blink = Math.sin(state.tick * 0.12) > 0;
    if (blink) {
      ctx.fillStyle = '#4a4a4a';
      ctx.font = '8px "Press Start 2P", monospace';
      ctx.textAlign = 'right';
      ctx.fillText('▶', GW - 12, boxY + boxH - 14);
    }
  }
}

function wrapText(text, x, y, maxW, lineH) {
  const words = text.split(' ');
  let line = '';
  let curY = y;
  for (const word of words) {
    const test = line ? line + ' ' + word : word;
    const m = ctx.measureText(test);
    if (m.width > maxW && line) {
      ctx.fillText(line, x, curY);
      line = word;
      curY += lineH;
    } else {
      line = test;
    }
  }
  if (line) ctx.fillText(line, x, curY);
}

// ════════════════════════════════════════════════════════════
// VERB SYSTEM
// ════════════════════════════════════════════════════════════
const verbLabels = { look:'Κοίταξε', talk:'Μίλησε', open:'Άνοιξε', use:'Χρησιμοποίησε' };
// Verb fallbacks: "use" tries pick/push/close; "open" tries use
const verbFallbacks = { use: ['pick','push','close','open'], open: ['use'] };

function setVerb(v) {
  state.verb = v;
  document.querySelectorAll('.vb').forEach(b => b.classList.remove('on'));
  document.querySelector(`[data-v="${v}"]`)?.classList.add('on');
  updateActionLine();
}

function updateActionLine() {
  const al = document.getElementById('action-line');
  const obj = state.hoverObj;
  al.textContent = obj ? `${verbLabels[state.verb]} ${obj.label}` : (verbLabels[state.verb] || '');
}

function objClick(obj) {
  if (state.dlg.active) return;
  const objCenterX = obj.x + obj.w / 2;

  // Walk Ntemis to object, then execute verb
  startWalk('ntemis', objCenterX, () => {
    let d = obj.verbs[state.verb];
    // Verb fallback: "use" tries open/push/close if no direct match
    if (!d && verbFallbacks[state.verb]) {
      for (const fb of verbFallbacks[state.verb]) {
        if (obj.verbs[fb]) { d = obj.verbs[fb]; break; }
      }
    }
    if (!d) {
      const defs = {
        look:[{s:'',t:'Τίποτα ιδιαίτερο.'}],
        talk:[{s:'ΝΤΕΜΗΣ',t:'Δεν μπορώ να μιλήσω σε αυτό.'}],
        open:[{s:'ΝΤΕΜΗΣ',t:'Δεν ανοίγει.'}],
        use:[{s:'ΝΤΕΜΗΣ',t:'Δεν ξέρω πώς.'}],
      };
      if (defs[state.verb]?.length) showDlg(defs[state.verb]);
      return;
    }
    if (typeof d === 'string') { changeScene(d); return; }
    if (typeof d === 'function') d = d();
    if (Array.isArray(d) && d.length) showDlg(d);
  });
  familyFollow(objCenterX);
}

// ════════════════════════════════════════════════════════════
// INVENTORY
// ════════════════════════════════════════════════════════════
function addInv(item) {
  if (state.inv.find(i => i.id === item.id)) return;
  state.inv.push(item);
  renderInvUI();
}

// Inventory item icons — pixel art drawn on mini canvases (52x52)
const INV_ICONS = {
  note: (c) => {
    // Rolled scroll with wax seal
    c.fillStyle='#c4a870'; c.fillRect(12,4,28,40);
    c.fillStyle='#d8c490'; c.fillRect(14,6,24,36);
    // Roll top
    c.fillStyle='#b09058'; c.fillRect(10,4,32,5);
    c.fillStyle='#c4a870';
    c.beginPath(); c.ellipse(10,7,3,4,0,0,Math.PI*2); c.fill();
    c.beginPath(); c.ellipse(42,7,3,4,0,0,Math.PI*2); c.fill();
    // Text lines
    c.fillStyle='#8a7a58';
    for(let y=14;y<38;y+=5) c.fillRect(18,y,18,2);
    // Wax seal
    c.fillStyle='#b03030'; c.beginPath(); c.arc(36,38,5,0,Math.PI*2); c.fill();
    c.fillStyle='#d04040'; c.beginPath(); c.arc(35,37,3,0,Math.PI*2); c.fill();
    // "Γ" on seal
    c.fillStyle='#e8c8c8'; c.font='bold 5px sans-serif'; c.textAlign='center'; c.textBaseline='middle';
    c.fillText('Γ',36,38);
  },
  compass: (c) => {
    // Brass compass body
    c.fillStyle='#8a6a30'; c.beginPath(); c.arc(26,26,18,0,Math.PI*2); c.fill();
    c.fillStyle='#b08838'; c.beginPath(); c.arc(26,26,16,0,Math.PI*2); c.fill();
    c.fillStyle='#1a1810'; c.beginPath(); c.arc(26,26,14,0,Math.PI*2); c.fill();
    // Compass rose
    c.fillStyle='#c03030'; c.beginPath(); c.moveTo(26,12); c.lineTo(28,26); c.lineTo(24,26); c.fill();
    c.fillStyle='#e0d0c0'; c.beginPath(); c.moveTo(26,40); c.lineTo(28,26); c.lineTo(24,26); c.fill();
    c.fillStyle='#607090'; c.beginPath(); c.moveTo(12,26); c.lineTo(26,24); c.lineTo(26,28); c.fill();
    c.fillStyle='#607090'; c.beginPath(); c.moveTo(40,26); c.lineTo(26,24); c.lineTo(26,28); c.fill();
    // Center pin
    c.fillStyle='#d4a03c'; c.beginPath(); c.arc(26,26,2,0,Math.PI*2); c.fill();
    // N marker
    c.fillStyle='#c03030'; c.font='bold 5px sans-serif'; c.textAlign='center'; c.fillText('N',26,11);
  },
  shell: (c) => {
    // Scallop shell
    c.fillStyle='#e8d0b0'; c.beginPath(); c.ellipse(26,28,16,12,0,0,Math.PI*2); c.fill();
    c.fillStyle='#d4b89c'; c.beginPath(); c.ellipse(26,30,14,10,0,0,Math.PI); c.fill();
    // Ridges
    c.strokeStyle='#a08060'; c.lineWidth=1.5;
    for(let i=0;i<7;i++){c.beginPath();c.moveTo(26,16);c.lineTo(12+i*5,40);c.stroke();}
    // Highlight
    c.fillStyle='rgba(255,255,255,0.2)'; c.beginPath(); c.ellipse(22,24,6,4,-.3,0,Math.PI*2); c.fill();
  },
  candle: (c) => {
    // Candlestick with flame
    c.fillStyle='#8a6a30'; c.fillRect(20,36,12,8); // base
    c.fillStyle='#a08038'; c.fillRect(22,34,8,4); // holder
    c.fillStyle='#e8dcc0'; c.fillRect(24,16,4,20); // wax body
    c.fillStyle='#d4c8a0'; c.fillRect(23,16,6,3); // wax top
    // Wick
    c.fillStyle='#2a2a2a'; c.fillRect(25,12,2,5);
    // Flame
    c.fillStyle='#d4a03c'; c.beginPath(); c.ellipse(26,10,5,8,0,0,Math.PI*2); c.fill();
    c.fillStyle='#f0d060'; c.beginPath(); c.ellipse(26,10,3,5,0,0,Math.PI*2); c.fill();
    c.fillStyle='#fff8e0'; c.beginPath(); c.ellipse(26,11,1,3,0,0,Math.PI*2); c.fill();
  },
  key: (c) => {
    // Ornate brass key
    c.fillStyle='#c49030'; c.strokeStyle='#8a6020'; c.lineWidth=1;
    // Bow (head)
    c.beginPath(); c.arc(16,20,8,0,Math.PI*2); c.fill(); c.stroke();
    c.fillStyle='#1a1208'; c.beginPath(); c.arc(16,20,4,0,Math.PI*2); c.fill();
    // Shaft
    c.fillStyle='#c49030'; c.fillRect(23,18,20,4);
    c.strokeStyle='#8a6020'; c.strokeRect(23,18,20,4);
    // Teeth
    c.fillStyle='#c49030';
    c.fillRect(38,22,3,6); c.fillRect(34,22,2,4); c.fillRect(42,18,2,4);
    c.strokeStyle='#8a6020';
    c.strokeRect(38,22,3,6); c.strokeRect(34,22,2,4);
  },
};

function renderInvUI() {
  const grid = document.getElementById('inv-grid');
  grid.innerHTML = '';
  for (const item of state.inv) {
    const slot = document.createElement('div');
    slot.className = 'inv-slot';
    slot.dataset.id = item.id;
    slot.onclick = () => invClick(item.id);
    if (INV_ICONS[item.id]) {
      const cvs = document.createElement('canvas');
      cvs.width = 52; cvs.height = 52;
      cvs.style.cssText = 'width:52px;height:52px;image-rendering:pixelated';
      INV_ICONS[item.id](cvs.getContext('2d'));
      slot.appendChild(cvs);
    } else {
      const txt = document.createElement('span');
      txt.className = 'inv-text';
      txt.textContent = item.label;
      slot.appendChild(txt);
    }
    slot.title = item.label;
    grid.appendChild(slot);
  }
}

function scrollInv(dir) {
  const grid = document.getElementById('inv-grid');
  grid.scrollLeft += dir * 50;
}

function invClick(id) {
  if (id === 'note' && state.verb === 'look') {
    showDlg([{s:'',t:'«Σας περιμέναμε. Ελάτε στο λιμάνι απόψε. Τραπέζι για τρεις. — Γ.»'},{s:'',t:'Το χαρτί μυρίζει θάλασσα. Παλιομοδίτικο γράψιμο.'}]);
  }
  document.querySelectorAll('.inv-slot').forEach(s => s.classList.remove('on'));
  document.querySelector(`[data-id="${id}"]`)?.classList.add('on');
}

// ════════════════════════════════════════════════════════════
// SCENE MANAGEMENT
// ════════════════════════════════════════════════════════════
function startScene(id) {
  const sc = scenes[id];
  state.scene = id;
  state.hoverObj = null;

  document.getElementById('ui-panel').classList.add('on');
  document.getElementById('action-line').classList.add('on');

  // Position characters
  for (const [who, pos] of Object.entries(sc.charPos)) {
    chars[who].x = pos.x;
    chars[who].y = pos.y;
    chars[who].walking = false;
    chars[who].visible = true;
    chars[who].fadeIn = 0; // start fade-in
    chars[who].dir = 1;
  }

  initParticles();
  initAmbientSound();
  startSceneAmbience(id);
  changeSceneMusic(id);

  // Entry dialogue
  if (!state.visited.has(id) && sc.entry) {
    state.visited.add(id);
    setTimeout(() => showDlg(sc.entry), 600);
  } else {
    state.visited.add(id);
  }
}

function changeScene(id) {
  state.fade.active = true;
  state.fade.alpha = 0;
  state.fade.dir = 1; // fade out
  state.fade.cb = () => {
    startScene(id);
    state.fade.dir = -1; // fade in
    state.fade.cb = () => { state.fade.active = false; };
  };
}

function checkEnd() {
  if (state.flags.note && !state.flags.done) {
    state.flags.done = 1;
    setTimeout(() => showDlg([
      {s:'ΝΤΕΜΗΣ',t:'«Σας περιμέναμε»... Ποιος μας περιμένει;'},
      {s:'ΚΛΕΙΩ',t:'Ο «Γ.» ξέρει ότι είμαστε τρεις. Πρέπει να πάμε.'},
      {s:'ΑΙΑΣ',t:'Πάμε στο λιμάνι!'},
      {s:'',t:'Ο ήλιος βυθίζεται πίσω από τα βουνά. Το λιμάνι περιμένει.'},
      {s:'',t:'— Τέλος Σκηνής 1 —'},
      {s:'',t:'Συνέχεια στη Σκηνή 2: Το Γράμμα...'},
    ]), 1500);
  }
}

// ════════════════════════════════════════════════════════════
// RENDER — Main drawing function
// ════════════════════════════════════════════════════════════
function render() {
  ctx.clearRect(0, 0, GW, GH);

  // Canvas-rendered title screen
  if (state.phase === 'title') {
    drawTitleScreen(state.tick);
    return;
  }

  if (state.phase !== 'playing') return;
  if (!state.scene) return;

  const sc = scenes[state.scene];

  // Background
  const bgImg = images[sc.bg];
  if (bgImg) {
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(bgImg, 0, 0, GW, GH);
  } else {
    ctx.fillStyle = '#1a1510';
    ctx.fillRect(0, 0, GW, GH);
  }

  // Ambient overlay
  const grad = ctx.createLinearGradient(0, 0, 0, GH);
  grad.addColorStop(0, 'rgba(212,160,60,0.03)');
  grad.addColorStop(0.3, 'rgba(0,0,0,0)');
  grad.addColorStop(0.7, 'rgba(0,0,0,0)');
  grad.addColorStop(1, 'rgba(0,0,0,0.15)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, GW, GH);

  // Scene-specific ambience (behind characters)
  drawSceneAmbience(state.tick);

  // Dust particles
  drawParticles();

  // Hotspot highlight on hover
  if (state.hoverObj) {
    const obj = state.hoverObj;
    ctx.save();
    ctx.strokeStyle = 'rgba(212,160,60,0.4)';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
    ctx.setLineDash([]);
    ctx.restore();
  }

  // Exit zone highlights
  if (sc.exits) {
    for (const exit of sc.exits) {
      const isHover = (exit.side === 'left' && state.mouseGX < 25) ||
                      (exit.side === 'right' && state.mouseGX > GW - 25);
      if (isHover) {
        ctx.save();
        const exGrad = exit.side === 'left'
          ? ctx.createLinearGradient(0, 0, 25, 0)
          : ctx.createLinearGradient(GW, 0, GW - 25, 0);
        exGrad.addColorStop(0, 'rgba(212,160,60,0.15)');
        exGrad.addColorStop(1, 'rgba(212,160,60,0)');
        ctx.fillStyle = exGrad;
        if (exit.side === 'left') ctx.fillRect(0, 0, 25, GH);
        else ctx.fillRect(GW - 25, 0, 25, GH);
        // Arrow
        ctx.fillStyle = '#D4A03C';
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        if (exit.side === 'left') ctx.fillText('◀', 12, GH / 2);
        else ctx.fillText('▶', GW - 12, GH / 2);
        ctx.restore();
      }
    }
  }

  // Characters — back to front for depth
  drawCharacter('clio', state.tick);
  drawCharacter('ajax', state.tick);
  drawCharacter('ntemis', state.tick);

  // Scene label
  ctx.save();
  ctx.fillStyle = '#D4A03C';
  ctx.font = '8px "Press Start 2P", monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.shadowColor = '#000';
  ctx.shadowBlur = 4;
  ctx.shadowOffsetX = 2;
  ctx.shadowOffsetY = 2;
  ctx.fillText(sc.label, GW / 2, 8);
  ctx.restore();

  // Music toggle icon
  ctx.save();
  ctx.globalAlpha = state.musicOn ? 0.5 : 0.2;
  ctx.fillStyle = '#D4A03C';
  ctx.font = '14px sans-serif';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'top';
  ctx.fillText('♪', GW - 8, 8);
  ctx.restore();

  // Dialogue overlay
  drawDialogue();

  // Fade overlay
  if (state.fade.active && state.fade.alpha > 0) {
    ctx.save();
    ctx.globalAlpha = state.fade.alpha;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, GW, GH);
    ctx.restore();
  }
}

// ════════════════════════════════════════════════════════════
// UPDATE — Main logic update
// ════════════════════════════════════════════════════════════
function update(dt) {
  state.tick++;

  // Title screen — start music on first interaction (handled by click)
  if (state.phase === 'title') return;

  if (state.phase !== 'playing') return;

  // Walking
  updateWalking(dt);

  // Character fade-in
  for (const who of ['ntemis','ajax','clio']) {
    if (chars[who].fadeIn < 1) {
      const delays = { ntemis: 0.1, ajax: 0.3, clio: 0.5 };
      if (state.tick > delays[who] * 60) {
        chars[who].fadeIn = Math.min(1, chars[who].fadeIn + dt * 1.5);
      }
    }
  }

  // Dialogue typewriter
  updateDlg(dt);

  // Particles
  updateParticles();

  // Scene ambience (seagulls, petals, cat, sounds)
  updateSceneAmbience(dt);

  // Fade transition
  if (state.fade.active) {
    const speed = 2.0; // fade speed (slower = smoother)
    state.fade.alpha += state.fade.dir * dt * speed;
    if (state.fade.dir > 0 && state.fade.alpha >= 1) {
      state.fade.alpha = 1;
      if (state.fade.cb) { const cb = state.fade.cb; state.fade.cb = null; cb(); }
    }
    if (state.fade.dir < 0 && state.fade.alpha <= 0) {
      state.fade.alpha = 0;
      if (state.fade.cb) { const cb = state.fade.cb; state.fade.cb = null; cb(); }
    }
  }
}

// ════════════════════════════════════════════════════════════
// GAME LOOP
// ════════════════════════════════════════════════════════════
let lastTime = 0;

function gameLoop(timestamp) {
  const dt = lastTime ? Math.min((timestamp - lastTime) / 1000, 0.05) : 0.016;
  lastTime = timestamp;

  // Resize canvas to fill available space
  const rect = CVS.getBoundingClientRect();
  // Keep internal resolution fixed, CSS handles scaling

  update(dt);
  render();
  requestAnimationFrame(gameLoop);
}

// ════════════════════════════════════════════════════════════
// INPUT HANDLING
// ════════════════════════════════════════════════════════════
CVS.addEventListener('mousemove', (e) => {
  const g = screenToGame(e.clientX, e.clientY);
  state.mouseGX = g.x;
  state.mouseGY = g.y;

  if (state.phase === 'title') {
    CVS.style.cursor = 'pointer';
    return;
  }

  if (state.phase !== 'playing' || state.dlg.active) {
    state.hoverObj = null;
    updateActionLine();
    return;
  }

  // Check hotspots
  const obj = hitTestObj(g.x, g.y);
  state.hoverObj = obj;

  // Check exits for cursor change
  const exit = hitTestExit(g.x, g.y);
  if (exit) {
    CVS.style.cursor = exit.side === 'left' ? 'w-resize' : 'e-resize';
    state.hoverObj = { label: exit.label }; // fake obj for action line
  } else if (obj) {
    CVS.style.cursor = 'pointer';
  } else {
    CVS.style.cursor = 'crosshair';
  }
  updateActionLine();
});

CVS.addEventListener('click', (e) => {
  const g = screenToGame(e.clientX, e.clientY);

  // Title clicks handled by dedicated handler
  if (state.phase !== 'playing') return;

  // Dialogue advance
  if (state.dlg.active) { advanceDlg(); return; }

  // Music toggle (top-right corner)
  if (g.x > GW - 30 && g.y < 25) { toggleMusic(); return; }

  // Check exit zones
  const exit = hitTestExit(g.x, g.y);
  if (exit) { changeScene(exit.target); return; }

  // Check hotspots
  const obj = hitTestObj(g.x, g.y);
  if (obj) { objClick(obj); return; }

  // Click ground — walk Ntemis
  if (g.y > 200) { // Only walk on ground area
    startWalk('ntemis', g.x);
    familyFollow(g.x);
  }
});

// Keyboard
document.addEventListener('keydown', e => {
  if (e.key === ' ' || e.key === 'Enter') {
    e.preventDefault();
    if (state.dlg.active) advanceDlg();
  }
  const vk = {'1':'look','2':'talk','3':'open','4':'use'};
  if (vk[e.key] && state.phase === 'playing') setVerb(vk[e.key]);
});

// ════════════════════════════════════════════════════════════
// MUSIC
// ════════════════════════════════════════════════════════════
const bgm = document.getElementById('bgm');
bgm.volume = 0.25;

// Per-scene music map
const sceneMusic = {
  exterior: 'music/arrival-at-galaxidi-scene-1-1.mp3',
  terrace:  'music/arrival-at-galaxidi-scene-1-1.mp3',
  kitchen:  'music/the-grandfather-s-house-1.mp3',
  port:     'music/the-harbor-at-dusk-1.mp3',
  museum:   'music/the-maritime-museum-1.mp3',
  liotrivi: 'music/the-old-olive-press-1.mp3',
};

let currentMusicSrc = '';

function changeSceneMusic(sceneId) {
  const newSrc = sceneMusic[sceneId];
  if (!newSrc || newSrc === currentMusicSrc) return;
  // Crossfade: old out, new in
  const oldVol = bgm.volume;
  const fadeDur = 1500;
  const fadeStart = performance.now();
  const fadeOut = () => {
    const t = Math.min(1, (performance.now() - fadeStart) / fadeDur);
    bgm.volume = oldVol * (1 - t);
    if (t < 1) { requestAnimationFrame(fadeOut); return; }
    bgm.pause();
    bgm.src = newSrc;
    currentMusicSrc = newSrc;
    bgm.volume = 0;
    bgm.play().catch(() => {});
    // Fade in
    const fadeInStart = performance.now();
    const fadeIn = () => {
      const t2 = Math.min(1, (performance.now() - fadeInStart) / fadeDur);
      bgm.volume = 0.25 * t2;
      if (t2 < 1) requestAnimationFrame(fadeIn);
    };
    requestAnimationFrame(fadeIn);
  };
  requestAnimationFrame(fadeOut);
}

function toggleMusic() {
  if (state.musicOn) {
    bgm.pause(); state.musicOn = false;
  } else {
    bgm.play().catch(() => {}); state.musicOn = true;
  }
}

// ════════════════════════════════════════════════════════════
// TITLE SCREEN — Bright sunny harbor with animated title
// ════════════════════════════════════════════════════════════
const titleMusic = document.getElementById('title-music');
titleMusic.volume = 0.7;
let titleFadeOut = 0;
let titleStartTick = -1;

// Title text animation config
const titleLine1 = 'ΤΟ ΜΥΣΤΗΡΙΟ';
const titleLine2 = 'του';
const titleLine3 = 'ΓΑΛΑΞΕΙΔΙΟΥ';
const LETTER_DELAY = 4;
const LINE2_DELAY = 55;
const LINE3_DELAY = 25;
const PROMPT_DELAY = 70;

function drawTitleScreen(tick) {
  if (titleStartTick < 0) titleStartTick = tick;
  const elapsed = tick - titleStartTick;
  const t = tick * 0.02;

  // ═══════════════════════════════════════
  // BACKGROUND — pixel art image
  // ═══════════════════════════════════════
  const bg = images['title-bg'];
  if (bg && bg.complete) {
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(bg, 0, 0, GW, GH);
  } else {
    // Fallback solid color while loading
    ctx.fillStyle = '#4A9FD8';
    ctx.fillRect(0, 0, GW, GH);
  }

  // ═══════════════════════════════════════
  // ANIMATED ELEMENTS — waves, boats, seagulls
  // ═══════════════════════════════════════

  // Wave shimmer — moving light bands across the water
  const waterTop = GH * 0.58;
  ctx.save();
  for (let i = 0; i < 8; i++) {
    const wy = waterTop + 10 + i * 16;
    // Waves scroll left-to-right continuously
    const scrollX = (tick * 0.3 + i * 90) % (GW + 60) - 30;
    const ww = 40 + Math.sin(t * 0.5 + i) * 20;
    const wobble = Math.sin(t * 0.9 + i * 2.1) * 4;
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.fillRect(scrollX, wy + wobble, ww, 2);
    ctx.fillStyle = 'rgba(180,230,255,0.2)';
    ctx.fillRect(scrollX + 10, wy + wobble + 4, ww * 0.7, 2);
  }
  ctx.restore();

  // Subtle vignette overlay
  const vig = ctx.createRadialGradient(GW/2, GH/2, GW*0.3, GW/2, GH/2, GW*0.75);
  vig.addColorStop(0, 'rgba(0,0,0,0)');
  vig.addColorStop(1, 'rgba(0,0,0,0.15)');
  ctx.fillStyle = vig;
  ctx.fillRect(0, 0, GW, GH);

  // ═══════════════════════════════════════
  // ANIMATED TITLE — letters unfold cinematically
  // ═══════════════════════════════════════
  const l1N = titleLine1.length;
  const l1End = l1N * LETTER_DELAY;
  const l2Start = l1End + LINE2_DELAY;
  const l2End = l2Start + 15;
  const l3Start = l2End + LINE3_DELAY;
  const l3N = titleLine3.length;
  const l3End = l3Start + l3N * LETTER_DELAY;
  const promptAt = l3End + PROMPT_DELAY;

  ctx.save();
  ctx.textBaseline = 'middle';

  // Single letter renderer with scale-in animation
  function drawLetter(ch, cx, cy, size, progress) {
    if (progress <= 0) return;
    const p = Math.min(1, progress);
    const scale = p < 0.5 ? 1.5 - p : 1.0 + Math.sin((p-0.5)*Math.PI)*0.05;
    const alpha = Math.min(1, p * 2);
    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(scale, scale);
    ctx.globalAlpha = alpha;
    ctx.font = `bold ${size}px "Press Start 2P", monospace`;
    ctx.textAlign = 'center';
    // Shadow layers
    const shd = [['#060200',5],['#1A0804',4],['#2E1508',3],['#4A2010',2],['#7A5018',1]];
    for (const [c,d] of shd) { ctx.fillStyle = c; ctx.fillText(ch, d, d); }
    // Gold with glow
    const g = 0.3 + Math.sin(t*1.2 + cx*0.01)*0.15;
    ctx.shadowColor = `rgba(255,180,40,${g*alpha})`;
    ctx.shadowBlur = 20;
    ctx.fillStyle = '#D4A03C';
    ctx.fillText(ch, 0, 0);
    ctx.shadowBlur = 0;
    ctx.fillStyle = `rgba(255,235,170,${0.35*alpha})`;
    ctx.fillText(ch, 0, -1);
    ctx.restore();
  }

  // Line 1: "ΤΟ ΜΥΣΤΗΡΙΟ"
  const l1Size = 36, l1Y = 100;
  ctx.font = `bold ${l1Size}px "Press Start 2P", monospace`;
  ctx.textAlign = 'left';
  const l1W = ctx.measureText(titleLine1).width;
  let l1X = (GW - l1W) / 2;
  for (let i = 0; i < l1N; i++) {
    const ch = titleLine1[i];
    const chW = ctx.measureText(ch).width;
    drawLetter(ch, l1X + chW/2, l1Y, l1Size, (elapsed - i*LETTER_DELAY)/20);
    l1X += chW;
  }

  // Line 2: "του"
  if (elapsed > l2Start) {
    const p2 = Math.min(1, (elapsed - l2Start) / 25);
    ctx.save();
    ctx.globalAlpha = p2;
    ctx.translate(GW/2, l1Y + 50);
    ctx.scale(1.3 - p2*0.3, 1.3 - p2*0.3);
    ctx.font = 'bold 14px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#1A0804'; ctx.fillText(titleLine2, 2, 2);
    ctx.fillStyle = '#B8842C'; ctx.fillText(titleLine2, 0, 0);
    ctx.restore();
  }

  // Line 3: "ΓΑΛΑΞΕΙΔΙΟΥ"
  const l3Size = 38, l3Y = l1Y + 102;
  ctx.font = `bold ${l3Size}px "Press Start 2P", monospace`;
  const l3W = ctx.measureText(titleLine3).width;
  let l3X = (GW - l3W) / 2;
  for (let i = 0; i < l3N; i++) {
    const ch = titleLine3[i];
    const chW = ctx.measureText(ch).width;
    drawLetter(ch, l3X + chW/2, l3Y, l3Size, (elapsed - l3Start - i*LETTER_DELAY)/20);
    l3X += chW;
  }
  ctx.restore();


  // Blinking start prompt
  if (elapsed > promptAt) {
    const blink = 0.2 + Math.sin(tick*0.06)*0.45;
    ctx.save();
    ctx.font = '8px "Press Start 2P", monospace';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.globalAlpha = Math.max(0, blink);
    ctx.fillStyle = '#D4A03C';
    ctx.shadowColor = 'rgba(212,160,60,0.5)'; ctx.shadowBlur = 10;
    ctx.fillText('► ΚΛΙΚ ΓΙΑ ΕΝΑΡΞΗ ◄', GW/2, GH - 35);
    ctx.restore();
  }

  // Fade overlay
  if (titleFadeOut > 0) {
    ctx.save();
    ctx.globalAlpha = titleFadeOut;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, GW, GH);
    ctx.restore();
  }
}



// ════════════════════════════════════════════════════════════
// TITLE & INTRO FLOW
// ════════════════════════════════════════════════════════════
let titleClicked = false;
let titleMusicStarted = false;

// Start title music on any user gesture (needed for autoplay policy)
function ensureTitleMusic() {
  if (!titleMusicStarted && state.phase === 'title') {
    titleMusic.currentTime = 0;
    const p = titleMusic.play();
    if (p) p.then(() => { titleMusicStarted = true; console.log('Title music playing'); }).catch(e => console.warn('Title music blocked:', e));
  }
}
// Try immediately + on any interaction
ensureTitleMusic();
document.addEventListener('click', ensureTitleMusic);
document.addEventListener('keydown', ensureTitleMusic);
document.addEventListener('touchstart', ensureTitleMusic);

CVS.addEventListener('click', function titleClickHandler(e) {
  if (state.phase !== 'title' || titleClicked) return;
  // First click just starts music — need a second click to proceed
  if (!titleMusicStarted) {
    ensureTitleMusic();
    return;
  }
  titleClicked = true;

  // Keep title music playing through intro — don't fade it here

  // Animate fade to black
  const fadeStep = () => {
    titleFadeOut += 0.02;
    if (titleFadeOut < 1) {
      requestAnimationFrame(fadeStep);
    } else {
      titleFadeOut = 1;
      // Switch to intro — title music keeps playing
      state.phase = 'intro';
      state.musicOn = true;
      const intro = document.getElementById('intro-screen');
      intro.classList.add('show');
      showIntroPage();
    }
  };
  requestAnimationFrame(fadeStep);
}, { once: false });

function showIntroPage() {
  const t = document.getElementById('intro-text');
  const h = document.getElementById('intro-hint');
  t.style.opacity = '0';
  h.classList.remove('on');
  setTimeout(() => {
    t.innerHTML = introPages[state.introPage].replace(/\n/g, '<br>');
    t.style.opacity = '1';
    setTimeout(() => h.classList.add('on'), 1200);
  }, 300);
}

document.getElementById('intro-screen').onclick = () => {
  state.introPage++;
  if (state.introPage >= introPages.length) {
    const is = document.getElementById('intro-screen');
    is.style.opacity = '0';

    // Crossfade: title music out, scene music in (2 second overlap)
    currentMusicSrc = sceneMusic['exterior'];
    bgm.volume = 0;
    bgm.play().catch(() => {});
    const crossfadeDur = 2000; // 2 seconds
    const crossfadeStart = performance.now();
    const crossfadeStep = () => {
      const elapsed = performance.now() - crossfadeStart;
      const t = Math.min(1, elapsed / crossfadeDur);
      // Ease: smooth cubic
      const ease = t < 0.5 ? 4*t*t*t : 1-Math.pow(-2*t+2,3)/2;
      titleMusic.volume = Math.max(0, 0.7 * (1 - ease));
      bgm.volume = 0.25 * ease;
      if (t < 1) {
        requestAnimationFrame(crossfadeStep);
      } else {
        titleMusic.pause();
        titleMusic.volume = 0.7;
        bgm.volume = 0.25;
      }
    };
    requestAnimationFrame(crossfadeStep);

    setTimeout(() => {
      is.style.display = 'none';
      state.phase = 'playing';
      state.musicOn = true;
      startScene('exterior');
    }, 1500);
  } else {
    showIntroPage();
  }
};

// ════════════════════════════════════════════════════════════
// BOOT
// ════════════════════════════════════════════════════════════
loadAllAssets().then(() => {
  requestAnimationFrame(gameLoop);
});
</script>
</body>
</html>
